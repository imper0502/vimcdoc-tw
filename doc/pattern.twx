*pattern.txt*   For Vim version 8.0.  最近更新: 2017年8月


		  VIM 參考手冊    by Bram Moolenaar
		    譯者: lang2 http://vimcdoc.sf.net


模式及查詢命令					*pattern-searches*

最基本的東西可以在使用者手冊的 |03.9| 節中找到。在 |usr_27.txt| 也有一些解釋。

1. 查詢命令			|search-commands|
2. 匹配模式的定義		|search-pattern|
3. 魔術				|/magic|
4. 模式項總覽			|pattern-overview|
5. 倍數項			|pattern-multi-items|
6. 普通匹配原			|pattern-atoms|
7. 忽略大小寫			|/ignorecase|
8. 合成用字元			|patterns-composing|
9. 與 Perl 匹配模式的比較	|perl-patterns|
10. 高亮顯示匹配		|match-highlight|

==============================================================================
1. 查詢命令					*search-commands*

							*/*
/{pattern}[/]<CR>	正向查詢第 [count] 次出現 {pattern} 的地方
			(|exclusive| 開動作)。

/{pattern}/{offset}<CR>	正向查詢第 [count] 次出現 {pattern} 的地方並向上或下移
			動 |{offset}| 行。|linewise| 行動作。

							*/<CR>*
/<CR>			正向查詢第 [count] 次出現處，使用上次的模式
			|last-pattern| 以及上次的 |{offset}|。

//{offset}<CR>		正向查詢第 [count] 次出現處，使用上次的模式
			|last-pattern| 以及新偏移 |{offset}|。若 {offset} 為
			空，不使用任何偏移。

							*?*
?{pattern}[?]<CR>	反向查詢第 [count] 次出現 {pattern} 的地方
			(|exclusive| 開動作)

?{pattern}?{offset}<CR>	反向查詢第 [count] 次出現 {pattern} 的地方
			並向上或下移動 |{offset}| 行 |linewise| 行動作。

							*?<CR>*
?<CR>			反向查詢第 [count] 次出現處，使用上次的模式
			|last-pattern| 以及上次的 |{offset}|。

??{offset}<CR>		反向查詢第 [count] 次出現處，使用上次的模式
			|last-pattern| 以及新偏移 |{offset}|。若 {offset} 為
			空，不使用任何偏移。

							*n*
n			將上次的 "/" 或 "?" 重複 [count] 次。
			如果游標不移動，搜尋重複 count + 1 次。
			|last-pattern| {Vi: 無計數}

							*N*
N			將上次的 "/" 或 "?" 在相反方向上重複 [count] 次。
			|last-pattern| {Vi: 無計數}

							*star* *E348* *E349*
*			正向查詢第 [count] 次出現距離當前游標最近的單詞的地
			方。用於查詢的單詞是以下最先符合條件的:
				1. 游標所在的關鍵字 |'iskeyword'|
				2. 當前行內的游標後的第一個關鍵字。
				3. 游標所在的非空白單詞
				4. 當前行內的游標後的第一個非空白單詞
			只查詢整字，就像使用了命令 "/\<keyword\>" 一樣。
			(|exclusive| 開動作) {Vi 無此功能}
			使用 'ignorecase'，不使用 'smartcase'。

							*#*
#			同 "*"，但反向查詢。也可以用磅符號 (字元 163)。如果
			"#" 的功能和退格鍵一樣，試著在啟動 Vim 前使用
			"stty erase <BS>" (<BS> 是 CTRL-H 或真的退格鍵)。
			{Vi 無此功能}

							*gstar*
g*			同 "*"，但不使用 "\<" 和 "\>"。這樣查詢就會匹配非整字
			的地方。{Vi 無此功能}

							*g#*
g#			同 "#"，但不使用 "\<" 和 "\>"。這樣查詢就會匹配非整字
			的地方。{Vi 無此功能}

							*gd*
gd			跳轉 (goto) 至區域性宣告 (declaration)。當游標下是一個局
			部變數時，此命令會跳轉到該變數被宣告的地方。
			首先，Vim 會查詢當前函式的起始處，就像使用 "[[" 一樣。
			如果找不到會停止在第一行。如果找到， Vim 會反向搜尋直
			到找到一個空行，然後從這裡開始正向查詢游標所在的關鍵
			字，就像使用了 "*" 一樣，但看起來象註釋的行會被忽略。
			(見 'comments' 選項)。
			注意 這並非總有效。Vim 不會做語法分析。它僅僅查詢關鍵
			字的匹配。如果標頭檔案也需要搜尋的話，可以使用
			|include-search| 列出的命令。
			這個命令之後，可以使用 |n| 正向查詢下一個匹配 (不能反
			向)。
			{Vi 無此功能}

							*gD*
gD			跳轉 (goto) 至全域性宣告 (Declaration)。當游標下是一個全
			局變數時，此命令會跳轉到該變數被宣告的地方。此命令和
			"gd" 命令一樣，不過查詢總是從第一行開始。{Vi 無此功能}

							*1gd*
1gd			同 "gd"，但忽略游標位置前結束的 {} 塊裡的匹配。
			{Vi 無此功能}

							*1gD*
1gD			同 "gD"，但忽略游標位置前結束的 {} 塊裡的匹配。
			{Vi 無此功能}

							*CTRL-C*
CTRL-C			中止當前的 (搜尋) 命令。在 MS-DOS 上用 CTRL-Break
			|dos-CTRL-Break|。
			在普通模式下，任何等待的命令將被終止。

							*:noh* *:nohlsearch*
:noh[lsearch]		停止 'hlsearch' 選項的高亮顯示。如果再執行查詢命令或者
			設定 'hlsearch' 選項，高亮會自動開啟。此命令無法在自動
			命令裡使用，因為高亮的狀態會在自動命令執行期間自動儲存
			和恢復 |autocmd-searchpat|。
			執行使用者函式時也是如此。

如果開啟 'incsearch' 選項，鍵入查詢模式時，即時顯示當前的匹配。不過，你還得用
<CR> 來結束查詢命令並將游標定位到顯示的匹配。也可以用 <ESC> 來放棄查詢。

如果開啟 'hlsearch'，最後一次查詢命令的所有匹配點都會被高亮。用 |:nohlsearch|
命令來暫停。

如果沒找到匹配，會報錯: *E486* Pattern not found
注意 為 Vi 相容起見，|:global| 命令會把此錯誤當作一個普通的訊息。|:s| 命令的
"e" 標誌位可用來避免此錯誤 |:s_flags|。

					*search-offset* *{offset}*
這些命令查詢一個指定的模式。而 "/" 和 "?" 命令還可以指定一個額外的偏移量。有兩
種偏移: 行偏移和字元偏移。{Vi 沒有字元偏移}

偏移用來指定游標相對於找到的匹配的位置:
    [num]	[num] 行向下，第一列
    +[num]	[num] 行向下，第一列
    -[num]	[num] 行向上，第一列
    e[+num]	[num] 字元向右 (從匹配結束 (end) 處算起)
    e[-num]	[num] 字元向左 (從匹配結束 (end) 處算起)
    s[+num]	[num] 字元向右 (從匹配開始 (start) 處算起)
    s[-num]	[num] 字元向左 (從匹配開始 (start) 處算起)
    b[+num]	[num] 等價於 s[+num] (從匹配開始 (begin) 處算起)
    b[-num]	[num] 等價於 s[-num] (從匹配開始 (begin) 處算起)
    ;{pattern}  開始另一項搜尋，見 |//;|

如果給出了 '-' 或 '+' 但是省略了 [num]，會使用預設的 1。
如果使用了 'e' 偏移，查詢會成為 |inclusive| 閉動作 (游標要到達的字元本身會包含
在操作裡)。

示例:

模式			游標位置	~
/test/+1		"test" 下一行，第一列
/test/e			"test" 的後一個 't'
/test/s+2		"test" 中的 's'
/test/b-3		"test" 前的第三個字元

如果把這些命令之一和一個操作符連用，影響的是查詢之前和之後游標位置之間的字元。
然而，如果使用了行偏移，影響的是兩游標位置之間的所有整行。

一個演示如何查詢一個模式並用另一個單詞來更改匹配的例子: >
	/foo<CR>	查詢 "foo"
	c//e<CR>	修改從當前位置到匹配結尾的部分
	bar<Esc>	輸入替換文字
	//<CR>		跳轉到下一個相同匹配的開始
	c//e<CR>	修改從當前位置到匹配結尾的部分
	beep<Esc>	輸入替換文字
			等等。
<
							*//;* *E386*
一個很特別的偏移是 ';' 後面接另一個查詢命令。例如: >

   /test 1/;/test
   /test.*/+1;?ing?

其中第一例會先找到下一個出現 "test 1" 的地方，然後尋找在它之後 "test" 的第一次
出現之處。

這就好象接連執行兩次查詢命令，不同之處在於:
- 它可以被當作操作符之後的單個移動命令。
- 以後的 "n" 或 "N" 命令基於第一個查詢操作。
- 當有錯誤時游標原地不動。

							*last-pattern*
最近使用的模式和偏移會被記住。它們可以用來重複查詢，而且查詢的方向和計數都可以
修改。注意 Vim 會記住兩個模式: 一個是普通模式下查詢命令用的，另一個是替代命令
":s" 用的。每次給出一個空白的模式時，都將用到前次使用模式。不過，如果沒有前次
搜尋模式，如果可以，使用前次替代模式。

'magic' 選項的值是和最近使用模式本身繫結的。如果你改變了 'magic'，最近使用模式
的解釋方法不會改變。'ignorecase' 選項就不同。當 'ignorecase' 的值改變時，該模
式會匹配另外的文字。

如果你設定了 'hlsearch' 選項，所有最近使用的查詢模式的匹配點都會高亮。

要清除最近使用的查詢模式: >
	:let @/ = ""
這不會把該模式設定為空串，因為那樣會匹配所有的東西。該模式是真的清除了，就象
Vim 剛剛啟動一樣。

查詢通常會跳過那些不移動游標位置的匹配。下一次匹配是開始於下一個字元還是在跳過
那些匹配之後取決於 'cpoptions' 選項中的 'c' 標誌位。見 |cpo-c|。
	     帶 'c' 標誌位:   "/..." 前進 1 至 3 個字元
	   不帶 'c' 標誌位:   "/..." 前進 1 個字元
帶 'c' 標誌位對應結果難以完全確定，因為查詢可以從第一列開始，忽略任何匹配，直
到找到超過游標位置的匹配為止。

如果反向尋找，要是如上所述 'cpoptions' 裡包含了 'c' 標誌位的話，從行首開始搜
索，使用游標位置之前的最後一個匹配。

在 Vi 裡 ":tag" 命令會將最近查詢模式設定為要搜尋的標籤。除非 'cpoptions' 選項
中包括 't' 標誌位，Vim 不會這樣做，前次查詢模式仍然被記住。查詢模式總被存入查
找歷史記錄。

如果 'wrapscan' 選項的值為真 (預設) 的話，查詢會在緩衝區的結尾折返到首部。如果
不為真，反向查詢會在開始處停止；正向查詢會在結尾處停止。如果該選項為真但找不到
該模式，會給出一個錯誤資訊: "pattern not found"，游標原地不動。如果不為真，取
決於查詢的方向是正向還是反向，給出的資訊是: "search hit BOTTOM without match"
或者 "search hit TOP without match"。如果該選項為真，當查詢折返時會分別顯示:
"search hit TOP, continuing at BOTTOM" 或 "search hit BOTTOM, continuing at
TOP"。此時，訊息可以用設定 'shortmess' 選項裡的 's' 標誌位來關閉。該資訊的顯示
會使用 'w' 的高亮方法 (預設: 突出)。

							*search-range*
用 \%>l 專案，你可以限定 "/" 命令查詢的範圍。例如，要在行 199 之下行 300 之上
搜尋單詞 "limit": >
	/\%>199l\%<300llimit
另見 |/\%>l|。

另一個方法是使用 ":substitute" 命令並與 'c' 聯用。例: >
   :.,300s/Pattern//gc
這個命令會從游標所在處開始查詢 "Pattern"，直到第 300 行。在匹配處，你會被提示
鍵入一個字元。鍵入 'q' 終止；鍵入 'n' 找下一個匹配。

"*"，"#"，"g*" 和 "g#" 命令依照以下的次序查詢在游標附近的一個單詞，使用以下最
先找到的那個:
- 游標所在的關鍵字。
- 同行的游標右側的第一個關鍵字。
- 游標下的第一個字串 (WORD)。
- 同行的游標右側的第一個字串 (WORD)。
關鍵字只能包括字母和 'iskeyword' 中的字元。字串 (WORD) 可以包括任何非空白
(<Tab> 和／或 <Space>)。
備註 如果你用十個指頭打字的話，這些字元是很容易記住的:
"#" 在你的左手中指上 (向左上查詢)；"*" 在你的右手中指上 (向右下查詢)。
(不過，這取決於你的鍵盤佈局)。

==============================================================================
2. 模式的定義				*search-pattern* *pattern* *[pattern]*
					*regular-expression* *regexp* *Pattern*
					*E76* *E383* *E476*

頭一道菜已經在使用者手冊的第 27 章 |usr_27.txt| 上過了。

						*/bar* */\bar* */pattern*
1. 一個模式 (pattern) 是由 "\|" 分隔開的一個或多個分支 (branch)。它可以匹配其
   中的任何一個分支匹配的文字。例如: "foo\|beep" 可以匹配 "foo" 或 "beep"。如
   果超過一個分支可以匹配，選用其中的第一個。

   pattern ::=	    branch
		或  branch \| branch
		或  branch \| branch \| branch
		等。

						*/branch* */\&*
2. 一個分支是一個或多個被 "\&" 分隔的鄰接。它匹配最後一個鄰接，但僅僅當前面所
   的鄰接也在同樣位置匹配。例:
	"foobeep\&..." 匹配 "foobeep" 中的 "foo"。
	".*Peter\&.*Bob" 匹配同時包括 "Peter" 和 "Bob" 的一行

   branch ::=	    concat
		或  concat \& concat
		或  concat \& concat \& concat
		等。

						*/concat*
3. 一個鄰接 (concat) 是一或多個相鄰的元件 (piece)。它匹配第一個元件，後接第二
   個元件的匹配，等等。例如: "f[0-9]b"，先匹配 "f"，然後是一個數位，接著 "b"。

   concat  ::=	    piece
		或  piece piece
		或  piece piece piece
		等。

						*/piece*
4. 一個元件是一個匹配原 (atom)，後面可能帶一個倍數 (multi)，用來表示該匹配原匹
   配的次數。例如: "a*" 匹配任意個 "a" 組成的序列: ""，"a"，"aa" 等。參見
   |/multi|。

   piece   ::=	    atom
		或  atom  multi

						*/atom*
5. 一個匹配原可以是一個很長的條目列表中的一個。許多匹配原用來匹配文字中的一個
   字元，通常是一個普通的字元或字元類。也可以用圓括號來將一個模式變成一個匹配
   原。下面的 "\z(\)" 構造僅用在語法高亮中。

   atom    ::=	    ordinary-atom		|/ordinary-atom|
		或  \( pattern \)		|/\(|
		或  \%( pattern \)		|/\%(|
		或  \z( pattern \)		|/\z(|


				*/\%#=* *two-engines* *NFA*
Vim 包含兩個正規表示式引擎:
1. 老式的基於回溯的引擎，支援所有功能。
2. 新式的 NFA 引擎，對某些模式會快很多，對某些模式可能會變慢。

Vim 會自動為你選擇合適的引擎。不過，如果你遇過問題或者想特別指定某一個引擎，可
以在模式開頭處加入:

	\%#=0	強制自動選擇。僅在 'regexpengine' 設為非零時才有效果。
	\%#=1	強制使用舊引擎。
	\%#=2	強制使用 NFA 引擎。

也可用 'regexpengine' 選項改變預設機制。

			 *E864* *E868* *E874* *E875* *E876* *E877* *E878*
選擇 NFA 引擎時如果遇到未實現的模式部分時，整個模式會不匹配。只用於除錯 Vim。

==============================================================================
3. 魔術								*/magic*

某些字元在模式中是按本義出現的。它們匹配自身。然而，當前面有一個反斜槓時，這些
字元具有特殊的含義。

另外一些字元即使沒有反斜槓也代表特殊的意思。它們反而需要一個反斜槓來匹配按本義
出現的自身。

一個字元是否按本義出現取決於 'magic' 選項以及下面將解釋的條目。
							*/\m* */\M*
使用 "\m" 會使得其後的模式的解釋方式就如同設定了 'magic' 選項一樣。而且將忽略
'magic' 選項的實際值。
使用 "\M" 會使得其後的模式的解釋方式就如同設定了 'nomagic' 選項一樣。
							*/\v* */\V*
使用 "\v" 會使得其後的模式中所有 '0'-'9'，'a'-'z'，'A'-'Z' 和 '_' 之外的字元都
當作特殊字元解釋。"very magic"

使用 "\V" 會使得其後的模式中只有反斜槓和終止字元 （/ 或 ?) 有特殊的意義。"very
nomagic"

示例:
在這之後: \v	   \m	    \M	     \V		匹配 ~
		'magic' 'nomagic'
	  $	   $	    $	     \$		匹配行尾
	  .	   .	    \.	     \.		匹配任何字元
	  *	   *	    \*	     \*		前面匹配原的任意次重複
	  ~	   ~	    \~	     \~		最近替代字串
	  ()	   \(\)     \(\)     \(\)	組成為單個匹配原
	  |	   \|	    \|	     \|		分隔可選分支
	  \a	   \a	    \a	     \a		字母字元
	  \\	   \\	    \\	     \\		反斜槓 (按本義)
	  \.	   \.	    .	     .		英文句號 (按本義)
	  \{	   {	    {	     {		'{'  (按本義)
	  a	   a	    a	     a		'a'  (按本義)

{僅 Vim 支援 \m，\M，\v 和 \V}

建議始終將 'magic' 選項保持在預設值 －  'magic'。這可以避免移植性的麻煩。要使
模式不受該選項值的影響，在模式前面加上 "\m" 或 "\M"。

==============================================================================
4. 模式項總覽						*pattern-overview*
						*E865* *E866* *E867* *E869*

倍數總覽。						*/multi* *E61* *E62*
更多解釋和示例見下，點選連結即可。				*E64* *E871*

	  倍數 ~
     'magic' 'nomagic'	匹配前面的匹配原 ~
|/star|	*	\*	0 或更多	儘可能多
|/\+|	\+	\+	1 或更多	儘可能多 (*)
|/\=|	\=	\=	0 或 1		儘可能多 (*)
|/\?|	\?	\?	0 或 1		儘可能多 (*)

|/\{|	\{n,m}	\{n,m}	n 到 m		儘可能多 (*)
	\{n}	\{n}	n		準確 (*)
	\{n,}	\{n,}	最少 n		儘可能多 (*)
	\{,m}	\{,m}	0 到 m		儘可能多 (*)
	\{}	\{}	0 或更多	儘可能多 (和 * 相同) (*)

|/\{-|	\{-n,m}	\{-n,m}	n 到 m		儘可能少 (*)
	\{-n}	\{-n}	n		準確 (*)
	\{-n,}	\{-n,}	最少 n		儘可能少 (*)
	\{-,m}	\{-,m}	0 到 m		儘可能少 (*)
	\{-}	\{-}	0 或更多	儘可能少 (*)

							*E59*
|/\@>|	\@>	\@>	1，要求完整的模式匹配 (不能回溯) (*)
|/\@=|	\@=	\@=	無，但要求匹配 |/zero-width| (*)
|/\@!|	\@!	\@!	無，但要求_不_匹配 |/zero-width| (*)
|/\@<=|	\@<=	\@<=	無，但要求反向匹配 |/zero-width| (*)
|/\@<!|	\@<!	\@<!	無，但要其反向_不_匹配 |/zero-width| (*)

(*) {Vi 無此功能}


普通匹配原總覽。					*/ordinary-atom*
更多解釋和示例見下，點選連結即可。

          普通匹配原 ~
      magic   nomagic	匹配 ~
|/^|	^	^	行首 (在模式起始) |/zero-width|
|/\^|	\^	\^	按本義出現的 '^'
|/\_^|	\_^	\_^	行首 (用於任何地方) |/zero-width|
|/$|	$	$	行尾 (在模式結尾) |/zero-width|
|/\$|	\$	\$	按本義出現的 '$'
|/\_$|	\_$	\_$	行尾 (用於任何地方) |/zero-width|
|/.|	.	\.	任何單個字元 (不包括換行)
|/\_.|	\_.	\_.	任何單個字元，包括換行
|/\<|	\<	\<	單詞的起始 |/zero-width|
|/\>|	\>	\>	單詞的結尾 |/zero-width|
|/\zs|	\zs	\zs	任何字元，設定匹配部分起始
|/\ze|	\ze	\ze	任何字元，設定匹配部分結束
|/\%^|	\%^	\%^	檔案首 |/zero-width|		*E71*
|/\%$|	\%$	\%$	檔案尾 |/zero-width|
|/\%V|	\%V	\%V	可視區域內 |/zero-width|
|/\%#|	\%#	\%#	游標位置 |/zero-width|
|/\%'m|	\%'m	\%'m	位置標記 m 的位置 |/zero-width|
|/\%l|	\%23l	\%23l	在第 23 行 |/zero-width|
|/\%c|	\%23c	\%23c	在第 23 列 |/zero-width|
|/\%v|	\%23v	\%23v	在虛擬第 23 列 |/zero-width|

字元類 {Vi 無此功能}:				*/character-classes*
      magic   nomagic	匹配 ~
|/\i|	\i	\i	識別符號字元 (見 'isident' 選項)
|/\I|	\I	\I	同 "\i"，但不包括數字字元
|/\k|	\k	\k	關鍵字字元 (見 'iskeyword' 選項)
|/\K|	\K	\K	同 "\k"，但不包括數字字元
|/\f|	\f	\f	檔名字元 (見 'isfname' 選項)
|/\F|	\F	\F	同 "\f"，但不包括數字字元
|/\p|	\p	\p	可顯示字元 (見 'isprint' 選項)
|/\P|	\P	\P	同 "\p"，但不包括數字字元
|/\s|	\s	\s	空白字元； <Space> 和 <Tab>
|/\S|	\S	\S	非空白字元: \s 之反
|/\d|	\d	\d	數位:			[0-9]
|/\D|	\D	\D	非數位:			[^0-9]
|/\x|	\x	\x	十六進位制數位:		[0-9A-Fa-f]
|/\X|	\X	\X	非十六進位制數位:		[^0-9A-Fa-f]
|/\o|	\o	\o	八進位制數位:		[0-7]
|/\O|	\O	\O	非八進位制數位:		[^0-7]
|/\w|	\w	\w	單詞字元:		[0-9A-Za-z_]
|/\W|	\W	\W	非單詞字元:		[^0-9A-Za-z_]
|/\h|	\h	\h	單詞首字元:		[A-Za-z_]
|/\H|	\H	\H	非單詞首字元:		[^A-Za-z_]
|/\a|	\a	\a	英文字母字元:		[A-Za-z]
|/\A|	\A	\A	非英文字母字元:		[^A-Za-z]
|/\l|	\l	\l	小寫字元:		[a-z]
|/\L|	\L	\L	非小寫字元:		[^a-z]
|/\u|	\u	\u	大寫字元:		[A-Z]
|/\U|	\U	\U	非大寫字元		[^A-Z]
|/\_|	\_x	\_x	其中 x 可以是以上任意一個字元: 對應字元類加上換行
 (字元類結束)

      magic   nomagic	匹配 ~
|/\e|	\e	\e	<Esc>
|/\t|	\t	\t	<Tab>
|/\r|	\r	\r	<CR>
|/\b|	\b	\b	<BS>
|/\n|	\n	\n	行尾符
|/~|	~	\~	上次給出的替代字串
|/\1|	\1	\1	第一個 \(\) 匹配的字元 {Vi 無此功能}
|/\2|	\2	\2	如 "\1"，但用第二個 \(\)
	   ...
|/\9|	\9	\9	如 "\1"，但用第九個 \(\)
								*E68*
|/\z1|	\z1	\z1	僅用於語法高亮，見 |:syn-ext-match|
	   ...
|/\z1|	\z9	\z9	僅用於語法高亮，見 |:syn-ext-match|

	x	x	一個沒有特殊含義的字元匹配其自身

|/[]|	[]	\[]	[] 內指定的任何字元之一
|/\%[]|	\%[]	\%[]	一個可選匹配原的序列

|/\c|	\c	\c	忽略大小寫，不使用 'ignorecase' 選項
|/\C|	\C	\C	匹配大小寫，不使用 'ignorecase' 選項
|/\Z|	\Z	\Z	忽略 Unicode 中的 "組合用字元" 的區別，對於搜尋帶母音
			的希伯來和阿拉伯文字有用。

      magic   nomagic	匹配 ~
|/\m|	\m	\m	對之後模式中字元開啟 'magic' 選項
|/\M|	\M	\M	對之後模式中字元關閉 'magic' 選項
|/\v|	\v	\v	對之後模式中字元設定 'magic' 選項為 "very magic"
|/\V|	\V	\V	對之後模式中字元設定 'magic' 選項為 "very nomagic"
|/\%#=|   \%#=1   \%#=1   選擇正規表示式引擎 |/zero-width|

|/\%d|	\%d	\%d	匹配用十進位制指定的字元 (如 \%d123)
|/\%x|	\%x	\%x	匹配用十六進位制指定的字元 (如 \%x2a)
|/\%o|	\%o	\%o	匹配用八進位制指定的字元 (如 \%o040)
|/\%u|	\%u	\%u	匹配指定的多位元組字元 (如 \%u20ac)
|/\%U|	\%U	\%U	匹配指定的巨大多位元組字元 (如 \%U12345678)
|/\%C|	\%C	\%C	匹配任何合成用字元

示例			匹配 ~
\<\I\i*		或
\<\h\w*
\<[a-zA-Z_][a-zA-Z0-9_]*
			一個識別符號 (例如，在一個 C 程式裡)。

\(\.$\|\. \)		一個英文句號後跟 <EOL> 或一個空格。

[.!?][])"']*\($\|[ ]\)	一個匹配英文句子結尾的模式。幾乎和 ")" 的定義相同。

cat\Z			匹配 "cat" 和 "càt" ("a" 後跟 0x0300)
			不匹配 "càt" (字元 0x00e0)，即使它們看起來可能一樣。


==============================================================================
5. 倍數項					*pattern-multi-items*

一個匹配原後面可以跟一個表示該匹配原匹配次數和方式的修飾。這個修飾稱為倍數。
在 |/multi| 可以看到一個綜述。

							*/star* */\star*
*	(在沒有設定 'magic' 時使用 \*)
	匹配 0 或更多個前面的匹配原，儘可能多地匹配。
	示例     'nomagic'	匹配 ~
	a*	   a\*		""、"a"、"aa"、"aaa" 等。
	.*	   \.\*		任意，包括空串，不包括行尾符
	\_.*	   \_.\*	匹配至緩衝區結束
	\_.*END	   \_.\*END	匹配至緩衝區中最後一次出現 "END" 處，包括該
				"END"

	特例: 當 "*" 用在模式的開頭或者緊跟在 "^" 之後時，它匹配星號字元。

	要當心，重複匹配 "\_." 會包括大量的文字，因而可能會花很長時間。例如，
	"\_.*END" 匹配從當前位置開始到檔案中最後一次出現 "END" 的地方。因為
	"*" 會盡可能多的匹配，它會先跳過到檔案結束前的所有行，然後一次退一個字
	符以查詢 "END"。

							*/\+*
\+	匹配一個或更多前面的匹配原。儘可能多。{Vi 無此功能}
	例		匹配 ~
	^.\+$		任意空行
	\s\+		一個以上的空白字元

							*/\=*
\=	匹配 0 或 1 個前面的匹配原。儘可能多。{Vi 無此功能}
	例		匹配 ~
	foo\=		"fo" 和 "foo"

							*/\?*
\?	和 \= 一樣。不能和反向查詢的 "?" 命令中使用。{Vi 無此功能}

					*/\{* *E60* *E554* *E870*
\{n,m}	匹配 n 至 m 個前面的匹配原。儘可能多
\{n}	匹配 n 個前面的匹配原
\{n,}	匹配至少 n 個前面的匹配原。儘可能多
\{,m}	匹配 0 至 m 個前面的匹配原。儘可能多
\{}	匹配 0 個以上前面的匹配原。儘可能多 (和 * 等價)
							*/\{-*
\{-n,m}	匹配 n 至 m 個前面的匹配原。儘可能少
\{-n}	匹配 n 個前面的匹配原
\{-n,}	匹配至少 n 個前面的匹配原。儘可能少
\{-,m}	匹配 0 至 m 個前面的匹配原。儘可能少
\{-}	匹配 0 個以上前面的匹配原。儘可能少
	{Vi 沒有這些}

	n 和 m 是正的十進位制數或零
								*non-greedy*
	如果一個 "-" 緊接在 "{" 之後，那麼最短匹配優先演算法將啟用 (見下面的例
	子)。特別的，"\{-}" 和 "*" 一樣，但使用最短匹配優先演算法。_不過_，更早
	開始的匹配比更短的匹配優先: "a\{-}b" 匹配 "xaaab" 中的 "aaab"。

	示例			匹配 ~
	ab\{2,3}c		"abbc" 或 "abbbc"
	a\{5}			"aaaaa"
	ab\{2,}c		"abbc"、"abbbc"、"abbbbc" 等
	ab\{,3}c		"ac"、"abc"、"abbc" 或 "abbbc"
	a[bc]\{3}d		"abbbd"、"abbcd"、"acbcd"、"acccd" 等。
	a\(bc\)\{1,2}d		"abcd" 或 "abcbcd"
	a[bc]\{-}[cd]		"abcd" 中的 "abc"
	a[bc]*[cd]		"abcd" 中的 "abcd"

	} 之前可以加 (也可以不加) 一個反斜槓: \{n,m\}。

							*/\@=*
\@=	零寬度匹配前面的匹配原。{Vi 無此功能}
	類似於 Perl 中的 "(?=pattern)"。
	示例			匹配 ~
	foo\(bar\)\@=		"foobar" 中的 "foo"
	foo\(bar\)\@=foo	空
							*/zero-width*
	"\@=" (或 "^"，"$"，"\<"，"\>") 的匹配不包括任何字元。這些字元僅僅是用
	來檢查匹配是否存在。這很容易搞錯，因為後續的項會在同樣位置作匹配。上面
	的最後一個例子不會匹配 "foobarfoo"，因為 Vim 會嘗試在 "bar" 匹配的同樣
	地方匹配 "foo"。

	注意 使用 "\&" 同使用 "\@=" 是一樣的: "foo\&.." 等於 "\(foo\)\@=.."。
	但用 "\&" 容易些，你可以省了那些括號。


							*/\@!*
\@!	零寬度否匹配，亦即，要求前面的匹配原在當前位置_不_匹配。
	|/zero-width| {Vi 無此功能}
	類似於 Perl 中的 "(?!pattern)"。
	示例			匹配 ~
	foo\(bar\)\@!		任意後面不帶 "bar" 的 "foo"
	a.\{-}p\@!		"a"，"ap"，"app"，"appp" 等。後面不帶 "p"
	if \(\(then\)\@!.\)*$	"if " 後面無跟隨 "then"

	使用 "\@!" 要小心，因為很多地方一個模式可以不匹配。"a.*p\@!" 會匹配一
	個 "a" 直到行尾，因為 ".*" 匹配所有行內的字元，而 "p" 不在行尾匹配。
	"a.\{-}p\@!" 則可以匹配 "a"，"ap"，"app" 等中的一項，只要它們不再緊跟
	另外一個 "p"，這是因為 "." 可以匹配 "p" 而 "p\@!" 不匹配這個 "p" 的後
	面。

	你不能用 "\@!" 去尋找匹配所在位置之前的否匹配。"\(foo\)\@!bar" 會匹配
	"foobar" 中的 "bar"，因為在 "bar" 匹配的位置上，"foo" 並不匹配。如果
	不想匹配 "foobar"，你可以嘗試 "\(foo\)\@!...bar"，但它不能匹配在行首出
	現的 "bar"。最好的方法是用 "\(foo\)\@<!bar"。

	有用的例子: 要找到包含 "foo" 但沒有 "bar" 的行: >
		/^\%(.*bar\)\@!.*\zsfoo
<	此模式先檢查某行中沒有一個位置可以匹配 "bar"。如果 ".*bar" 匹配，\@!
	會拒絕本模式。否則，繼續尋找 "foo"。"\zs" 使得匹配從 "foo" 處開始。

							*/\@<=*
\@<=	零寬度反向匹配。要求前面的匹配原緊貼在後面的模式之前匹配。
	|/zero-width| {Vi 無此功能}
	類似於 Perl 的 "(?<=pattern)"，但是 Vim 允許使用非固定寬度的模式。
	示例			匹配 ~
	\(an\_s\+\)\@<=file	在 "an" 和若干個空白或者行尾符之後的 "file"。
	為了提高效能，最好避免這個倍數項。可以用 "\zs" 替代 |/\zs|。要匹配
	上述的示例:
		an\_s\+\zsfile
	反向匹配時至少要設一個限制範圍，見下。

	"\@<=" 和 "\@<!" 檢查剛好在其後模式匹配點之前出現的匹配文字。理論上，
	這些匹配可以從當前位置之前的任何地方開始，為了限制所需的時間，只有其後
	匹配所在的行和它上一行 (如果有上一行的話) 會被檢索。這對大多數的應用來
	說已經足夠，而且也不會減慢速度太多。

	在舊的正規表示式引擎裡，在 "\@<=" 和 "\@<!" 之後的模式部分其實先被匹
	配，所以不能用 "\1" 之類的結構來引用零寬度匹配原中的 \(\)。反過來倒是
	可以的。
	壞示例				匹配 ~
	\%#=1\1\@<=,\([a-z]\+\)		"abc,abc" 裡的 ",abc"

	不過，新的正規表示式引擎工作方式不同，最好不要依賴此行為，如果可以避
	免，不要用 \@<=:
	示例				匹配 ~
	\([a-z]\+\)\zs,\1		"abc,abc" 裡的 ",abc"

\@123<=
	類似於 "\@<="，但只往回看 123 個位元組。這樣可以避免去匹配很多已知不會成
	功的但使模式很慢的嘗試。例如，要檢查緊接 "span" 之前要否有 "<":
		/<\@1<=span
	這裡只須對 "span" 之前一個位元組試圖匹配 "<"，本來這也是唯一可能的位置。
	如果跨過行邊界，此限制相對於該行的行尾。這樣，匹配所在行的行首部分不計
	入限制範圍 (只是為了簡單起見)。
	零相當於無限制。

							*/\@<!*
\@<!	零寬度反向否匹配，要求前面的匹配原_不_緊貼在其後的模式之前匹配。換而言
	之，如果在當前行或之前的一行中沒有任何位置這個匹配原可以匹配而且它的匹
	配文字剛好緊貼在其後模式的匹配點之前。|/zero-width| {Vi 無此功能}
	類似於 Perl 的 "(?<!pattern)"，但是 Vim 允許使用非固定寬度的模式。
	該倍數所引用的匹配原必須緊貼在其後匹配之前，所以這個匹配原可以用 ".*"
	結尾。警告: 該倍數項可能會很慢 (因為在匹配之前的許多位置都要被檢查)。
	如有可能，請使用限制範圍，見下。
	示例			匹配 ~
	\(foo\)\@<!bar		任何不在 "foobar" 中的 "bar"
	\(\/\/.*\)\@<!in	不在 "//" 之後 (中間可以有間隔) 的 "in"

\@123<!
	類似於 "\@<!"，但只往回看 123 個位元組。這樣可以避免去匹配很多已知不會成
	功的但使模式很慢的嘗試。

							*/\@>*
\@>	匹配前面的匹配原時要求完整匹配 (不能回溯)。{Vi 無此功能}
	類似於 Perl 中的 "(?>pattern)"。
	示例		匹配 ~
	\(a*\)\@>a	無 ("a*" 用盡了所有的 "a"，後面不可能再有)

	試圖匹配前面的匹配原，就如同匹配一個完整的模式那樣。如果以後無法匹配，
	不會用較短的子模式或者任何其它的方法來重試該匹配原。注意觀察以下兩者的
	不同: "a*b" 和 "a*ab" 都匹配 "aaab"，但是後者中的 "a*" 僅僅匹配前兩個
	"a"。"\(a*\)\@>ab" 不會匹配 "aaab"，因為 "a*" 匹配了 "aaa" (儘可能多
	的 "a")，導致 "ab" 無法匹配。


==============================================================================
6.  普通匹配原					*pattern-atoms*

一個普通匹配原可能是:

							*/^*
^	在模式起點或在 "\|"，"\("，"\%("，"\n" 之後: 匹配行首；在其它位置匹配
	按本義出現的 '^' 字元。|/zero-width|
	示例		匹配 ~
	^beep(		C 函式 "beep" 開始的地方 (很可能)。

							*/\^*
\^	匹配按本義出現的 '^' 字元。可以用於任何位置。

							*/\_^*
\_^	匹配行首。|/zero-width| 可以用於任何位置。
	示例		匹配 ~
	\_s*\_^foo	空白字元及空行，後接行首的 "foo"。

							*/$*
$	在模式終點或 "\|"、"\)" 或 "\n" (開啟 'magic' 的話) 之前: 匹配行尾
	<EOL>；其它位置，匹配按本義出現的 '$' 字元。|/zero-width|

							*/\$*
\$	匹配按本義出現的 '$' 字元。可以用於任何位置。

							*/\_$*
\_$	匹配行尾。|/zero-width|  可以用於任何位置。注意: "a\_$b" 永遠無法匹
	配，因為 "b" 不能匹配行尾符。可以使用 "a\nb" 代替 |/\n|。
	示例		匹配 ~
	foo\_$\_s*	"foo" 在行尾，後接空白字元及空行

.	('nomagic' 的情形: \.)				*/.* */\.*
	匹配任何單個字元，不包括行尾符。

							*/\_.*
\_.	匹配任何單個字元或行尾符。當心: "\_.*" 會一直匹配到緩衝區結尾！

							*/\<*
\<	匹配單詞起點: 下一個字元是單詞的首字元。'iskeyword' 選項指定哪些是組成
	單詞的字元。|/zero-width|

							*/\>*
\>	匹配單詞終點: 前一個字元是單詞的尾字元。'iskeyword' 選項指定哪些是組成
	單詞的字元。|/zero-width|

							*/\zs*
\zs	匹配任何位置，並將匹配起始處置於該處: 下一個字元將是整個匹配的第一個字
	符。|/zero-width|
	例如: >
		"^\s*\zsif"
<	匹配行首的 "if"，忽略前導的空白字元。
	可以使用多次，但實際使用最後一次在匹配的分支裡遇到的。例如: >
		/\(.\{-}\zsFab\)\{3}
<	找到第三次出現的 "Fab"。
	不能後跟倍數。 *E888*
	{Vi 無此功能} {僅當編譯時加入 |+syntax| 特性才可用}
							*/\ze*
\ze	匹配任何位置，並將匹配結尾處置於該處: 前一個字元將是整個匹配的最後一個
	字元。|/zero-width|
	可以使用多次，但實際使用最後一次在匹配的分支裡遇到的。
	例如: "end\ze\(if\|for\)" 匹配 "endif" 和 "endfor" 中的 "end"。
	不能後跟倍數。 |E888|
	{Vi 無此功能} {僅當編譯時加入 |+syntax| 特性才可用}

						*/\%^* *start-of-file*
\%^	匹配檔案頭。當用於一個字串時，匹配字串起始處。{Vi 無此功能}
	例如，要查詢一個檔案中首次出現 "VIM" 的地方: >
		/\%^\_.\{-}\zsVIM
<
						*/\%$* *end-of-file*
\%$	匹配檔案尾。當用於一個字串時，匹配字串結束處。{Vi 無此功能}
	注意 下面的模式不匹配檔案中的最後一個 "VIM": >
		/VIM\_.\{-}\%$
<	它會找到下一個 VIM，因為其後的部分總會匹配。這樣才能匹配檔案中的最後一
	個 "VIM": >
		/VIM\ze\(\(VIM\)\@!\_.\)*\%$
<	這裡使用了 |/\@!| 來確定在首個 "VIM" 之後_無法_再次匹配 "VIM"。
	從檔案尾部反向搜尋會容易些！

						*/\%V*
\%V	在可視區域內匹配。可視模式停止後，在 |gv| 將會重新選擇的區域內匹配。
	這是一個零寬度 |/zero-width| 匹配。要確保整個模式都在可視區域裡，把本
	匹配原放在匹配模式的開始和剛好結尾之前處，例如: >
		/\%Vfoo.*ba\%Vr
<	這在可視選擇只包含 "foo bar" 時，才會匹配。而: >
		/\%Vfoo.*bar\%V
<	這在可視選擇區在 "r" 之後繼續時，才會匹配 "foo bar"。
	只能用於當前緩衝區。

						*/\%#* *cursor-position*
\%#	匹配游標位置。僅對顯示於視窗內的緩衝區有效。{Vi 無此功能}
	警 告: 如果使用了該模式之後游標被移動，結果不再有效，Vim 不會自動更新
	匹配。這對語法高亮和 'hlsearch' 很重要。換言之: 在游標移動時顯示並不因
	此而更新。Vim 只對行被修改 (整行被更新) 或使用者使用 |CTRL-L| 命令時 (整
	個螢幕被更新) 進行更新。例如，要高亮顯示游標下的單詞: >
		/\k*\%#\k*
<	當設定 'hlsearch' 時，移動游標並作若干更改，你就能清楚地看到更新在何時
	進行。

						*/\%'m* */\%<'m* */\%>'m*
\%'m	匹配位置標記 m 的位置。
\%<'m	匹配位置標記 m 之前的位置。
\%>'m	匹配位置標記 m 之後的位置。
	例如，高亮位置標記 's 到 'e 的文字: >
		/.\%>'s.*\%<'e..
<	注意 在匹配裡需要兩個句號來包含位置標記 'e。這是因為 "\%<'e" 匹配 'e
	位置標記之前的字元，而既然它是零寬度匹配 |/zero-width|，它並不真正包含
	該字元。
	{Vi 無此功能}
	警 告: 如果使用模式後移動了位置標記，結果不再有效。Vim 並不自動更新匹
	配。這和 "\%#" 裡移動游標的情形類似 |/\%#|。

						*/\%l* */\%>l* */\%<l*
\%23l	匹配指定的行。
\%<23l	匹配指定行的上方 (行號更小)。
\%>23l	匹配指定行的下方 (行號更大)。
	這三個匹配原可以用來匹配緩衝區內的特定行。"23" 可以是任何行號。第一行
	為 1。 {Vi 無此功能}
	警 告: 當插入和刪除行時 Vim 不會自動更新匹配。這意味著語法高亮很快就會
	有問題。
	例如，要高亮顯示游標所在行: >
		:exe '/\%' . line(".") . 'l.*'
<	當設定 'hlsearch' 時，移動游標並作若干更改，你就能清楚地看到更新在何時
	進行。

						*/\%c* */\%>c* */\%<c*
\%23c	匹配指定的列。
\%<23c	匹配指定列之前。
\%>23c	匹配指定列之後。
	這三個匹配原可以用來匹配緩衝區或字串中的特定列。"23" 可以是任何列
	號。第一列為 1。事實上，列以位元組計算 (因此對多位元組字元來說是不準確
	的)。 {Vi 無此功能}
	警 告: 當插入和刪除字元時 Vim 並不自動更新匹配。這意味著語法高亮很快就
	會有問題。
	例如，要高亮顯示游標所在列: >
		:exe '/\%' . col(".") . 'c'
<	當設定 'hlsearch' 時，移動游標並作若干更改，你就能清楚地看到更新在何時
	進行。
	一個匹配第 44 列單個位元組的例子: >
		/\%>43c.\%<46c
<	注意: "\%<46c" 匹配第 45 列，而 "." 匹配 44 列的一個位元組。

						*/\%v* */\%>v* */\%<v*
\%23v	匹配指定虛擬列。
\%<23v	匹配指定虛擬列之前。
\%>23v	匹配指定虛擬列之後。
	這三個匹配原可以用來匹配緩衝區或字串中指定的虛擬列。如果不是在匹配窗
	口內的緩衝區，使用當前視窗的選項值 (如 'tabstop')。
	"23" 可以是任何列號。第一列為 1。
	注意 某些虛擬列位置永遠無法被匹配，因為它們在製表符或其它佔用超過一個
	螢幕位置的特殊字元的中間某處。{Vi 無此功能}
	警 告: 當插入和刪除字元時 Vim 並不自動更新高亮的匹配。這意味著語法高亮
	很快就會有問題。
	例如，要高亮顯示所有位於虛擬第 72 列之後的字元: >
		/\%>72v.*
<	當設定 'hlsearch' 時，移動游標並作若干更改，你就能清楚地看到更新在何時
	進行。
	要匹配直到第 17 列的文字: >
		/^.*\%17v
<	這裡不包括第 17 列，因為這是 |/zero-width| 匹配。要包含該列，應用: >
		/^.*\%17v.
<	下例同上，但如果第 17 列沒有字元也同樣匹配: >
		/^.*\%<18v.
<	注意 如果沒有 "^" 來錨住首列的匹配，第 17 列也能被高亮: >
		/.*\%17v
<	'hlsearch' 高亮第 17 列，因為存在另外一個匹配，其中 ".*" 匹配零個字
	符。


字元類: {Vi 無此功能}
\i	識別符號字元 (見 'isident' 選項)			*/\i*
\I	同 "\i"，但不包括數字字元			*/\I*
\k	關鍵字字元 (見 'iskeyword' 選項)		*/\k*
\K	同 "\k"，但不包括數字字元			*/\K*
\f	檔名字元 (見 'isfname' 選項)			*/\f*
\F	同 "\f"，但不包括數字字元			*/\F*
\p	可顯示字元 (見 'isprint' 選項)			*/\p*
\P	同 "\p"，但不包括數字字元			*/\P*

備註: 上面這些適用於多位元組字元，而下面只匹配 ASCII 字元，因為它們由範圍限定。

						*whitespace* *white-space*
\s	空白字元； <Space> 和 <Tab>			*/\s*
\S	非空白字元: \s 之反				*/\S*
\d	數位:				[0-9]		*/\d*
\D	非數位:				[^0-9]		*/\D*
\x	十六進位制數位:			[0-9A-Fa-f]	*/\x*
\X	非十六進位制數位:			[^0-9A-Fa-f]	*/\X*
\o	八進位制數位:			[0-7]		*/\o*
\O	非八進位制數位:			[^0-7]		*/\O*
\w	單詞字元:			[0-9A-Za-z_]	*/\w*
\W	非單詞字元:			[^0-9A-Za-z_]	*/\W*
\h	單詞首字元:			[A-Za-z_]	*/\h*
\H	非單詞首字元:			[^A-Za-z_]	*/\H*
\a	英文字母字元:			[A-Za-z]	*/\a*
\A	非英文字母字元:			[^A-Za-z]	*/\A*
\l	小寫字元:			[a-z]		*/\l*
\L	非小寫字元:			[^a-z]		*/\L*
\u	大寫字元:			[A-Z]		*/\u*
\U	非大寫字元:			[^A-Z]		*/\U*

	備註: 使用匹配原比使用 [] 構造要快。

	備註: 字元類不使用 'ignorecase'，"\c" 和 "\C" 的設定。

		*/\_* *E63* */\_i* */\_I* */\_k* */\_K* */\_f* */\_F*
		*/\_p* */\_P* */\_s* */\_S* */\_d* */\_D* */\_x* */\_X*
		*/\_o* */\_O* */\_w* */\_W* */\_h* */\_H* */\_a* */\_A*
		*/\_l* */\_L* */\_u* */\_U*
\_x	其中 x 為上面列出的可用字元之一: 結果為對應字元類加上行尾符
(字元類結束)

\e	匹配 <Esc>					*/\e*
\t	匹配 <Tab>					*/\t*
\r	匹配 <CR>					*/\r*
\b	匹配 <BS>					*/\b*
\n	匹配行尾符					*/\n*
	當對字串而不是緩衝區進行匹配時，匹配一個按本義出現的換行字元。

~	匹配上次給出的替代字串			*/~* */\~*

\(\)	一個由轉義的括號括起來的模式。			*/\(* */\(\)* */\)*
	例: "\(^a\)" 匹配行首的 'a'。
	*E51* *E54* *E55* *E872* *E873*

\1      匹配和第一個 \( 和 \) 之間的子表示式的匹配文字	*/\1* *E65*
	相同的字串。 {Vi 無此功能}
	例如: "\([a-z]\).\1" 匹配 "ata"，"ehe"，"tot" 等。
\2      類似於 "\1"，但使用第二子表示式，		*/\2*
   ...							*/\3*
\9      類似於 "\1"，但使用第三子表示式。		*/\9*
	備註: 各組的標號是基於哪一個 "\(" 先出現 (自左至右)，而_非_哪一個先匹
	配。

\%(\)	一個由轉義的括號括起來的模式。			*/\%(\)* */\%(* *E53*
	類似 \(\)，但不算作一個子表示式。這樣做允許使用更多的群組，並且處理時
	會稍快些。
	{Vi 無此功能}

x	一個沒有特殊含義的單個字元，匹配其自身

							*/\* */\\*
\x	一個反斜槓帶一個沒有特殊含義的單個字元，保留作將來的擴充套件

[]	('nomagic' 的情形: \[])		*/[]* */\[]* */\_[]* */collection*
\_[]
	一個集合。一組由方括號括起來的字元。匹配集合中的任何一個字元。
	示例		匹配 ~
	[xyz]		'x'、'y' 或 'z' 之一
	[a-zA-Z]$	出現在行尾的字母字元
	\c[a-z]$	同上
	[Ð-ÑÐÑ]		俄語字符集 (包括 utf-8 和 cp1251)

								*/[\n]*
	如果在集合前加上 "\_" 的話，同時匹配行尾符，這等價於給集合加上 "\n"。
	即使該模式以 "^" 開始，也能匹配行尾符！因此 "\_[^ab]" 將匹配行尾符以及
	所有非 "a" 或 "b" 的字元。
	這使其與 Vi 相容: 沒有 "\_" 或 "\n" 時，集合不匹配行尾符。
								*E769*
	如果沒有 ']'，Vim 不會給出錯誤資訊，而是假設不使用集合。可用於直接搜尋
	'['。不過內部搜尋會得到 E769。同時要注意在 ”:substitute" 命令裡，整個
	命令作為模式處理，例如 ":s/[/x/" 搜尋 "[/x" 並替換為空，而不是搜尋 "["
	並替換為 "x"！

								*E944* *E945*
	如果集合以 "^" 開始，它匹配所有_不在_集合內的字元: "[^xyz]" 匹配任何不
	是 'x'、'y' 和 'z' 的字元。
	- 如果集合中的兩個字元以 '-' 隔開，表示它們之間的所有 ASCII 字元。例
	  如，"[0-9]" 匹配任何十進位制數位。如果開始字元大於結束字元，如 [c-a]，
	  報錯 E944。可以使用非 ASCII 字元，但在舊的正規表示式引擎中字元值的距
	  離不能超過 256。例如設定 re=1 後搜尋 [\u3000-\u4000]，會報錯 E945。
	  在模式之前加上 \%#=2 可以解決這個問題。
	- 字元類表示式被解釋為該字元類代表的字元集合。支援以下字元類:
		  名稱        函式	內容 ~
*[:alnum:]*	  [:alnum:]   isalnum	字母和數位
*[:alpha:]*	  [:alpha:]   isalpha	字母
*[:blank:]*	  [:blank:]     	空格和製表
*[:cntrl:]*	  [:cntrl:]   iscntrl	控制字元
*[:digit:]*	  [:digit:]     	十進位制數位 '0' 到 '9'
*[:graph:]*	  [:graph:]   isgraph	ASCII 可顯示字元，不包括空格
*[:lower:]*	  [:lower:]   (1)	小寫字母 (使用 'ignorecase' 時代表所有
					字母)
*[:print:]*	  [:print:]   (2)	可顯示字元，包括空格
*[:punct:]*	  [:punct:]   ispunct	ASCII 標點字元
*[:space:]*	  [:space:]     	空白字元: 空格、製表、CR、NL、垂直制
					表、換頁
*[:upper:]*	  [:upper:]   (3)	大寫字母 (使用 'ignorecase' 時代表所有
					字母)
*[:xdigit:]*	  [:xdigit:]    	十六進位制數位: 0-9、a-f、A-F
*[:return:]*	  [:return:]		<CR> 字元
*[:tab:]*	  [:tab:]		<Tab> 字元
*[:escape:]*	  [:escape:]		<Esc> 字元
*[:backspace:]*	  [:backspace:]		<BS> 字元
	  方括號括起的字元類表示式是對於方括號定界的集合的擴充。例如，下面的模
	  式是一個 UNIX 檔名: "[-./[:alnum:]_~]\+"。即至少有一個字元的字元列
	  表，其中字元可以是 '-'，'.'，'/'，字母，數位，'_' 或 '~' 中的一個。
	  這些項僅對 8 位字元有效，但在新的正規表示式引擎裡， [:lower:] 和
	  [:upper:] 也可用於多位元組字元。見 |two-engines|。將來，其它專案可能也
	  可用於多位元組字元。現在，要得到所有的 “alpha" 字元，可用:
	  [[:lower:][:upper:]]。

	  "函式" 列顯示使用的庫函式。具體實現取決於系統。否則:
	  (1) 編譯時帶 |+multi_byte| 特性時，ASCII 使用 islower()，其它字元使
	  用 Vim 內建規則。
	  (2) 使用 Vim 內建規則
	  (3) 用 (1) 但使用 isupper()
							*/[[=* *[==]*
	- 等價類 (equivalence class)。匹配的字元和被比較的字元 "幾乎" 相同，但
	  重音的區別可以忽略。目前支援 Unicode、latin1 和 latin9。形式是:
		[=a=]
							*/[[.* *[..]*
	- 排序規則元素 (collation element)。目前只能簡單地接受如下形式的單個字
	  符:
		[.a.]
							  */\]*
	- 要在集合之內包括字元 ']'，^'，'-' 或 '\'，只需在該字元前加上反斜槓
	  "[xyz\]]"，"[\^xyz]"，"[xy\-z]" 和 "[xyz\\]"。
	  (備註: POSIX 不支援這種反斜槓的用法)。
	  對於 ']' 你也可以將其作為第一個字元 (但可能在 "^" 之後) 而無須轉義:
	  "[]xyz]" 或 "[^]xyz]"  {Vi 無此功能}。
	  對於 '-' 你也可以將其作為第一個或最後一個字元: "[-xyz]"，"[^-xyz]"
	  或 "[xyz-]"。
	  對於 '\' 你也可以將其放置在除了 "^]-\bdertnoUux" 以外的任何一個字元
	  之前而無須轉義: "[\xyz]" 匹配 '\'，'x'，'y' 及 'z'。但是用 "\\" 好
	  些，因為將來的擴充套件可能會在 '\' 之後使用其它字元。
	- 省略結尾的 ] 不被視為錯誤。"[]" 等同於 "[]]"，匹配 ']' 字元。
	- 當 'cpoptions' 中不包括 'l' 標誌位時，以下轉義可用 {Vi 無此功能}:
		\e	<Esc>
		\t	<Tab>
		\r	<CR>	(_不是_行尾符！)
		\b	<BS>
		\n	換行符，見上 |/[\n]|
		\d123	字元的十進位制表示
		\o40	字元的八進位制表示，最大值為 0377
		\x20	字元的十六進位制表示，最大值為 0xff
		\u20AC	多位元組字元的十六進位制表示，最大值為 0xffff
		\U1234	多位元組字元的十六進位制表示，最大值為 0xffffffff
	  備註: 其它曾在前面提到的反斜槓轉義碼 (譯者注: 如 \s、\d 等)
		在方括號 [] 之內是不起作用的！
	- 用集合來匹配可能會很慢。因為每個字元都要和集合中的每一個字元作比較。
	  儘可能使用上面提到的其它匹配原。例如: 同樣是匹配一個數位，"\d" 要比
	  "[0-9]" 快的多。

						*/\%[]* *E69* *E70* *E369*
\%[]	一個可選匹配原的序列。它總能匹配，但試圖匹配儘量多的列出的匹配原，而在
	第一個不匹配的地方終止。例如: >
		/r\%[ead]
<	匹配 "r"，"re"，"rea" 或者 "read"。採用最長可能的匹配。下面例子可以用
	來匹配 Ex 命令 "function"，其中 "fu" 是必須的而 "nction" 是可選的: >
		/\<fu\%[nction]\>
<	這裡用到了單詞結尾匹配原 "\>" 來避免匹配 "full" 中的 "fu"。
	當要匹配的不是普通字元時，問題就變得更復雜了。你不一定會經常這樣，但可
	以這麼做。例如: >
		/\<r\%[[eo]ad]\>
<	匹配 "r"，"re"，"ro"，"rea"，"roa"，"read" 及 "road"。
	[] 裡不能有 \(\)、\%(\) 或 \z(\) 項，\%[] 也不能巢狀。
	要包含 "["，用 "[[]" 而 "]" 則可用 "[]]"，例如: >
		/index\%[[[]0[]]]
<	匹配 "index"、"index["、"index[0" 和 "index[0]"。
	{僅當編譯時加入 |+syntax| 特性才有效}

				*/\%d* */\%x* */\%o* */\%u* */\%U* *E678*

\%d123	匹配十進位制指定的字元。後面必須跟著非數位。
\%o40	匹配八進位制指定的字元，至多 0377。
	小於 040 的數必須後面跟著非八進位制的數位或非數位。
\%x2a	匹配不超過兩位十六進位制數位指定的字元。
\%u20AC	匹配不超過四位十六進位制數位指定的字元。
\%U1234abcd	匹配不超過八位十六進位制數位指定的字元。

==============================================================================
7. 忽略大小寫						*/ignorecase*

如果選項 'ignorecase' 開啟的話，忽略正常字母的大小寫。設定 'smartcase' 會在模
式只包含小寫字母時才忽略大小寫。
							*/\c* */\C*
如果模式的任何位置出現了 "\c"，整個模式會象開啟 'ignorecase' 一樣處理。真正的
'ignorecase' 和 'smartcase' 的值會被忽略。"\C" 的效果恰好相反: 強制對整個模式
匹配大小寫。
{僅 Vim 支援 \c 和 \C}
注意 'ignorecase'，"\c" 和 "\C" 對字元類無效。

例如:
	模式	'ignorecase'  'smartcase'	匹配 ~
	foo	  關		-		foo
	foo	  開		-		foo Foo FOO
	Foo	  開		關		foo Foo FOO
	Foo	  開		開		    Foo
	\cfoo	  -		-		foo Foo FOO
	foo\C	  -		-		foo

技術細節:						*NL-used-for-Nul*
檔案中的 <Nul> 字元在記憶體中儲存為 <NL>。顯示為 "^@"。翻譯是在讀寫檔案時完成
的。為了在查詢模式中匹配 <Nul> 你可以使用 CTRL-@ 或 "CTRL-V 000"。這應該不出你
的所料。在內部，該字元被替換為 <NL>。不尋常的是鍵入 CTRL-V CTRL-J 同樣插入一個
<NL>，因此也搜尋檔案中的 <Nul>。{Vi 則完全不能處理檔案中的 <Nul> 字元}

							*CR-used-for-NL*
當 'fileformat' 為 "mac" 時，<NL> 字元在內部儲存為 <CR>。在文本里顯示為 "^J"。
除此以外，和 <NL> 作為 <Nul> 的用法類似。

在作表示式求值時，模式中的 <NL> 字元匹配字串中的 <NL>。用 "\n" (反斜槓 n) 來
匹配 <NL> 在這裡是行不通的，它僅對緩衝區內的文字有效。

							*pattern-multi-byte*
模式匹配對於多位元組字元同樣適用。大體上使用並無區別，不過要注意無效位元組可能引起
的問題，一個包含無效位元組的模式永遠不會得到匹配。

==============================================================================
8. 合成用字元						*patterns-composing*

							*/\Z*
如果模式的任何位置出現了 "\Z"，所有的合成用字元將被忽略。這時，只比較基本字
符，合成用字元可以不同，其數量也可以不同。這一功能只在 'encoding' 為 'utf-8'
時有意義。
例外: 如果模式以一或多個合成用字元開始，它們必須匹配。
							*/\%C*
"\%C" 可用來跳過任何合成用字元。例如，模式 "a" 不匹配 "càt" (這裡 a 有合成用字
符 0x0300)，但 "a\%C" 可以。注意 不匹配 "cát" (這裡 á 是字元 0xe1，沒有合成用
字元)。但匹配 "cat" (這裡 a 就是簡單的 a)。

如果一個合成用字元出現在模式的開始處或在不包含合成用字元的專案之後出現，它匹配
任何包含該合成用字元的字元。

句號和合成用字元聯用和合成用字元本身的效果相同，但是你不用擔心該字元前面出現的
是什麼專案。

合成用字元出現的順序無關重要。另外，文字可以使用比模式更多的合成用字元，它仍然
匹配。但模式中合成用字元必須全數出現在文字中。

假定 B 是基本字元，x 和 y 是合成用字元:
	模式		文字		匹配與否 ~
	Bxy		Bxy		是 (完全匹配)
	Bxy		Byx		是 (忽略順序)
	Bxy		By		否 (缺失 x)
	Bxy		Bx		否 (缺失 y)
	Bx		Bx		是 (完全匹配)
	Bx		By		否 (缺失 x)
	Bx		Bxy		是 (忽略多餘的 y)
	Bx		Byx		是 (忽略多餘的 y)

==============================================================================
9. 與 Perl 模式的比較					*perl-patterns*

Vim 中的正則表示式和 Perl 的在功能上來說非常相似。它們之間的區別基本上只是在表
示方法上。這裡給出一個它們之間的區別的總結:

功能				Vim 方言	Perl 方言 ~
----------------------------------------------------------------
強制不區分大小寫		\c		(?i)
強制區分大小寫			\C		(?-i)
不須被引用的群組		\%(atom\)	(?:atom)
保守的倍數描述			\{-n,m}		*?，+?，??，{}?
零寬度匹配			atom\@=		(?=atom)
零寬度否匹配			atom\@!		(?!atom)
零寬度反向匹配			atom\@<=	(?<=atom)
零寬度反向否匹配		atom\@<!	(?<!atom)
無重試匹配			atom\@>		(?>atom)

(譯註: 常見的其它譯法
不須被引用的群組		非捕獲分組
保守的倍數描述			非貪婪匹配
零寬度匹配			正向預搜尋匹配
零寬度否匹配			正向預搜尋不匹配
零寬度反向匹配			反向預搜尋匹配
零寬度反向否匹配		反向預搜尋不匹配
)

Vim 和 Perl 匹配一個字串中的換行符時有所不同:

在 Perl 裡，^ 和 $ 預設只匹配文字的開始和結尾。但是你也可以設定 'm' 標誌位來使
它們匹配內嵌的換行符。你還可以設定 's' 標誌位使句號 (.) 可以也用來匹配換行符。
(順便提一下，使用類似上面 i 標誌位的用法，可以在在模式內部改變這兩個標誌位。)

另一方面，Vim 中的 ^ 和 $ 永遠匹配內嵌的換行符。但另外有兩個匹配原:  \%^ 和
\%$，可以分別用來匹配 (且只匹配) 文字的起始和結尾。對第二個問題，Vim 用 \_ "修
飾符" 來解決: 把它放在一個句號或字元類之前，對應的模式就可以同時匹配換行字元。

最後，以下這些結構是 Perl 獨有的:
- 在正則表示式內執行任意程式碼:  (?{perl 程式碼})
- 條件表示式:  (?(條件)真值表達式|假值表示式)

... 而這些是 Vim 獨有的:
- 改變模式的 'magic' 屬性:  \v \V \m \M (對於避免反斜槓非常有用)
- 可選匹配原的序列:  \%[atoms]
- \& (\& 之於 \| 就像 "與" 之於 "或"；它強迫多個模式在同一個位置匹配)
- 通過行/列號匹配:  \%5l \%5c \%5v
- 設定匹配的開始和結束位置:  \zs \ze

==============================================================================
10. 高亮顯示匹配					*match-highlight*

							*:mat* *:match*
:mat[ch] {group} /{pattern}/
		定義一個在當前視窗高亮顯示的模式。它會以 {group} 高亮。例: >
			:highlight MyGroup ctermbg=green guibg=green
			:match MyGroup /TODO/
<		除了 // 以外，任何字元都可以用來標識一個 {pattern} 的開始和結
		束。要當心某些特殊的字元，例如 '"' 和 '|'。

		該命令執行時，{group} 必須已經定義。

		對於 'hlsearch' 要高亮的字元，仍然適用 {group} 高亮，因為匹配
		高亮的優先順序比 'hlsearch' 要高。同樣的，語法高亮 (見 'syntax')
		也被匹配否決。

		注意 使用 'hlsearch' 高亮顯示最近使用的查詢模式對所有視窗都有
		效，而以 ":match" 定義的模式僅僅對當前視窗生效。當切換至另一個
		緩衝區時，該設定被保留。

		'ignorecase' 不起作用。在模式中使用 |/\c| 來忽略大小寫，否則，
		大小寫總是區分的。

		'redrawtime' 定義搜尋模式匹配的最大時間。

		匹配行尾而 Vim 只重繪部分顯示時，結果可能會令你意想不到。這是
		因為 Vim 在重繪開始的行上尋找匹配的緣故。

		另見 |matcharg()| 和 |getmatches()|。前者返回上次 |:match| 命
		令使用的高亮組和模式。後者返回 |matchadd()| 和 |:match| 兩者定
		義的所有高亮組和模式的列表。

		|:match| 定義的高亮匹配僅限於三個 (除了 |:match| 以外，還有
		|:2match| 和 |:3match| 可用)。而 |matchadd()| 無此限制，而且還
		能排定匹配的優先順序。

		另一個例子，高亮顯示虛擬第 72 列之後的所有文字: >
			:highlight rightMargin term=bold ctermfg=blue guifg=blue
			:match rightMargin /.\%>72v/
<		要高亮顯示所有位於虛擬第 7 列的文字: >
			:highlight col8 ctermbg=grey guibg=grey
			:match col8 /\%<8v.\%>7v/
<		注意 用兩個專案是為了匹配那些佔用了超過一個虛擬列的字元，例如
		TAB。

:mat[ch]
:mat[ch] none
		清除上次定義的匹配模式。


:2mat[ch] {group} /{pattern}/					*:2match*
:2mat[ch]
:2mat[ch] none
:3mat[ch] {group} /{pattern}/					*:3match*
:3mat[ch]
:3mat[ch] none
		和上面的 |:match| 完全類似，但設定不同的匹配。這樣，同時可以有
		三組啟用的匹配。如果不同匹配在相同位置出現，最小編號的匹配優
		先。
		":3match" 命令用於 |matchparen| 外掛。建議使用 ":match" 進行手
		動的搜尋，而 ":2match" 用於其它的外掛。


 vim:tw=78:ts=8:ft=help:norl:
