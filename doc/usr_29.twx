*usr_29.txt*	For Vim version 8.0.  最近更新: 2017年8月

		     VIM 使用者手冊 - by Bram Moolenaar
		     譯者: wandys  http://vimcdoc.sf.net

			    在程式碼間移動


Vim 的創造者是一名計算機程式設計師，因此這就不奇怪 Vim 中有許多幫助編寫程式的功
能: 跳轉到識別符號被定義和使用的地方；在另一個視窗中預覽有關的宣告等等。在下一章
中還會介紹更多的功能。

|29.1|	使用標籤
|29.2|	預覽視窗
|29.3|	在程式碼間移動
|29.4|	查詢全域性識別符號
|29.5|	查詢區域性識別符號

     下一章: |usr_30.txt|  編輯程式
     前一章: |usr_28.txt|  摺疊
       目錄: |usr_toc.txt|

==============================================================================
*29.1*	使用標籤

什麼是標籤？標籤就是一個識別符號被定義的地方。一個例子就是 C 或者 C++ 程式中的函
數定義。標籤列表可以儲存在一個標籤檔案中。Vim 可以通過它來從任何地方跳轉到該標
籤，也就是一個識別符號被定義的地方。
   在當前目錄下為所有的 C 檔案生成標籤檔案，使用下面的這個命令: >

	ctags *.c

"ctags" 是一個獨立的程式。大多數 Unix 系統上都已經安裝了它。如果你還沒有安裝，
可以在這裡找到 "Exuberant ctags":

	http://ctags.sf.net ~

現在你可以使用下面的命令跳轉到一個函式定義的地方: >

	:tag startlist

這個命令會找到函式 "startlist"，即使該函式是在另一個檔案中。
   CTRL-] 命令會跳轉到當前游標下單詞的標籤。這樣瀏覽毫無頭緒的 C 程式碼會變得更
容易些。舉個例子，假設你在函式 "write_block" 中。你可以看到它呼叫了函式
"write_line"。但 "write_line" 做了什麼呢？將游標置於呼叫 "write_line" 的地方然
後按 CTRL-]，你就跳轉到了這個函式的定義的地方了。
   "write_line" 函式呼叫了 "write_char"。你需要知道它做了什麼。將游標定位到調
用 "write_char" 的地方然後按 CTRL-]，你就到了定義 "write_char" 的地方。

	+-------------------------------------+
	|void write_block(char **s; int cnt)  |
	|{				      |
	|   int i;			      |
	|   for (i = 0; i < cnt; ++i)	      |
	|      write_line(s[i]);	      |
	|}	    |			      |
	+-----------|-------------------------+
		    |
	     CTRL-] |
		    |	 +----------------------------+
		    +--> |void write_line(char *s)    |
			 |{			      |
			 |   while (*s != 0)	      |
			 |	write_char(*s++);     |
			 |}	  |		      |
			 +--------|-------------------+
				  |
			   CTRL-] |
				  |    +------------------------------------+
				  +--> |void write_char(char c)		    |
				       |{				    |
				       |    putchar((int)(unsigned char)c); |
				       |}				    |
				       +------------------------------------+

":tags" 命令顯示你經過的標籤列表:
	:tags
	  # TO tag	   FROM line  in file/text ~
	  1  1 write_line	   8  write_block.c ~
	  2  1 write_char	   7  write_line.c ~
	> ~
>
現在介紹向回跳轉。CTRL-T 命令跳轉到上一個標籤。在上例中，你會回到 "write_line"
函式呼叫 "write_char" 的地方。
   這個命令接受一個計數引數，用來表示跳轉回去的標籤個數。你已經向前跳轉，現在
又跳轉了回去。現在我們再一次向前跳轉。下面的命令跳轉到標籤列表中最上面的標
籤: >

	:tag
<
你可以在前面加上要向前跳轉的標籤個數。比如: ":3tag"。CTRL-T 同樣可以加上一個計
數引數。
   通過這些命令，你可以用 CTRL-] 沿著呼叫樹向前跳轉，用 CTRL-T 向回跳轉，用
":tags" 命令顯示當前位置。


分 割 窗 口

":tag" 命令會將當前視窗的檔案替換為包含新函式的檔案。怎樣才能同時檢視兩個檔案
呢？你可以使用 ":split" 命令將視窗分開然後再用 ":tag" 命令。Vim 有個縮寫命令可
以做到這些: >

	:stag tagname

使用下面的命令可以分割當前視窗並跳轉到游標下的標籤: >

	CTRL-W ]

如果指定了計數引數，新視窗將包含指定的那麼多行。


多 個 標 籤 文 件

如果在多個目錄中都有檔案，你可以在每一個目錄下建立一個標籤檔案。Vim 只能跳轉到
那個目錄下的標籤。
   通過設定 'tags' 選項，你可以使用多個相關的標籤檔案。比如: >

	:set tags=./tags,./../tags,./*/tags

這會使 Vim 找到當前檔案所在目錄及其父目錄和所有子目錄下的標籤檔案。
   這已經是不少的標籤檔案了，但也許仍不夠。比如，當編輯 "~/proj/src" 目錄下的
一個檔案時，你無法找到 "~/proj/sub/tags" 目錄下的標籤檔案。對這種情況，Vim 提
供了一個查詢整個目錄樹下標籤檔案的方法，比如: >

	:set tags=~/proj/**/tags


單 個 標 籤 文 件

當 Vim 在多個地方查詢標籤檔案時，你會聽到硬碟在格格作響。這樣會有點慢。在這種
情況下，你最好將這些時間花在生成一個大的標籤檔案上。你可以要等一會兒。
   這得藉助上面提到的 "Exuberant ctags" 程式。它有一個選項可以搜尋整個目錄
樹: >

	cd ~/proj
	ctags -R .

這樣做的好處是 "Exuberant ctags" 可以識別多種檔案型別，它不僅適用於 C 和 C++
程式，還適用於 Eiffel 甚至 Vim 指令碼。請參考 ctags 文件進行調整所用引數。
   現在你只需要告訴 Vim 你的標籤檔案在何處: >

	:set tags=~/proj/tags


多 個 匹 配

當一個函式 (或類中的方法) 被定義多次，":tags" 命令會跳轉到第一處。如果在當前文
件中存在匹配，那它將會被首先使用。
   你現在可以跳轉到同一個標籤的其它匹配處: >

	:tnext

重複執行這個命令可以找到更多的匹配。如果存在很多匹配，你可以選擇要跳轉到哪一
個: >

	:tselect tagname

Vim 會為你展示一個選擇列表:

	  # pri kind tag	       file ~
	  1 F	f    mch_init	       os_amiga.c ~
		       mch_init() ~
	  2 F	f    mch_init	       os_mac.c ~
		       mch_init() ~
	  3 F	f    mch_init	       os_msdos.c ~
		       mch_init(void) ~
	  4 F	f    mch_init	       os_riscos.c ~
		       mch_init() ~
	Enter nr of choice (<CR> to abort):  ~

你現在可以輸入要跳轉到的匹配代號 (在第一列)。其它列的資訊可以讓你知道匹配在何
處被定義。

可以用這些命令在各匹配的標籤間移動:

	:tfirst			到第一個匹配
	:[count]tprevious	向前 [count] 個匹配
	:[count]tnext		向後 [count] 個匹配
	:tlast			到最後一個匹配

如果沒有指定，[count] 預設為一。


猜 測 標 籤 名

命令列補全是避免輸入長標籤名的好辦法。只需輸入開始的一部分然後按 <Tab>: >

	:tag write_<Tab>

你會得到第一個匹配。如果這不是你想要的，重複輸入 <Tab> 直到你找到正確的匹配。
   有時你只知道一個函式名的一部分，或是你有很多以相同字串開頭而結尾不同的標
記。這時你可以告訴 Vim 使用一個模式來查詢標籤。

   假設你要跳轉到一個包含 "block" 的標籤。首先輸入: >

	:tag /block

現在再利用命令列補全功能: 輸入 <Tab>。Vim 會找到所有包含 "block" 的標籤並使用
第一個匹配。
   標籤名前面的 "/" 告訴 Vim 這不是一個確定的標籤名而是一個模式。你可以利用有
關查詢模式的所有特性。舉個列子，假設你要選擇所有以 "write_" 開頭的標籤: >

	:tselect /^write_

"^" 指定標籤以 "write_" 開頭，否則在中間含有 "write_" 的標籤名也會被找到。類似
地，"$" 指定標籤名結尾處的匹配。


標 籤 瀏 覽 器

CTRL-] 可以讓你跳轉到游標所在識別符號的定義處，因此你可以利用識別符號的列表來形成
一個目錄。這裡給出一個例子。
   首先生成一個識別符號列表 (需要 Exuberant ctags): >

	ctags --c-types=f -f functions *.c

現在開啟 Vim 並在一個垂直分割視窗中編輯這個檔案: >

	vim
	:vsplit functions

視窗中包含一個所有函式的列表。其它的東西可以被忽略。用 ":setlocal ts=99" 命令
使其顯示得更清晰些。
   在這個視窗中，定義一個對映: >

	:nnoremap <buffer> <CR> 0ye<C-W>w:tag <C-R>"<CR>

移動游標至要跳轉到函式的所在行，輸入 <Enter>。Vim 會在另一個視窗中跳轉到所選擇
的函式定義處。


相 關 雜 項

你可以在不改變 'tagcase' 為 "followic" 的情況下置位 'ignorecase' 選項，或者設
置 'tagcase' 為 "ignore" 來忽略標籤名裡的大小寫。

'tagbsearch' 選項標明標籤檔案是否經過排序。預設是假定為標籤檔案已排序，這樣會
使查詢更快，但如果檔案沒有被排序是無法工作的。

'taglength' 選項可用來告訴 Vim 標籤的有效字元個數。

Cscope 是一個自由軟體。它不僅可以找到一個識別符號被宣告的地方，還可以找到識別符號
被使用的地方。請參考 |cscope|。

==============================================================================
*29.2*	預覽視窗

當編輯含有函式呼叫的程式碼時，你需要使用正確的呼叫引數。要獲知所要傳遞的值，你可
以檢視這個函式是如何定義的。標籤機制對此十分適用。如果定義可在另一個視窗內顯示
那就更好了。對此我們可以利用預覽視窗。
   開啟一個預覽視窗來顯示函式 "write_char": >

	:ptag write_char

Vim 會開啟一個視窗，跳轉到 "write_char" 標籤。然後它會回到原來的位置。這樣你可
以繼續輸入而不必使用 CTRL-W 命令。
   如果函式名出現在文字中，你可以用下面的命令在預覽視窗中得到其定義: >

	CTRL-W }

有一個指令碼可以自動顯示游標處的標籤定義。請參考 |CursorHold-example|。

用下面的命令關閉預覽視窗: >

	:pclose

要在預覽視窗中編輯一個指定的檔案，用 ":pedit"。這在編輯標頭檔案時很有用，比
如: >

	:pedit defs.h

最後，"psearch" 可用來查詢當前檔案和任何包含檔案中的單詞並在預覽視窗中顯示匹
配。這在使用沒有標籤檔案的庫函式時十分有用。例如: >

	:psearch popen

這會在預覽視窗中顯示含有 popen() 原型的 "stdio.h" 檔案:

	FILE	*popen __P((const char *, const char *)); ~

你可以用 'previewheight' 選項指定預覽視窗開啟時的高度。

==============================================================================
*29.3*	在程式碼間移動

因為程式程式碼是結構化的，Vim 可以識別其中的有關專案。一些特定的命令可用來完成相
關的移動。
   C 程式中經常包含類似下面的程式碼:

	#ifdef USE_POPEN ~
	    fd = popen("ls", "r") ~
	#else ~
	    fd = fopen("tmp", "w") ~
	#endif ~

有時會更長，也許還有巢狀。將游標置於 "#ifdef" 處按 %。Vim 會跳轉到 "#else"。繼
續按 % 會跳轉到 "#endif"。再次按下 % 又回到原來的 "#ifdef"。
   當代碼巢狀時，Vim 會找到相匹配的專案。這是檢查你是否忘記了一個 "#endif" 的
好辦法。
   當你在一個 "#ifdef" - "#endif" 塊內的某個位置，你可以用下面的命令回到開始
處: >

	[#

如果你的位置不是在 "#if" 或 "#ifdef" 之後，Vim 會鳴音。用下面命令可以跳轉到下
一個 "#else" 或 "#endif": >

	]#

這兩個命令會跳過它所經過的 "#if" - "#endif" 塊。
例如:

	#if defined(HAS_INC_H) ~
	    a = a + inc(); ~
	# ifdef USE_THEME ~
	    a += 3; ~
	# endif ~
	    set_width(a); ~

如果游標在最後一行，"[#" 會移動到第一行。中間的 "#ifdef" - "#endif" 塊被跳過。


在 代 碼 塊 內 移 動

C 程式碼塊包含在 {} 中，有時一個程式碼會很長。要跳轉到外部程式碼塊的開始處，用 "[["
命令。用 "][" 找到結尾處。(前提是 "{" 和 "}" 都在第一列。)
   "[{" 命令跳轉到當前程式碼塊的開始處。它會跳過同一級別的 {} 對。"]}" 跳轉到結
尾。
   一點概述:

			function(int a)
	   +->		{
	   |		    if (a)
	   |	   +->	    {
	[[ |	   |		for (;;)	       --+
	   |	   |	  +->	{			 |
	   |	[{ |	  |	    foo(32);		 |     --+
	   |	   |   [{ |	    if (bar(a))  --+	 | ]}	 |
	   +--	   |	  +--		break;	   | ]}  |	 |
		   |		}		 <-+	 |	 | ][
		   +--		foobar(a)		 |	 |
			    }			       <-+	 |
			}				       <-+

當編寫 C++ 或 Java 程式碼時，外部程式碼塊是類，而下一級的 {} 是方法。在類內部用
"[m" 可以找到前一個方法的開始。"]m" 會找到下一個方法的開始。

另外，"[]" 反向移動到前一個函式的結尾，"]]" 正向移動到下一個函式的開始。函式的
結尾指的是處在第一列的 "}"。

				int func1(void)
				{
					return 1;
		  +---------->  }
		  |
	      []  |		int func2(void)
		  |	   +->	{
		  |    [[  |		if (flag)
	start	  +--	   +--			return flag;
		  |    ][  |		return 2;
		  |	   +->	}
	      ]]  |
		  |		int func3(void)
		  +---------->	{
					return 3;
				}

不要忘了你還可以用 "%" 在匹配的 ()、{} 和 [] 間移動。這在它們相距很多行時仍然
適用。


在 括 號 內 移 動

"[(" 和 "])" 命令與 "[{" 和 "]}" 類似，只不過它們適用於 () 對而不是 {} 對。
>
				  [(
<		    <--------------------------------
			      <-------
		if (a == b && (c == d || (e > f)) && x > y) ~
				  -------------->
			  --------------------------------> >
				       ])

在 注 釋 間 移 動

移動到一個註釋的開始用 "[/"；向前移動到註釋的結尾用 "]/"。這隻對 /* - */ 註釋
有效。

	  +->	  +-> /*
	  |    [/ |    * A comment about      --+
       [/ |	  +--  * wonderful life.	| ]/
	  |	       */		      <-+
	  |
	  +--	       foo = bar * 3;	      --+
						| ]/
		       /* a short comment */  <-+

==============================================================================
*29.4*	查詢全域性識別符號

你在編輯一個 C 程式，想要知道一個變數是被宣告為 "int" 還是 "unsigned"。一個快
速的方法是使用 "[I" 命令來查詢。
   假設游標在單詞 "column" 處。輸入: >

	[I

Vim 會列出它所找出的匹配行，不僅在當前檔案內查詢，還會在所有的包含檔案中查詢。
結果如下所示:

	structs.h ~
	 1:   29     unsigned     column;    /* column number */ ~

相對使用標籤檔案或預覽視窗的好處是包含檔案也被搜尋。大多數情況下都能找到正確
的宣告。即使標籤檔案已經過期或者你沒有為包含檔案建立標籤也不會影響結果。
   但是一些準備工作是必要的，否則 "[I" 就沒法工作。首先，'include' 選項必須指
定檔案是如何被包含的。預設值適用於 C 和 C++。對其它的語言，你需要自己設定。


定 位 包 含 文 件

   Vim 會找到 'path' 選項指定路徑中的包含檔案。如果缺少某個目錄，一些包含檔案
將不會被找到。你可以用這個命令來檢視: >

	:checkpath

它會列出不能找到的包含檔案，以及被找到的包含檔案。一個輸出樣例:

	--- Included files not found in path --- ~
	<io.h> ~
	vim.h --> ~
	  <functions.h> ~
	  <clib/exec_protos.h> ~

檔案 "io.h" 被當前檔案包含但無法找到。"vim.h" 可以找到，這樣 ":checkpath" 跟進
這個檔案並檢查其中的包含檔案。結果顯示無法找到 "vim.h" 包含的 "functions.h" 和
"clib/exec_protos.h" 檔案。

	備註:
	Vim 不是一個編譯器。它無法識別 "#ifdef" 語句。這就是說所有的
	"#include" 語句都會被使用，即使它在 "#if NEVER" 之後。

給 'path' 選項增加一個目錄可以修正無法找到檔案的錯誤。一個好的參考是
Makefile。注意那些包括 "-I" 的條目，比如 "-I/usr/local/X11"。要增加這個目錄，
用: >

	:set path+=/usr/local/X11

如果有很多的子目錄，你可以用 "*" 萬用字元。例如: >

	:set path+=/usr/*/include

這會找到 "/usr/local/include" 以及 "/usr/X11/include" 目錄下的檔案。

如果你的工程專案的包含檔案都在一個巢狀的目錄樹下，"**" 就非常有用。它會搜尋所
有的子目錄。例如: >

	:set path+=/projects/invent/**/include

這會找到這些目錄下的檔案:

	/projects/invent/include ~
	/projects/invent/main/include ~
	/projects/invent/main/os/include ~
	等等

還有其它的可能性。更多資訊，請檢視 'path' 選項。
   如果你想檢視找到的包含檔案，用這個命令: >

	:checkpath!

你會得到一個 (很長) 的包含檔案列表。為使它更短些，Vim 會對已經找到的檔案顯示
"(Already listed)" 而不再重新顯示一遍。


跳 轉 到 匹 配

"[I" 產生一個每項只有一行文字的列表。如果你想要進一步地檢視第一項，你可以用這
個命令來跳轉: >

	[<Tab>

你也可以使用 "[ CTRL-I"，因為 CTRL-I 和按 <Tab> 效果一樣。

"[I" 產生的列表在每行的開頭都有一個序號。如果你要跳轉到第一項外的其它項，首先
輸入序號: >

	3[<Tab>

會跳轉到列表中的第三項。記住你可以用 CTRL-O 跳回到原來的地方。


相 關 命 令

	[i		只列出第一項匹配
	]I		只列出游標下面的專案
	]i		只列出游標下面的第一項匹配


查 找 巨集 定 義 標 識 符

"[I" 命令查詢任何識別符號。只查詢 "#define" 定義的巨集，用: >

	[D

同樣，這會在所有的包含檔案中查詢。'define' 選項指定 "[D" 所查詢的專案定義行的
模式。你需要改變它的值來適用於 C 或 C++ 以外的語言。
   "[D" 相關命令:

	[d		只列出第一項匹配
	]D		只列出游標下面的專案
	]d		只列出游標下面的第一項匹配

==============================================================================
*29.5*	查詢區域性識別符號

"[I" 命令查詢所有的包含檔案。要在當前檔案中查詢並跳轉到游標處單詞被首次使用的
地方，用: >

	gD

提示: Goto Definition。這個命令對查詢區域性 (C 語言中的 "static") 宣告的變數或函
數很有用。例如 (游標在 "counter" 處):

	   +->   static int counter = 0;
	   |
	   |     int get_counter(void)
	gD |     {
	   |	     ++counter;
	   +--	     return counter;
		 }

要進一步的縮小查詢範圍，只在當前函式內查詢，用這個命令: >

	gd

這會回到當前函式的開始處尋找游標處單詞首次出現的地方。實際上，它是向後找到一個
在第一列為 '{' 的上方的空行，然後再從那裡開始正向查詢識別符號。例如 (游標位於
idx 上):

		int find_entry(char *name)
		{
	   +->	    int idx;
	   |
	gd |	    for (idx = 0; idx < table_len; ++idx)
	   |		if (strcmp(table[idx].name, name) == 0)
	   +--		    return idx;
		}

==============================================================================

下一章: |usr_30.txt| 編輯程式

版權: 見 |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
