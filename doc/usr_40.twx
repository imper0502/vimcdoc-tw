*usr_40.txt*	For Vim version 8.0.  最近更新: 2017年8月

		     VIM 使用者手冊 - by Bram Moolenaar
		     譯者: lang2 http://vimcdoc.sf.net

			      建立新的命令


Vim 是一個可擴充套件的編輯器。你可以把一系列你常用的命令組合成一個新的命令。或者重
新定義一個現存的命令。各種命令的自動執行可以通過自動命令實現。

|40.1|	鍵對映
|40.2|	定義命令列命令
|40.3|	自動命令

            下一章: |usr_41.txt|  編寫 Vim 指令碼
            前一章: |usr_32.txt|  撤銷樹
              目錄: |usr_toc.txt|

==============================================================================
*40.1*	鍵對映

簡單的對映已經在 |05.3| 介紹過了。基本的概念是將一系列的鍵輸入轉換成為另外一個
鍵輸入序列。這是一個很簡單，但是很有效的機制。
   最簡單的形式是將一個鍵輸入序列對映到一個鍵上。由於那些除了 <F1> 外的功能鍵
都沒有預先定義的功能，選擇它們作為對映物件是很有效的。例如: >

	:map <F2> GoDate: <Esc>:read !date<CR>kJ

這顯示瞭如何使用三種不同的執行模式。在用 "G" 移動到最後一行後，"o" 命令開始一
個新行並開始插入模式。然後文字 "Date: " 被輸入並用 <Esc> 離開插入模式。
   注意在 <> 內使用的特殊鍵。這叫尖括號記法。你要分別地輸入這些字元，而不是鍵
入要表示的鍵本身。這使得對映更具可讀性，而且你也可以方便地拷貝，貼上文字。
   ":" 使得 Vim 回到命令列。":read !date" 命令讀取 "date" 命令的輸出並新增到當
前行之下。<CR> 是用來執行該命令的。
   到此為止，文字看起來像:

	Date:  ~
	Fri Jun 15 12:54:34 CEST 2001 ~

然後 "kJ" 將游標上移並將兩行連線起來。
   參閱 |map-which-keys| 可以幫助你決定應該使用哪些鍵來作對映。


映 射 與 運 行 模 式

":map" 命令定義普通模式的鍵對映。你也可以為其它執行模式定義對映。例如，":imap"
用來定義插入模式的對映。你可以用它來定義一個插入日期的對映: >

	:imap <F2> <CR>Date: <Esc>:read !date<CR>kJ

看起來很象前面為普通模式定義的 <F2> 對映。只是開始的地方有所不同。普通模式下的
<F2> 對映依然有效。這樣你就可以在各種模式下為同一對映鍵定義不同的對映。
   應該注意的是，雖然這個對映以插入模式開始，但它卻以普通模式結束。如果你希望
繼續插入模式，可以在最後加上 "a"。

下面是一個對映命令及其生效模式的總覽:

	:map		普通，可視模式及操作符等待模式
	:vmap		可視模式
	:nmap		普通模式
	:omap		操作符等待模式
	:map!		插入和命令列模式
	:imap		插入模式
	:cmap		命令列模式

操作符等待模式是當你鍵入一個操作符 (比如 "d" 或 "y") 之後，Vim 期待你鍵入一個
動作命令或者文字物件時的狀態。比如，當你鍵入命令 "dw"， 那個 "w" 就是在操作符
等待模式下鍵入的。

假定你想定義對映 <F7> 使得命令 d<F7> 刪除一個 C 程式塊 ({} 包括的文字)。類似的
y<F7> 會將程式塊拷貝到匿名的暫存器。因此，你所要做的就是定義 <F7> 來選擇當前的
語法塊。你可以用下面的命令做到: >

	:omap <F7> a{

這使得 <F7> 在操作符等待模式下選擇一個塊，就像是你鍵入了 "a{" 一樣。這個對映在
你不容易鍵入 { 時比較有用。


映 射 列 表

要檢視當前定義的對映，使用不帶引數的 ":map" 命令。或者其它執行模式的變體。輸出
應該類似於:

	   _g		 :call MyGrep(1)<CR> ~
	v  <F2>		 :s/^/> /<CR>:noh<CR>`` ~
	n  <F2>		 :.,$s/^/> /<CR>:noh<CR>`` ~
	   <xHome>	 <Home>
	   <xEnd>	 <End>


第一列顯示該對映有效的執行模式。"n" 表示普通模式，"i" 表示插入模式，等等。空白
表示用 ":map" 命令定義的對映，也就是對普通和可視模式有效。
   列出對映的一個比較實用的目的是檢查 <> 表示的特殊鍵是否被識別了 (僅當支援多
色彩是有效)。例如，當 <Esc> 被用彩色顯示時，它表示轉義字元。否則，只是 5 個不
同的字元。


重 映 射

對映的結果會檢查其中包括的其他對映。例如，上面對 <F2> 的對映可以減短為: >

	:map <F2> G<F3>
	:imap <F2> <Esc><F3>
	:map <F3>  oDate: <Esc>:read !date<CR>kJ

在普通模式下 <F2> 被對映為: 行進至最後一行，然後輸入 <F3>；在插入模式下先鍵入
<Esc> 後也輸入 <F3>。接下來 <F3> 也被對映，執行真正的工作。

假設你幾乎不使用 Ex 模式，並想用 "Q" 命令來排版文字 (就像舊版本的 Vim 那樣)。
下面的對映就能做到: >

	:map Q gq

但是，你總有需要用到 Ex 模式的時候。我們來將 "gQ" 對映為 Q，這樣你仍然可以進入
Ex 模式: >

	:map gQ Q

這樣一來當你鍵入 "gQ" 時它被對映為 "Q"。到現在為止一切順利。但由於 "Q" 被對映
為 "gq"， 輸入的 "gQ" 被解釋成為 "gq"， 你根本就沒進入 Ex 模式。
   要避免鍵被再次對映，使用 ":noremap" 命令: >

	:noremap gQ Q

現在 Vim 就知道了對 "Q" 不需要檢查與之相關的對映。對於每個模式都有一個類似的命
令:

	:noremap	普通，可視和操作符等待模式
	:vnoremap	可視模式
	:nnoremap	普通模式
	:onoremap	操作符等待模式
	:noremap!	插入和命令列模式
	:inoremap	插入模式
	:cnoremap	命令列模式


遞 歸 映 射

當一個對映呼叫它本身的時候，會無限制的執行下去。這可以被用來無限次重複一個操
作。
   例如，你有一組檔案，每個的第一行都包括一個版本號。你用 "vim *.txt" 來編輯它
們。你現在正在編輯第一個檔案。定義下面的對映: >

	:map ,, :s/5.1/5.2/<CR>:wnext<CR>,,

現在當你鍵入 ",," 時，上面的對映被觸發。它把第一行的 "5.1" 替換為 "5.2"。接著
執行 ":wnext" 來寫入檔案並開始編輯下一個。對映以 ",," 結束。這又觸發了同一個映
射，再次執行替換操作，依此類推。
   這個對映會一直進行下去，直至遇到錯誤為止。在這裡可能是查詢命令無法匹配到
"5.1" 。你可以自行插入 "5.1" 然後再次鍵入 ",,"。或者 ":wnext" 因為遇到最後一個
檔案而失敗。
   當對映在中途遇到錯誤時，對映的剩餘部分會被放棄。你可用 CTRL-C 中斷對映。(在
MS-Windows 上用 CTRL-Break)。


刪 除 映 射

要刪除一個對映，使用 ":unmap" 命令。同樣，刪除對映的命令也和執行模式相關:

	:unmap		普通，可視和操作符等待模式
	:vunmap		可視模式
	:nunmap		普通模式
	:ounmap		操作符等待模式
	:unmap!		插入和命令列模式
	:iunmap		插入模式
	:cunmap		命令列模式

這裡有個小技巧可以定義一個對普通模式和操作符等待模式有效而對可視模式無效的映
射: 先對三個模式都定義對映，然後將可視模式的那個刪除: >

	:map <C-A> /---><CR>
	:vunmap <C-A>

注意那 5 個字元 "<C-A>" 表示一個鍵組合 CTRL-A。

要清除所有的對映，使用 |:mapclear| 命令。現在你應該可以猜到各種模式下的變體了
吧。要當心使用這個命令，它不可能被撤銷。


特 殊 字 符

在 ":map" 命令後面可以追加另一個命令。需要用 | 字元來將兩個命令分開。這也就意
味著一個對映中不能直接使用該字元。需要時，可以用 <Bar> (五個字元)。例如:
>
	:map <F8> :write <Bar> !checkin %:S<CR>

":unmap" 命令有同樣的問題，而且你得留意字尾的空白字元。下面兩個命令是不同的:
>
	:unmap a | unmap b
	:unmap a| unmap b

第一個命令試圖刪除對映 "a "，後面帶有一個空格。

當要在一個對映內使用空格時，應該用 <Space> (七個字元): >

	:map <Space> W

這使得空格鍵移動到下一個空白字元分割的單詞。

在一個對映後不能直接加註釋，因為 " 字元也被當作是對映的一部分。你可以用 |" 繞
過這一限制。這實際上是開始一個新的空命令。例如: >

	:map <Space> W|     " Use spacebar to move forward a word


映 射 與 縮 寫

縮寫和插入模式的對映很象。對引數的處理它們是一樣的。它們主要的不同在於觸發的方
式。縮寫是由單詞之後的非單詞字元觸發的。而對映由其最後一個字元觸發。
   另一個區別是你鍵入的縮寫的字元會在你鍵入的同時被插入到文字內。當縮寫被觸發
時，這些字元會被刪除並替換成縮寫所對應的字元。當你鍵入一個對映時，直到你完成所
有的對映鍵而對映被觸發時，對映所對應的內容才會被插入。如果你置位 'showcmd' 選
項，鍵入的字元會顯示在 Vim 視窗的最後一行。
   有一個例外是當對映有歧義的時候。假定你有兩個對映: >

	:imap aa foo
	:imap aaa bar

現在，當你鍵入 "aa" 時，Vim 不知道是否要使用第一個對映。它會等待另一個鍵輸入。
如果是 "a"，第二個對映被執行，結果是 "bar"。如果是其它字元，例如空格，第一個映
射被執行，結果是 "foo"， 而且空格字元也會被插入。


另 外 ...

<script> 關鍵字可以被用來使一個對映僅對當前指令碼有效。參見 |:map-<script>|。

<buffer> 關鍵字可以被用來使一個對映僅對當前緩衝區有效。參見 |:map-<buffer>|。

<unique> 關鍵字可以被用來當一個對映已經存在時不允許重新定義。否則的話新的對映
會簡單的覆蓋舊的。參見 |:map-<unique>|。

如果要使一個鍵無效，將之對映至 <Nop> (五個字元)。下面的對映會使 <F7> 什麼也幹
不了: >

	:map <F7> <Nop>| map! <F7> <Nop>

注意 <Nop> 之後一定不能有空格。

==============================================================================
*40.2*	定義命令列命令

Vim 編輯器允許你定義你自己的命令。你可以像執行其他命令列命令一樣執行你自定義的
命令。
   要定義一個命令，象下面一樣執行 ":command" 命令: >

	:command DeleteFirst 1delete

現在當你執行 ":DeleteFirst" 命令時，Vim 執行 ":1delete" 來刪除第一行。

	備註:
	使用者定義的命令必須以大寫字母開始，但不能用 ":X"，":Next" 和 ":Print"。
	也不能用下劃線！你可以使用數字，但是不鼓勵這麼做。

要列出使用者定義的命令，執行下面的命令: >

	:command

象那些內建的命令一樣，使用者自定義的命令也可以被縮寫。你只需要鍵入足夠區別於其它
命令的字元就可以了。命令列補全也有效。


參 數 個 數

自定義命令可以帶一系列的引數。引數的數目必須用 -nargs 選項來指定。例如，上面
例子中的 :DeleteFirst 命令不帶引數，所以你也可以這樣來定義: >

	:command -nargs=0 DeleteFirst 1delete

不過，因為預設引數數目為 0，你沒有必要加上 "-nargs=0"。其它可用的值是:

	-nargs=0	無引數
	-nargs=1	一個引數
	-nargs=*	任意數目的引數
	-nargs=?	沒有或一個引數
	-nargs=+	一個或更多引數


使 用 參 數

在命令的定義中，<args> 關鍵字可以用來表示命令帶的引數。例如: >

	:command -nargs=+ Say :echo "<args>"

現在當你輸入  >

	:Say Hello World

Vim 會顯示 "Hello World"。然而如果你加上一個雙引號，就不行了。例如: >

	:Say he said "hello"

要把特殊字元放到字串裡，必須在它們的前面加上反斜槓，用 "<q-args>" 就可以: >

	:command -nargs=+ Say :echo <q-args>

現在上面的 ":Say" 命令會引發下面的命令被執行: >

	:echo "he said \"hello\""

關鍵字 <f-args> 包括與 <args> 一樣的資訊，不過它將其轉換成適用於函式呼叫的格
式。例如:
>
	:command -nargs=* DoIt :call AFunction(<f-args>)
	:DoIt a b c

會執行下面的命令: >

	:call AFunction("a", "b", "c")


行 範 圍

有些命令需要一個範圍作為引數。要告訴 Vim 你需要定義這樣的命令，使用 -range 選
項。它可能的值如下:

	-range		允許範圍；預設為當前行。
	-range=%	允許範圍；預設為整個檔案。
	-range={count}	允許範圍；只用該範圍最後的行號作為單個數字的引數，其缺
			省值為 {count}。

當一個範圍被指定時，關鍵字 <line1> 和 <line2> 可以用來取得範圍的首行和末行的行
號。例如，下面的命令定義一個將指定的範圍寫入檔案 "save_file" 的命令 －
SaveIt: >

	:command -range=% SaveIt :<line1>,<line2>write! save_file


其 它 選 項

其它的一些選項有:

	-count={number}		命令可以帶 count 引數，預設為 {number}。
				用 <count> 關鍵字可以訪問該引數。
	-bang			允許使用 !。若 ! 出現，<bang> 擴充套件為 !。
	-register		你可以指定一個暫存器。(預設為無名暫存器。)
				指定的暫存器可通過 <reg> (即 <register>) 來操
				作。
	-complete={type}	給出命令列補全的方式。|:command-completion|
				列出了所有可用值。
	-bar			命令後可用 | 加另外一個命令，或 " 加一個註釋。
	-buffer			命令僅對當前緩衝區有效。

最後，你還可以使用 <lt> 關鍵字來代表字元 <。這樣可以轉義上面提到的 <> 專案的特
殊含義。


重 定 義 和 刪 除

! 引數可以用來重新定義相同的命令: >

	:command -nargs=+ Say :echo "<args>"
	:command! -nargs=+ Say :echo <q-args>

要刪除自定義命令，使用 ":delcommand"。該命令只帶一個引數，那就是自定義命令的
名字。例: >

	:delcommand SaveIt

要一次刪除所有的自定義命令: >

	:comclear

要當心！這個命令無法撤銷。

關於所有這些內容的更多資訊可參閱參考手冊: |user-commands|。

==============================================================================
*40.3*	自動命令

自動命令是一類特殊的命令。當某些事件，例如檔案讀入或改變緩衝區等事件發生時，它
們會自動被執行。例如，通過自動命令你可以教 Vim 來編輯壓縮檔案。這個功能被用在
|gzip| 外掛裡。
   自動命令非常強大。如果你小心使用的話，自動命令可以省去你很多自己敲命令的麻
煩。如果不當心的話你就是自找麻煩。

假設你希望在每次寫入檔案時自動的替換檔案尾部的日期戳。先定義一個函式: >

	:function DateInsert()
	:  $delete
	:  read !date
	:endfunction

你需要在每次緩衝區寫入檔案之前想辦法呼叫該函式。下面這一行就能做到: >

	:autocmd FileWritePre *  call DateInsert()

"BufWritePre" 是這個自動命令的觸發事件: 把緩衝區寫入檔案前 (pre)。"*" 是一個用
來匹配檔名的模式。這兒它匹配所有檔案。
   如果這個命令生效，當你呼叫 ":write" 時，Vim 檢查是否有匹配 BufWritePre 事件
的自動命令並執行它們。然後才執行 ":write"。
   通用的 :autocmd 命令格式如下: >

	:autocmd [group] {events} {file_pattern} [nested] {command}

組名  [group] 是可選的。它被用來管理和呼叫命令 (後面再講)。{events} 引數是一個
觸發事件列表 (用逗號隔開)。
   {file_pattern} 是檔案命令，通常帶有萬用字元。例如，用 "*.txt" 會使得自動命令
對所有檔名以 ".txt" 結尾的檔案被呼叫。選項 [nested] 允許自動命令的巢狀 (見
下)。最後，{command} 是要被執行的命令。


事 件

最有用的事件之一是 BufReadPost。它在一個檔案被調入編輯之後被觸發。常被用來設定
相關的選項。例如，你已知 ".gsm" 檔案是 GNU 彙編程式原始碼。為確保使用正確的語法
檔案，可以定義這樣的自動命令: >

	:autocmd BufReadPost *.gsm  set filetype=asm

如果 Vim 能夠正確的識別檔案型別的話，它將為你設定 'filetype' 選項。這會觸發
Filetype 事件。你可以利用這個來為某一型別的檔案做編輯的準備工作。例如，要為文
本檔案調入一組縮寫: >

	:autocmd Filetype text  source ~/.vim/abbrevs.vim

在開始編輯一個新檔案時，你可以要求 Vim 插入一個模板: >

	:autocmd BufNewFile *.[ch]  0read ~/skeletons/skel.c

在 |autocmd-events| 可以找到一個完整的事件列表。


匹 配 模 式

那個 {file_pattern} 引數實際上可以是一個以逗號分割開的模式列表。例如:
"*.c,*.h" 匹配所有檔名以 ".c" 和 ".h" 結尾的檔案。
   常見的檔案萬用字元都可以使用。這裡給出一個最常用的清單:

	*		匹配任意字元，任意多次
	?		匹配任意字元，一次
	[abc]		匹配 a、b 或 c
	.		匹配一個點 .
	a{b,c}		匹配 "ab" 和 "ac"

當模式包括斜槓 (/) 時 Vim 會比較路徑名。否則只有檔名的最後部分才用來作比較。
例如，"*.txt" 匹配 "/home/biep/readme.txt"。模式 "/home/biep/*" 也可以匹配那個
檔案。但是 "home/foo/*.txt" 就不行。
   當包括斜槓時，Vim 會試著匹配檔案的完整路徑 ("/home/biep/readme.txt") 和相對
路徑 (例如:  "biep/readme.txt")。

	備註:
	當在使用反斜槓作為檔案分隔符的系統 (如 MS-Windows) 上工作時，你也得在
	自動命令中使用正斜槓。這會使編寫匹配模式變得容易些，因為反斜槓有特殊的
	意義。它同時也使自動命令更具可移植性。


刪 除

要刪除一個自動命令，使用和定義它一樣的命令格式。但不要包括後面的 {command}
部分，而且要加上 !。例如: >

	:autocmd! FileWritePre *

這樣會刪除為 "FileWritePre" 事件定義的匹配 "*" 檔名模式的所有自動命令。


列 表

要列出當前定義的所有自動命令，用這個: >

	:autocmd

這個列表可能會相當長，特別是在使用了檔案型別檢測時。你可以指定組，事件和／或
檔名模式來要求僅列出相關的命令。例如，要列出 BufNewFile 事件的所有自動命
令: >

	:autocmd BufNewFile

列出所有匹配檔名模式 "*.c" 的命令: >

	:autocmd * *.c

使用 "*" 作為事件會給出所有事件的列表。要列出 cprograms 組對應的自動命令: >

	:autocmd cprograms


組

當定義自動命令時用到 {group} 這一項時，自動命令會被分成組。比如說，這可以被用
來刪除一個組中的所有命令。
   在為某一個組定義數個自動命令時，可以使用 ":augroup" 命令。例如，我們來定義
一些用於 C 程式的自動命令: >

	:augroup cprograms
	:  autocmd BufReadPost *.c,*.h :set sw=4 sts=4
	:  autocmd BufReadPost *.cpp   :set sw=3 sts=3
	:augroup END

這和下面的命令有一樣的效果: >

	:autocmd cprograms BufReadPost *.c,*.h :set sw=4 sts=4
	:autocmd cprograms BufReadPost *.cpp   :set sw=3 sts=3

要刪除 "cprograms" 組中的所有自動命令: >

	:autocmd! cprograms


嵌 套

一般的，某一事件觸發的自動命令在被執行時不會再觸發其它事件。例如，當因
FileChangedShell 事件而讀入一個檔案時，那些被定義來設定語法的自動命令就不會被
觸發。要使那些命令被觸發，加上一個 "nested" 引數: >

	:autocmd FileChangedShell * nested  edit


執 行 自 動 命 令

Vim 允許你用模擬某一事件發生的辦法來觸發一個自動命令。這可以在一個自動命令裡用
來觸發另外一個。例如: >

	:autocmd BufReadPost *.new  execute "doautocmd BufReadPost " . expand("<afile>:r")

這定義了一個新檔案開始編輯之後觸發的自動命令。這個檔案的檔名必須以 ".new" 結
尾。其中的 ":execute" 命令利用表示式求值來組成一個新的命令並執行之。當編輯檔案
"tryout.c.new" 時被執行的命令將是: >

	:doautocmd BufReadPost tryout.c

expand() 函式的引數是 "<afile>"，用來代表自動命令執行所關聯的檔案。":r" 指定僅
使用其根部分。

":doautocmd" 執行於當前緩衝區。":doautoall" 命令於 "doautocmd" 命令類似但執行
於所有緩衝區。


使 用 普 通 模 式 命 令

自動命令所執行的命令是 "命令列" 命令。如果你想在其中執行普通模式命令，可以使用
":normal" 命令。例如: >

	:autocmd BufReadPost *.log normal G

這樣，當你編輯 *.log 檔案時 Vim 會將游標移動到最後一行。
   使用 ":normal" 命令需要點技巧。首先，你要確保其引數是一個包括所有引數的完整
命令。當你用 "i" 進入插入模式時，你必須用 <Esc> 離開。如果你用 "/" 來開始查
找，你也必須用 <CR> 執行該查詢命令。
   ":normal" 命令會使用其後的所有文字作為將要執行的命令。因此不可能用 | 來後跟
另一個命令。有個辦法可以繞過這個約束: 把 ":normal" 命令放在 ":execute" 命令之
內。這個方法同時也方便了不可顯示的字元作為引數的傳遞。例如: >

	:autocmd BufReadPost *.chg execute "normal ONew entry:\<Esc>" |
		\ 1read !date

上面的例子還展示瞭如何用反斜槓來將一個長命令分為幾行。這可以用在 Vim 指令碼中
(不能用在命令列)。

如果你想讓你的自動命令作一些複雜的操作，其中涉及在檔案間跳轉然後回到原來位置，
你希望能夠恢復檔案的視窗位置。|restore-position| 有些例子。


忽 略 事 件

有些時候，你並不想觸發自動命令。'eventignore' 選項包括了一組會被 Vim 完全忽略
的事件。例如，下面的命令會使得進入和離開視窗的事件被忽略掉: >

	:set eventignore=WinEnter,WinLeave

要忽略所有的事件，用下面的命令: >

	:set eventignore=all

要恢復到正常的狀態，把 'eventignore' 設定為空即可: >

	:set eventignore=

==============================================================================

下一章: |usr_41.txt|  編寫 Vim 指令碼

版權: 見 |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
