*usr_41.txt*	For Vim version 8.0.  最近更新: 2013年8月

		     VIM 使用者手冊 - by Bram Moolenaar
		     譯者: lang2、Willis http://vimcdoc.sf.net

			      編寫 Vim 指令碼


Vim 指令碼語言在很多地方用到，包括 vimrc 檔案，語法檔案，等等。本章討論 Vim 指令碼
相關的知識。這樣的內容有很多，所以本章也比較長。

|41.1|	簡介
|41.2|	變數
|41.3|	表示式
|41.4|	條件語句
|41.5|	執行一個表示式
|41.6|	使用函式
|41.7|	定義一個函式
|41.8|	列表和字典
|41.9|	例外
|41.10|	其它討論
|41.11|	編寫外掛
|41.12|	編寫檔案型別外掛
|41.13|	編寫編譯器外掛
|41.14|	編寫快速載入的外掛
|41.15|	編寫庫指令碼
|41.16|	釋出 Vim 指令碼

           下一章: |usr_42.txt|  新增新的選單
           前一章: |usr_40.txt|  建立新的命令
             目錄: |usr_toc.txt|

==============================================================================
*41.1*	簡介					*vim-script-intro* *script*

你最初接觸到 Vim 指令碼是在 vimrc 檔案裡。當 Vim 啟動時它將讀取該檔案的內容並執
行其中的命令。你可以在其中設定選項。你也可以在其中使用任何冒號命令 (以 ":" 開
頭的命令；這些命令有時也被稱作 Ex 命令或命令列命令)。
   語法檔案其實也是 Vim 指令碼。專為某種檔案型別設定選項的檔案也是。一個很複雜的
巨集可以被單獨的定義在一個 Vim 指令碼檔案中。你可以自己想到其它的應用。

讓我們從一個簡單的例子開始: >

	:let i = 1
	:while i < 5
	:  echo "count is" i
	:  let i += 1
	:endwhile
<
	備註:
	那些 ":" 字元並非必須。只有在你鍵入命令時才需要，在編寫 Vim 指令碼時可以
	去掉。在這裡用一是為了清楚，二是為了區別於普通模式命令。
	備註:
	你可以拷貝這裡的示例文字，然後用 :@" 執行。

本例的輸出是:

	count is 1 ~
	count is 2 ~
	count is 3 ~
	count is 4 ~

第一行的 ":let" 命令給一個變數賦值。通常的用法是: >

	:let {變數} = {表示式}

在例子中變數名是 "i" 而表示式是一個簡單的數值 1。
   ":while" 命令開始一個迴圈。通常的用法是: >

	:while {條件}
	:  {語句}
	:endwhile

只要條件為真，"while" 和 ":endwhile" 包圍的語句就會被執行。在例子中使用的條件
是表示式 "i < 5"。這個條件在變數 i 小於五時總是真的。
	備註:
	如果你碰巧寫了一個死迴圈語句，你可以用 CTRL-C 來終止 (在 MS-Windows
	上使用 CTRL-Break)。

":echo" 命令顯示它的引數。在這個例子中的引數是字串 "count is" 和變數 i 的
值。因為開始時 i 的值是 1，所以將會顯示:

	count is 1 ~

接著是 ":let i += 1" 命令。該命令相當於 ":let i = i + 1"。在變數 i 上加一併將
新的值賦給同一個變數。

給出本例是為了解釋命令，不過如果你真的要寫這樣一個迴圈，下面的表達更加簡潔: >

	:for i in range(1, 4)
	:  echo "count is" i
	:endfor

我們現在不解釋 |:for| 和 |range()| 如何工作，一會兒再說。如果你沒有耐心，點選
這些連結。


三 種 數 值

數值可以是十進位制，十六進位制，或者八進位制的。以 "0x" 或 "0X" 開始的數值是十六進位制
的。例如 "0x1f" 代表十進位制 31。以零開始的數值是八進位制的。"017" 代表十進位制 15。
當心: 不要在十進位制數前添上零，那樣該數值將會被作為八進位制數對待！
   ":echo" 命令總以十進位制格式顯示數值。例: >

	:echo 0x7f 036
<	127 30 ~

在一個數值前加上減號會將其變為負值。十六進位制數和八進位制數亦然。減號也用於減法操
作。將下例與前面的比較: >

	:echo 0x7f -036
<	97 ~

表示式中的空白字元將被忽略。然而，為了增加表示式的易讀性，建議用來分隔不同的項
目。例如，為了不和上面的負號混淆，在減號和之後的數字前加入一個空格: >

	:echo 0x7f - 036

==============================================================================
*41.2*	變數

一個變數名可以由 ASCII 字元、數字和下劃線組成。但是變數名不能以數字開始。以下
是幾個有效的變數名:

	counter
	_aap3
	very_long_variable_name_with_dashes
	FuncLength
	LENGTH

"foo+bar" 和 "6var" 都是無效的變數名。
   這些變數都是全域性的。要列出當前定義的所有變數可以用這個命令: >

	:let

你可以在任何地方使用全域性變數。這同時也意味著: 當一個指令碼檔案使用 "count" 變數
時，可能另一個指令碼檔案也使用了這個變數。這至少會引起混亂，嚴重時會導致指令碼無法
正常工作。為避免這種情況發生，你可以在變數名前加上 "s:" 使其變成指令碼檔案的區域性
變數。例如，一指令碼包含以下程式碼: >

	:let s:count = 1
	:while s:count < 5
	:  source other.vim
	:  let s:count += 1
	:endwhile

由於 "s:count" 是區域性變數，你可以確信呼叫 (source) "other.vim" 指令碼時不會改變
它的值。如果 "other.vim" 也使用一個 "s:count" 變數，該變數將會是僅在指令碼內有效
的區域性變數。更多關於指令碼區域性變數可以在這裡讀到: |script-variable|。

還有很多其它型別的變數，參閱 |internal-variables|。最常用的幾類有:

	b:name		緩衝區的區域性變數
	w:name		視窗的區域性變數
	g:name		全域性變數 (也用於函式中)
	v:name		Vim 預定義的變數


刪 除 變 量

變數不僅僅可以在 ":let" 命令顯示，同時也佔用記憶體空間。為了刪除一個變數可以使用
":unlet" 命令。例: >

	:unlet s:count

這將刪除 "s:count" 這個指令碼區域性變數並釋放其佔用的記憶體。如果你並不確定這個變數
是否存在，但並不希望系統在它不存在時報錯，可以在命令後新增 !: >

	:unlet! s:count

當一個指令碼結束時，它使用的區域性變數不會自動被刪除。下一次指令碼被執行時，舊的變數
值仍可被使用。例: >

	:if !exists("s:call_count")
	:  let s:call_count = 0
	:endif
	:let s:call_count = s:call_count + 1
	:echo "called" s:call_count "times"

"exists()" 函式檢查一個變數是否已經被定義過了。它的引數是你想檢查的變數的名
字。而不是變數本身！如果你這樣做: >

	:if !exists(s:call_count)

那麼變數 s:call_count 的值將被用來做檢測。你不會得到想的結果。
   驚歎號 ! 將一個值取反。當該值為真時，表示式的值為假。當該值為假時，表示式的
值為真。你可以把它讀作 "not"。這樣 "if !exists()" 可以被讀作 "if not exists()"
(如果-不-存在)。
   Vim 把任何非零的值當作真。零代表假。
	注意:
	如果期待數值型別，Vim 自動把字串轉換為數值。如果使用不以數字開始的字
	符串，返回的數值為零。所以小心這種程式碼: >
		:if "true"
<	這裡 "true" 會被解讀為零，也就是假值！


字 符 串 變 量 和 常 量

到目前為止我們只用到了數值作為變數的值。同樣的我們可以使用字串。這兩種變數類
型是 Vim 支援的基本型別。變數的型別是動態的。每當我們通過 ":let" 語句為變數賦
值時，變數的型別才被確定。型別更多的內容見 |41.8|。
   你需要使用字串常量來為字串變數賦值。字串常量有兩種。第一種是由雙引號
括起來的: >

	:let name = "peter"
	:echo name
<	peter ~

如果你想在這樣的字串內使用雙引號，在之前加上反斜槓即可: >

	:let name = "\"peter\""
	:echo name
<	"peter" ~

如果你不想使用反斜槓，也可以用單引號括起字串: >

	:let name = '"peter"'
	:echo name
<	"peter" ~

所有的字元在單引號內都保持其本來面目。只有單引號本身例外: 輸入兩個你會得到一個
單引號。因為反斜槓在其中也被作為其本身來對待，你無法使用它來改變其後的字元的意
義。
   在雙引號括起來的字串中可以使用特殊字元。這裡有一些有用的例子:

	\t		<Tab>
	\n		<NL>，換行
	\r		<CR>，<Enter>
	\e		<Esc>
	\b		<BS>，退格
	\"		"
	\\		\，反斜槓
	\<Esc>		<Esc>
	\<C-W>		CTRL-W

最後兩個只是用來舉例子的。"\<name>" 的形式可以被用來表示特殊的鍵 "name"。
   在 |expr-quote| 中列出了全部的特殊字元。

==============================================================================
*41.3*	表示式

Vim 指令碼支援的表示式很豐富，也很容易使用。你可以在這裡讀到表示式的定義:
|expression-syntax|。這裡我們只看看常用的幾個。
   已經提到的那些數值，字串常量和變數都屬於表示式。因此任何可以使用表示式的
地方，數值，字串變數和常量都可以使用。其它基本的表示式有:

	$NAME		環境變數
	&name		選項
	@r		暫存器

例子: >

	:echo "The value of 'tabstop' is" &ts
	:echo "Your home directory is" $HOME
	:if @a > 5

&name 這種形式可以被用來暫時改變一個選項的值。例: >

	:let save_ic = &ic
	:set noic
	:/The Start/,$delete
	:let &ic = save_ic

這樣既確保了在匹配 "The Start" 模式時 'ignorecase' 選項是關閉的，同時也保留了
使用者原來的選項值。(另一個方法是在模式里加上 "\C"，見 |/\C|。)


算 術

我們把這些基本的東西都混合起來用就更有趣了。先來看看算術運算:

	a + b		加
	a - b		減
	a * b		乘
	a / b		除
	a % b		餘

先乘除，後加減。例如: >

	:echo 10 + 5 * 2
<	20 ~

括號內的先計算。這也沒什麼奇怪的。例如: >

	:echo (10 + 5) * 2
<	30 ~

用 "." 可以把兩個字串連線起來。例如: >

	:echo "foo" . "bar"
<	foobar ~

一般的，當 ":echo" 命令遇到多個引數時，會在它們之間加入空格。但上例中引數是一
個表示式，所以不會有空格。

下面的條件表示式很顯然是從 C 語言裡借來的:

	a ? b : c

如果 "a" 為真用 "b"，否則用 "c"。例如: >

	:let i = 4
	:echo i > 5 ? "i is big" : "i is small"
<	i is small ~

在整個表示式被求值前，結構中的三部分總是先被求值的。因此你可以將其視為:

	(a) ? (b) : (c)

==============================================================================
*41.4*	條件語句

":if" 命令在條件滿足的前提下，執行其後直到 ":endif" 的所有語句。常用的形式為:

	:if {condition}
	   {statements}
	:endif

語句 {statements} 僅當表示式 {condition} 為真 (非零) 時才被執行。這些語句還必
須是有效的。否則 Vim 無法找到相應的 ":endif"。
   你也可以使用 ":else"。常用形式為:

	:if {condition}
	   {statements}
	:else
	   {statements}
	:endif

第二組 {statements} 僅當條件不滿足時被執行。
   最後還有 ":elseif":

	:if {condition}
	   {statements}
	:elseif {condition}
	   {statements}
	:endif

這種形式就像 ":else" 接著 "if" 一樣，但是少出現一個 ":endif"。
   下面是一個有用的例子 (可以用在你的 vimrc 檔案裡): 它檢查 'term' 選項並根據
不同的值做不同的操作: >

	:if &term == "xterm"
	:  " Do stuff for xterm
	:elseif &term == "vt100"
	:  " Do stuff for a vt100 terminal
	:else
	:  " Do something for other terminals
	:endif


邏 輯 操 作

實際上我們在前面的幾個例子中已經是用到了。下面是幾個最常用的形式:

	a == b		等於
	a != b		不等於
	a >  b		大於
	a >= b		大於等於
	a <  b		小於
	a <= b		小於等於

如果條件滿足，結果為 1，否則為 0。例如: >

	:if v:version >= 700
	:  echo "祝賀"
	:else
	:  echo "你在使用舊的版本，升級！"
	:endif

這裡 "v:version" 是 Vim 定義的變數，用來存放 Vim 的版本號。600 意為 6.0 版。
6.1 版的值為 601。這對編寫可以在不同版本的 Vim 上執行的指令碼很有用。參閱
|v:version|

對數值和字串都可以做邏輯操作。兩個字串的算術差被用來比較它們的值。這個結果
是通過位元組值來計算的，對於某些語言，這樣做的結果未必正確。
   在比較一個字串和一個數值時，該字串將先被轉換成一個數值。這容易出錯，因
為當一個字串看起來不像數值時，它會被當作 0 對待。例如: >

	:if 0 == "one"
	:  echo "yes"
	:endif

上面的例子將顯示 "yes"，因為 "one" 看起來不像一個數值，所以被轉換為 0 了。

對於字串來說還有兩種操作:

	a =~ b		匹配
	a !~ b		不匹配

左邊的 "a" 被當作一個字串。右邊的 "b" 被當作一個匹配模式，正如做查詢操作一
樣。例如: >

	:if str =~ " "
	:  echo "字串包括空格"
	:endif
	:if str !~ '\.$'
	:  echo "字串不以句號結尾"
	:endif

注意 在匹配模式中用單引號是很有用的。因為匹配模式中通常有很多反斜槓，而反斜槓
在雙引號字串中必須雙寫才有效。

在做字串比較時用到 'ignorecase' 選項。如果你不希望使用該選項，可以在比較時加
上 "#" 或 "?"。"#" 表示大小寫敏感；"?" 表示忽略大小寫。因此 "==?" 比較兩字串
是否相等，不計大小寫。"!~#" 檢查一個模式是否被匹配，同時也考慮大小寫。
|expr-==| 有一個完整的字串比較/匹配操作列表。



循 環 詳 述

":while" 命令已經在前面提到了。還有另外兩條語句可以在 ":while" 和 ":endwhile"
之間使用。

	:continue		跳回 while 迴圈的開始；繼續迴圈
	:break			跳至 ":endwhile"；迴圈結束

例: >

	:while counter < 40
	:  call do_something()
	:  if skip_flag
	:    continue
	:  endif
	:  if finished_flag
	:    break
	:  endif
	:  sleep 50m
	:endwhile

":sleep" 命令使 Vim 小憩一下。"50m" 表示休息 50 毫秒。再舉一個例子，":sleep 4"
休息 4 秒。

更多迴圈可以用 ":for" 命令實現，見下面的 |41.8|。

==============================================================================
*41.5*	執行一個表示式

到目前為止，指令碼內的語句都是由 Vim 直接執行的。用 ":execute" 命令可以執行一個
表示式的結果。這是一個建立並執行命令的非常有效的方法。
   例如要跳轉到一個由變量表示的標籤: >

	:execute "tag " . tag_name

"." 被用來連線字串 "tag " 和變數 "tag_name" 的值。假設 "tag_name" 的值為
"get_cmd"，那麼被將執行的命令將是: >

	:tag get_cmd

":execute" 命令只能用來執行冒號命令。":normal" 命令可以用來執行普通模式命令。
然而，它的引數只能是按表面意義解釋的命令字元，不能是表示式。例如: >

	:normal gg=G

這個命令將跳轉到第一行並以 "=" 操作符排版所有行。
   為了使 ":normal" 命令也可以帶表示式，可以把 ":execute" 與其連起來使用。
例: >

	:execute "normal " . normal_commands

變數 "normal_commands" 必須包含要執行的普通模式命令。
   必須確保 ":normal" 的引數是一個完整的命令。否則，Vim 碰到引數的結尾就會中止
其執行。例如，如果你開始了插入模式，你必須也退出插入模式。這樣沒問題: >

	:execute "normal Inew text \<Esc>"

這將在當前行插入 "new text "。注意 這裡使用了特殊鍵 "\<Esc>"。這樣就避免了在你
的腳本當中鍵入真正的 <Esc> 字元。

如果你不想執行字串，而想執行它作為表示式計算的結果，可以用 eval() 函式: >

	:let optname = "path"
	:let optval = eval('&' . optname)

"&" 被加到 "path" 前面，這樣傳給 eval() 的引數成為 "&path"。這時得到的返回值就
是 'path' 選項的值。
   相同的操作可以這樣完成: >
	:exe 'let optval = &' . optname

==============================================================================
*41.6*	使用函式

Vim 定義了大量的函式並通過這些函式提供了豐富的功能。本節將給出一些例子。你可以
在 |functions| 找到一個完整的列表。

一個函式可以被 ":call" 命令呼叫。引數列表要用括號括起來，並用逗號分割。例如: >

	:call search("Date: ", "W")

這將以 "Date: " 和 "W" 為引數呼叫 search() 函式。search() 函式的第一個引數是
一個查詢模式，第二個是一個標誌。標誌 "W" 表示查詢操作遇到檔案尾時不折返。

在一個表示式內也可以呼叫函式。例如: >

	:let line = getline(".")
	:let repl = substitute(line, '\a', "*", "g")
	:call setline(".", repl)

getline() 函式從當前緩衝區獲取一行文字。其引數是行號。在本例中，"." 表示游標所
在行。
   substitute() 函式的功能和 ":substitute" 命令相似。它的第一個引數是要執行替
換操作的源字串。第二個引數是一個匹配模式，第三個引數是替換字串。最後一個參
數是一個標誌位。
   setline() 函式將第一個引數表示的行的文字置為第二個引數表示的字串。本例中
游標所在的行被 substitute() 函式的結果所替換。因此這三條語句的效果等同於: >

	:substitute/\a/*/g

如果你在呼叫 substitute() 之前或之後有更多的事情要做的話，用函式的方式就會更有
趣了。


函 數							*function-list*

Vim 提供的函式很多。這裡我們以它們的用途分類列出。你可以在 |functions| 找到一
個以字母順序排列的列表。在函式名上使用 CTRL-] 可以跳轉至該函式的詳細說明。

字串操作:						*string-functions*
	nr2char()		通過 ASCII 碼值取得一個字元
	char2nr()		取得字元的 ASCII 碼值
	str2nr()		把字串轉換為數值
	str2float()		把字串轉換為浮點數
	printf()		根據 % 專案格式化字串
	escape()		將字串通過 '\' 轉義
	shellescape()		轉義字串用於外殼命令
	fnameescape()		轉義 Vim 命令使用的檔名
	tr()			把一組字元翻譯成另一組
	strtrans()		將一個字串變成可顯示的格式
	tolower()		將一個字串轉換為小寫
	toupper()		將一個字串轉換為大寫
	match()			字串中的模式匹配處
	matchend()		字串中的模式匹配結束處
	matchstr()		在一個字串中匹配一個模式
	matchstrpos()		字串中滿足匹配的模式和位置
	matchlist()		類似 matchstr()，同時返回子匹配
	stridx()		子串在母串中第一次出現的地方
	strridx()		子串在母串中最後一次出現的地方
	strlen()		以位元組計的字串長度
	strchars()		以字元計的字串長度
	strwidth()		字串的顯示長度
	strdisplaywidth()	字串的顯示長度，處理製表
	substitute()		用一個字串替換一個匹配的模式
	submatch()		取得 ":s" 和 substitute() 匹配中指定的某個匹配
	strpart()		用位元組索引取得字串的子串
	strcharpart()		用字元索引獲取字串的子串
	strgetchar()		用字元索引獲取字串裡的字元
	expand()		展開特殊的關鍵字
	iconv()			轉換文字編碼格式
	byteidx()		字串裡字元的位元組位置
	byteidxcomp()		類似於 byteidx()，但計算合成用字元
	repeat()		重複字串多次
	eval()			計算字串表示式
	execute()		執行 Ex 命令並獲取輸出

列表處理:						*list-functions*
	get()			得到專案，錯誤索引不報錯
	len()			列表的專案總數
	empty()			檢查列表是否為空
	insert()		在列表某處插入專案
	add()			在列表後附加專案
	extend()		在列表後附加另一個列表
	remove()		刪除列表裡一或多個專案
	copy()			建立列表的淺備份
	deepcopy()		建立列表的完整備份
	filter()		刪除列表的選定專案
	map()			改變每個列表專案
	sort()			給列表排序
	reverse()		反轉列表專案的順序
	uniq()			刪除重複鄰接專案的備份
	split()			分割字串成為列表
	join()			合併列表專案成為字串
	range()			返回數值序列的列表
	string()		列表的字串表示形式
	call()			呼叫函式，引數以列表形式提供
	index()			列表裡某值的索引
	max()			列表專案的最大值
	min()			列表專案的最小值
	count()			計算列表裡某值的出現次數
	repeat()		重複列表多次

字典處理:						*dict-functions*
	get()			得到專案，錯誤的鍵不報錯
	len()			字典專案的總數
	has_key()		檢查某鍵是否出現在字典裡
	empty()			檢查字典是否為空
	remove()		刪除字典的專案
	extend()		從一個字典增加專案到另一個字典
	filter()		刪除字典的選定專案
	map()			改變每個字典專案
	keys()			得到字典的鍵列表
	values()		得到字典的值列表
	items()			得到字典的鍵-值組對的列表
	copy()			建立字典的淺備份
	deepcopy()		建立字典的完整備份
	string()		字典的字串表示形式
	max()			字典專案的最大值
	min()			字典專案的最小值
	count()			計算字典裡某值的出現次數

浮點數計算:						*float-functions*
	float2nr()		把浮點數轉換為數值
	abs()			絕對值 (也適用於數值)
	round()			四捨五入
	ceil()			向上取整
	floor()			向下取整
	trunc()			刪除小數點後的值
	fmod()			除法的餘數
	exp()			指數
	log()			自然對數 (以 e 為底的對數)
	log10()			以 10 為底的對數
	pow()			x 的 y 次方
	sqrt()			平方根
	sin()			正弦
	cos()			餘弦
	tan()			正切
	asin()			反正弦
	acos()			反餘弦
	atan()			反正切
	atan2()			反正切
	sinh()			雙曲正弦
	cosh()			雙曲餘弦
	tanh()			雙曲正切
	isnan()			檢查非數

其它計算:						*bitwise-function*
	and()			按位與
	invert()		按位取反
	or()			按位或
	xor()			按位異或
	sha256()		SHA-256 雜湊

變數:						 	*var-functions*
	type()			變數的型別
	islocked()		檢查變數是否加鎖
	funcref()		返回指向函式的函式引用
	function()		得到函式名對應的函式引用
	getbufvar()		取得指定緩衝區中的變數值
	setbufvar()		設定指定緩衝區中的變數值
	getwinvar()		取得指定視窗的變數值
	gettabvar()		取得指定標籤頁的變數值
	gettabwinvar()		取得指定視窗和標籤頁的變數值
	setwinvar()		設定指定視窗的變數值
	settabvar()		設定指定標籤頁的變數值
	settabwinvar()		設定指定視窗和標籤頁的變數值
	garbagecollect()	可能情況下釋放記憶體

游標和位置標記位置:			*cursor-functions* *mark-functions*
	col()			游標或位置標記所在的列
	virtcol()		游標或位置標記所在的螢幕列
	line()			游標或位置標記所在行
	wincol()		游標所在視窗列
	winline()		游標所在視窗行
	cursor()		置游標於 行／列 處
	screencol()		得到游標的螢幕列
	screenrow()		得到游標的螢幕行
	getcurpos()		得到游標位置
	getpos()		得到游標、位置標記等的位置
	setpos()		設定游標、位置標記等的位置
	byte2line()		取得某位元組位置所在行號
	line2byte()		取得某行之前的位元組數
	diff_filler()		得到一行之上的填充行數目
	screenattr()		得到遮蔽行的屬性
	screenchar()		得到遮蔽行的字元程式碼

操作當前緩衝區的文字:					*text-functions*
	getline()		從緩衝區中取一行
	setline()		替換緩衝區中的一行
	append()		附加行或行的列表到緩衝區
	indent()		某行的縮排
	cindent()		根據 C 縮排法則的某行的縮排
	lispindent()		根據 Lisp 縮排法則的某行的縮排
	nextnonblank()		查詢下一個非空白行
	prevnonblank()		查詢前一個非空白行
	search()		查詢模式的匹配
	searchpos()		尋找模式的匹配
	searchpair()		查詢 start/skip/end 配對的另一端
	searchpairpos()		查詢 start/skip/end 配對的另一端
	searchdecl()		查詢名字的宣告
	getcharsearch()		返回字元搜尋資訊
	setcharsearch()		設定字元搜尋資訊

					*system-functions* *file-functions*
系統呼叫及檔案操作:
	glob()			展開萬用字元
	globpath()		在幾個路徑中展開萬用字元
	glob2regpat()		轉換 glob 模式到搜尋模式
	findfile()		在目錄列表裡查詢檔案
	finddir()		在目錄列表裡查詢目錄
	resolve()		找到一個快捷方式所指
	fnamemodify()		改變檔名
	pathshorten()		縮短路徑裡的目錄名
	simplify()		簡化路徑，不改變其含義
	executable()		檢查一個可執行程式是否存在
	exepath()		可執行程式的完整路徑
	filereadable()		檢查一個檔案可讀與否
	filewritable()		檢查一個檔案可寫與否
	getfperm()		得到檔案許可權
	setfperm()		設定檔案許可權
	getftype()		得到檔案型別
	isdirectory()		檢查一個目錄是否存在
	getfsize()		取得檔案大小
	getcwd()		取得當前工作路徑
	haslocaldir()		檢查當前視窗是否使用過 |:lcd|
	tempname()		取得一個臨時檔案的名稱
	mkdir()			建立新目錄
	delete()		刪除檔案
	rename()		重新命名檔案
	system()		得到字串形式的外殼命令結果
	systemlist()		得到列表形式的外殼命令結果
	hostname()		系統的名稱
	readfile()		讀入檔案到一個行列表
	writefile()		把一個行列表寫到檔案裡

日期和時間:				*date-functions* *time-functions*
	getftime()		得到檔案的最近修改時間
	localtime()		得到以秒計的當前時間
	strftime()		把時間轉換為字串
	reltime()		得到準確的當前或者已經經過的時間
	reltimestr()		把 reltime() 的結果轉換為字串
	reltimefloat()		把 reltime() 的結果轉換為浮點數

			*buffer-functions* *window-functions* *arg-functions*
緩衝區，視窗及引數列表:
	argc()			引數列表項數
	argidx()		引數列表中的當前位置
	arglistid()		得到引數列表的編號
	argv()			從引數列表中取得一項
	bufexists()		檢查緩衝區是否存在
	buflisted()		檢查緩衝區是否存在並在列表內
	bufloaded()		檢查緩衝區是否存在並已載入
	bufname()		取得某緩衝區名
	bufnr()			取得某緩衝區號
	tabpagebuflist()	得到標籤頁裡的緩衝區列表
	tabpagenr()		得到標籤頁號
	tabpagewinnr()		類似於特定標籤頁裡的 winnr()
	winnr()			取得當前視窗的視窗號
	bufwinid()		取得某緩衝區的視窗 ID
	bufwinnr()		取得某緩衝區的視窗號
	winbufnr()		取得某視窗的緩衝區號
	getbufline()		得到指定緩衝區的行列表
	win_findbuf()		尋找包括某緩衝區的視窗
	win_getid()		取得視窗的視窗 ID
	win_gotoid()		轉到指定 ID 的視窗
	win_id2tabwin()		給出視窗 ID 獲取標籤頁號和視窗號
	win_id2win()		把視窗 ID 轉換為視窗號
	getbufinfo()		獲取緩衝區資訊的列表
	gettabinfo()		獲取標籤頁資訊的列表
	getwininfo()		獲取視窗資訊的列表

命令列:						*command-line-functions*
	getcmdline()		得到當前命令列
	getcmdpos()		得到命令列裡的游標位置
	setcmdpos()		設定命令列裡的游標位置
	getcmdtype()		得到當前命令列的型別
	getcmdwintype()		返回當前命令列視窗型別
	getcompletion()		命令列補全匹配的列表

quickfix 和位置列表:				*quickfix-functions*
	getqflist()		quickfix 錯誤的列表
	setqflist()		修改 quickfix 列表
	getloclist()		位置列表專案的列表
	setloclist()		修改位置列表

插入模式補全:					*completion-functions*
	complete()		設定要尋找的匹配
	complete_add()		加入要尋找的匹配
	complete_check()	檢查補全是否被中止
	pumvisible()		檢查彈出選單是否顯示

摺疊:						*folding-functions*
	foldclosed()		檢查某一行是否被摺疊起來
	foldclosedend()		類似 foldclosed() 但同時返回最後一行
	foldlevel()		檢查某行的摺疊級別
	foldtext()		產生摺疊關閉時所顯示的行
	foldtextresult()	得到關閉摺疊顯示的文字

語法和高亮:	 		 *syntax-functions* *highlighting-functions*
	clearmatches()		清除 |matchadd()| 和 |:match| 諸命令定義的所有
				匹配
	getmatches()		得到 |matchadd()| 和 |:match| 諸命令定義的所有
				匹配
	hlexists()		檢查高亮組是否存在
	hlID()			取得高亮組標示
	synID()			取得某位置的語法標示
	synIDattr()		取得某語法標示的特定屬性
	synIDtrans()		取得翻譯後的語法標示
	synstack()		取得指定位置的語法標示的列表
	synconcealed()		取得和隱藏 (conceal) 相關的資訊
	diff_hlID()		得到 diff 模式某個位置的高亮標示
	matchadd()		定義要高亮的模式 (一個 "匹配")
	matchaddpos()		定義要高亮的位置列表
	matcharg()		得到 |:match| 引數的相關資訊
	matchdelete()		刪除 |matchadd()| 或 |:match| 諸命令定義的匹配
	setmatches()		恢復 |getmatches()| 儲存的匹配列表

拼寫:	 					*spell-functions*
	spellbadword()		定位游標所在或之後的錯誤拼寫的單詞
	spellsuggest()		返回建議的拼寫校正列表
	soundfold()		返回 "發音相似" 的單詞等價形式

歷史記錄:					*history-functions*
	histadd()		在歷史記錄中加入一項
	histdel()		從歷史記錄中刪除一項
	histget()		從歷史記錄中提取一項
	histnr()		取得某歷史記錄的最大索引號

互動:						*interactive-functions*
	browse()		顯示檔案查詢器
	browsedir()		顯示目錄查詢器
	confirm()		讓使用者作出選擇
	getchar()		從使用者那裡取得一個字元輸入
	getcharmod()		取得最近鍵入字元的修飾符
	feedkeys()		把字元放到預輸入佇列中
	input()			從使用者那裡取得一行輸入
	inputlist()		讓使用者從列表裡選擇一個專案
	inputsecret()		從使用者那裡取得一行輸入，不回顯
	inputdialog()		從使用者那裡取得一行輸入，使用對話方塊
	inputsave()		儲存和清除預輸入 (typeahead)
	inputrestore()		恢復預輸入 (譯註: 參閱 input())

GUI:						*gui-functions*
	getfontname()		得到當前使用的字型名
	getwinposx()		GUI Vim 視窗的 X 位置
	getwinposy()		GUI Vim 視窗的 Y 位置
	balloon_show()		設定氣泡的內容

Vim 伺服器:					*server-functions*
	serverlist()		返回伺服器列表
	remote_startserve()	啟動伺服器
	remote_send()		向 Vim 伺服器傳送字元命令
	remote_expr()		在 Vim 伺服器內對一個表示式求值
	server2client()		向一個伺服器客戶傳送應答
	remote_peek()		檢查一個伺服器是否已經應答
	remote_read()		從一個伺服器讀取應答
	foreground()		將一個 Vim 視窗移至前臺
	remote_foreground()	將一個 Vim 伺服器視窗移至前臺

視窗大小和位置:					*window-size-functions*
	winheight()		取得某視窗的高度
	winwidth()		取得某視窗的寬度
	winrestcmd()		恢復視窗大小的返回命令
	winsaveview()		得到當前視窗的檢視
	winrestview()		恢復儲存的當前視窗的檢視

對映:						*mapping-functions*
	hasmapto()		檢查對映是否存在
	mapcheck()		檢查匹配的對映是否存在
	maparg()		取得對映的右部 (rhs)
	wildmenumode()		檢查 wildmode 是否啟用

測試:					    *test-functions*
	assert_equal()		斷言兩個表示式的值相等
	assert_notequal()	斷言兩個表示式的值不等
	assert_inrange()	斷言表示式在範圍內
	assert_match()		斷言模式與值匹配
	assert_notmatch()	斷言模式不與值匹配
	assert_false()		斷言表示式為假
	assert_true()		斷言表示式為真
	assert_exception()	斷言命令丟擲例外
	assert_fails()		斷言函式呼叫失敗
	assert_report()		報告測試失敗
	test_alloc_fail()	使記憶體分配失敗
	test_autochdir()	啟動時開啟 'autochdir'
	test_override()		測試 Vim 內部的覆蓋
	test_garbagecollect_now()   立即清理記憶體
	test_ignore_error()	忽略指定的錯誤資訊
	test_null_channel()	返回 null 通道
	test_null_dict()	返回 null 字典
	test_null_job()		返回 null 作業
	test_null_list()	返回 null 列表
	test_null_partial()	返回 null 偏函式
	test_null_string()	返回 null 字串
	test_settime()		設定 Vim 內部使用的時間

程序間通訊:				    *channel-functions*
	ch_canread()		檢查是否有可讀的內容
	ch_open()		開啟通道
	ch_close()		關閉通道
	ch_close_in()		關閉通道的 in 部分
	ch_read()		從通道讀取資訊
	ch_readraw()		從通道讀取未處理的資訊
	ch_sendexpr()		從通道讀取 JSON 資訊
	ch_sendraw()		向通道傳送未處理的資訊
	ch_evalexpr()		通過通道計算表示式
	ch_evalraw()		通過通道計算未經處理的表示式
	ch_status()		獲取通道的狀態
	ch_getbufnr()		獲取通道的緩衝區號
	ch_getjob()		獲取通道相關的作業
	ch_info()		獲取通道資訊
	ch_log()		在通道日誌檔案寫下資訊
	ch_logfile()		設定通道日誌檔案
	ch_setoptions()		設定通道的選項
	json_encode()		把表示式編碼為 JSON 字串
	json_decode()		把 JSON 字串解碼為 Vim 型別
	js_encode()		把表示式編碼為 JSON 字串
	js_decode()		把 JSON 字串解碼為 Vim 型別

作業:		    			        *job-functions*
	job_start()		啟動作業
	job_stop()		停止作業
	job_status()		獲取作業狀態
	job_getchannel()	獲取作業使用的通道
	job_info()		獲取作業資訊
	job_setoptions()	設定作業選項

定時器:						*timer-functions*
	timer_start()		建立定時器
	timer_pause()		暫停或繼續定時器
	timer_stop()		停止定時器
	timer_stopall()		停止所有定時器
	timer_info()		獲取定時器資訊

雜項:						*various-functions*
	mode()			取得當前編輯狀態
	visualmode()		最近一次使用過的可視模式
	exists()		檢查變數，函式等是否存在
	has()			檢查 Vim 是否支援某特性
	changenr()		返回最近的改變號
	cscope_connection()	檢查有無與 cscope 的連線
	did_filetype()		檢查某檔案型別自動命令是否已經使用
	eventhandler()		檢查是否在一個事件處理程式內
	getpid()		得到 Vim 的程序號

	libcall()		呼叫一個外部庫函式
	libcallnr()		同上，但返回一個數值

	undofile()		得到撤銷檔名
	undotree()		返回撤銷樹的狀態

	getreg()		取得暫存器內容
	getregtype()		取得暫存器型別
	setreg()		設定暫存器內容及型別

	shiftwidth()		'shiftwidth' 的有效值

	wordcount()		獲取緩衝區的位元組/單詞/字元計數

	taglist()		得到匹配標籤的列表
	tagfiles()		得到標籤檔案的列表

	luaeval()		計算 Lua 表示式
	mzeval()		計算 |MzScheme| 表示式
	perleval()		計算 Perl 表示式 (|+perl|)
	py3eval()		計算 Python 表示式 (|+python3|)
	pyeval()		計算 Python 表示式 (|+python|)
	pyxeval()		計算 |python_x| 表示式

==============================================================================
*41.7*	定義一個函式

Vim 允許你定義自己的函式。基本的函式宣告如下: >

	:function {name}({var1}, {var2}, ...)
	:  {body}
	:endfunction
<
	注意:
	函式名必須以大寫字母開始。

讓我們來定義一個返回兩數中較小者的函式。從下面這一行開始: >

	:function Min(num1, num2)

這將告訴 Vim 這個函式名叫 "Min" 並且帶兩個引數: "num1" 和 "num2"。
   你要做的第一件事就是看看哪個數值小一些:
   >
	:  if a:num1 < a:num2

特殊字首 "a:" 告訴 Vim 該變數是一個函式引數。我們把最小的數值賦給 smaller 變
量: >

	:  if a:num1 < a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif

"smaller" 是一個區域性變數。一個在函式內部使用的變數，除非被加上類似 "g:"、
"a:" 或 "s:" 的字首，都是區域性變數。

	備註:
	為了從一個函式內部訪問一個全域性變數你必須在前面加上 "g:"。因此在一個函
	數內 "g:today" 表示全域性變數 "today"，而 "today" 是另外一個僅用於該函式
	內的區域性變數。

現在你可以使用 ":return" 語句來把最小的數值返回給呼叫者了。最後，你需要結束這
個函式: >

	:  return smaller
	:endfunction

下面是這個函式完整的定義: >

	:function Min(num1, num2)
	:  if a:num1 < a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
	:  return smaller
	:endfunction

如果你喜歡簡短的函式，下面是等價的形式: >

	:function Min(num1, num2)
	:  if a:num1 < a:num2
	:    return a:num1
	:  endif
	:  return a:num2
	:endfunction

呼叫使用者自定義函式的方式和呼叫內建函式完全一致。僅僅是函式名不同而已。上面的
Min 函式可以這樣來使用: >

	:echo Min(5, 8)

只有這時函式才被 Vim 解釋並執行。如果函式中有類似未定義的變數之類的錯誤，你將
得到一個錯誤資訊。這些錯誤在定義函式時是不會被檢測到的。

當一個函式執行到 ":endfunction" 或 ":return" 語句沒有帶引數時，該函式返回零。

如果要重定義一個已經存在的函式，在 "function" 命令後加上 !: >

	:function!  Min(num1, num2, num3)


範 圍 的 使 用

":call" 命令可以帶一個行表示的範圍。這可以分成兩種情況。當一個函式定義時給出了
"range" 關鍵字時，表示它會自行處理該範圍。
  Vim 在呼叫這樣一個函式時給它傳遞兩個引數: "a:firstline" 和 "a:lastline"，用
來表示該範圍所包括的第一行和最後一行。例如: >

	:function Count_words() range
	:  let lnum = a:firstline
	:  let n = 0
	:  while lnum <= a:lastline
	:    let n = n + len(split(getline(lnum)))
	:    let lnum = lnum + 1
	:  endwhile
	:  echo "found " . n . " words"
	:endfunction

你可以這樣呼叫上面的函式: >

	:10,30call Count_words()

這個函式將被呼叫一次並顯示字數。
   另一種使用範圍的方式是在定義函式時不給出 "range" 關鍵字。Vim 將把游標移動到
範圍內的每一行，並分別對該行呼叫此函式。例如: >

	:function  Number()
	:  echo "line " . line(".") . " contains: " . getline(".")
	:endfunction

如果你用下面的方式呼叫該函式: >

	:10,15call Number()

它將被執行六次。


可 變 參 數

Vim 允許你定義引數個數可變的函式。下面的例子給出一個至少有一個引數 (start)，但
可以多達 20 個附加引數的函式: >

	:function Show(start, ...)

變數 "a:1" 表示第一個可選的引數，"a:2" 表示第二個，如此類推。變數 "a:0" 表示
這些引數的個數。
   例如: >

	:function Show(start, ...)
	:  echohl Title
	:  echo "start is " . a:start
	:  echohl None
	:  let index = 1
	:  while index <= a:0
	:    echo "  Arg " . index . " is " . a:{index}
	:    let index = index + 1
	:  endwhile
	:  echo ""
	:endfunction

上例中 ":echohl" 命令被用來給出接下來的 ":echo" 命令如何高亮輸出。
":echohl None" 終止高亮。":echon" 命令除了不輸出換行符外，和 ":echo" 一樣。

你可以用 a:000 變數，它是所有 "..." 引數的列表。見 |a:000|。


函 數 清 單

":function" 命令列出所有使用者自定義的函式及其引數: >

	:function
<	function Show(start, ...) ~
	function GetVimIndent()~
	function SetSyn(name) ~

如果要檢視該函式具體做什麼，用該函式名作為 ":function" 命令的引數即可: >

	:function SetSyn
<	1     if &syntax == '' ~
	2       let &syntax = a:name ~
	3     endif ~
	   endfunction ~


調 試

除錯或者遇到錯誤資訊時，行號是很有用的。有關除錯模式請參閱 |debug-scripts|。
   你也可以通過將 'verbose' 選項設為 12 以上來察看所有函式呼叫。將該引數設為
15 或以上可以檢視所有被執行的行。


刪 除 函 數

為了刪除 Show() 函式: >

	:delfunction Show

如果該函式不存在，你會得到一個錯誤資訊。


函 數 引 用

有時使變數指向一個或另一個函式可能有用。要這麼做，用 function() 函式。它把函式
名轉換為引用: >

	:let result = 0		" 或 1
	:function! Right()
	:  return 'Right!'
	:endfunc
	:function! Wrong()
	:  return 'Wrong!'
	:endfunc
	:
	:if result == 1
	:  let Afunc = function('Right')
	:else
	:  let Afunc = function('Wrong')
	:endif
	:echo call(Afunc, [])
<	Wrong! ~

注意 儲存函式引用的變數名必須用大寫字母開頭，不然和內建函式的名字會引起混淆。
   呼叫變數指向的函式可以用 call() 函式。它的第一個引數是函式引用，第二個引數
是引數構成的列表。

和字典組合使用函式引用是最常用的，下一節解釋。

==============================================================================
*41.8*	列表和字典

到目前為止，我們用了基本型別字串和數值。Vim 也支援兩種複合型別: 列表和字典。

列表是事物的有序序列。這裡的事物包括各種型別的值。所以你可以建立數值列表、列表
列表甚至混合專案的列表。要建立包含三個字串的列表: >

	:let alist = ['aap', 'mies', 'noot']

列表專案用方括號包圍，逗號分割。要建立空列表: >

	:let alist = []

用 add() 函式可以為列表加入專案: >

	:let alist = []
	:call add(alist, 'foo')
	:call add(alist, 'bar')
	:echo alist
<	['foo', 'bar'] ~

列表的連線用 + 完成: >

	:echo alist + ['foo', 'bar']
<	['foo', 'bar', 'foo', 'bar'] ~

或者，你可以直接擴充套件一個列表: >

	:let alist = ['one']
	:call extend(alist, ['two', 'three'])
	:echo alist
<	['one', 'two', 'three'] ~

注意 這裡如果用 add()，效果不一樣: >

	:let alist = ['one']
	:call add(alist, ['two', 'three'])
	:echo alist
<	['one', ['two', 'three']] ~

add() 的第二個引數作為單個專案被加入。


FOR 循 環

使用列表的一個好處是可以在上面進行疊代: >

	:let alist = ['one', 'two', 'three']
	:for n in alist
	:  echo n
	:endfor
<	one ~
	two ~
	three ~

這段程式碼迴圈遍歷列表 "alist" 的每個專案，分別把它們的值賦給變數 "n"。for 迴圈
通用的形式是: >

	:for {varname} in {listexpression}
	:  {commands}
	:endfor

要迴圈若干次，你需要長度為給定次數的列表。range() 函式建立這樣的列表: >

	:for a in range(3)
	:  echo a
	:endfor
<	0 ~
	1 ~
	2 ~

注意 range() 產生的列表的第一個專案為零，而最後一個專案比列表的長度小一。
   你也可以指定最大值、步進，反向也可以: >

	:for a in range(8, 4, -2)
	:  echo a
	:endfor
<	8 ~
	6 ~
	4 ~

更有用的示例，迴圈遍歷緩衝區的所有行: >

	:for line in getline(1, 20)
	:  if line =~ "Date: "
	:    echo matchstr(line, 'Date: \zs.*')
	:  endif
	:endfor

察看行 1 到 20 (包含)，並回顯那裡找到的任何日期。


字 典

字典儲存鍵-值組對。如果知道鍵，你可以快速查詢值。字典用花括號形式建立: >

	:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}

現在你可以把鍵放在方括號裡以查詢單詞: >

	:echo uk2nl['two']
<	twee ~

字典定義的通用形式是: >

	{<key> : <value>, ...}

空字典是不包含任何鍵的字典: >

	{}

字典的用途很多。它可用的函式也不少。例如，你可以得到它的鍵列表並在其上迴圈: >

	:for key in keys(uk2nl)
	:  echo key
	:endfor
<	three ~
	one ~
	two ~

注意 這些鍵沒有排序。你自己可以對返回列表按照特定順序進行排序: >

	:for key in sort(keys(uk2nl))
	:  echo key
	:endfor
<	one ~
	three ~
	two ~

但你永遠不能得到專案定義時的順序。為此目的，只能用列表。列表裡的專案被作為有序
序列儲存。


字 典 函 數

字典專案通常可以用方括號裡的索引得到: >

	:echo uk2nl['one']
<	een ~

完成同樣操作且無需那麼多標點符號的方法: >

	:echo uk2nl.one
<	een ~

這隻能用於由 ASCII 字母、數位和下劃線組成的鍵。此方式也可以用於賦值: >

	:let uk2nl.four = 'vier'
	:echo uk2nl
<	{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} ~

現在來一些特別的: 你可以直接定義函式並把它的引用放在字典裡: >

	:function uk2nl.translate(line) dict
	:  return join(map(split(a:line), 'get(self, v:val, "???")'))
	:endfunction

讓我們先試試: >

	:echo uk2nl.translate('three two five one')
<	drie twee ??? een ~

你注意到的第一個特殊之處是 ":function" 一行最後的 "dict"。這標記該函式為某個字
典使用。"self" 區域性變數這時可以引用該字典。
   現在把這個複雜的 return 命令拆開: >

	split(a:line)

split() 函式接受字串，把它分成空白分隔的多個單詞，並返回這些單片語成的列表。
所以下例返回的是: >

	:echo split('three two five one')
<	['three', 'two', 'five', 'one'] ~

map() 函式的第一個引數是上面這個列表。它然後遍歷列表，用它的第二個引數來進行計
算，過程中 "v:val" 設為每個專案的值。這相當於 for 迴圈的快捷方式。命令: >

	:let alist = map(split(a:line), 'get(self, v:val, "???")')

等價於: >

	:let alist = split(a:line)
	:for idx in range(len(alist))
	:  let alist[idx] = get(self, alist[idx], "???")
	:endfor

get() 函式檢查某鍵是否在字典裡存在。如果是，提取它對應的鍵。如果不是，返回預設
值，此例中預設值是 '???'。此函式可以很方便地處理鍵不一定存在而你不想要錯誤資訊
的情形。

join() 函式和 split() 剛好相反: 它合併列表裡的單詞，中間放上空格。
  split()、map() 和 join() 的組合非常簡潔地對單片語成的行進行過濾。


面 向 對 象 編 程

現在你可以把值和函式都放進字典裡，實際上，字典已經可以作為物件來使用。
   上面我們用了一個字典來把荷蘭語翻譯為英語。我們可能也想為其他的語言作同樣的
事。讓我們先建立一個物件 (也就是字典)，它支援 translate 函式，但沒有要翻譯的單
詞表: >

	:let transdict = {}
	:function transdict.translate(line) dict
	:  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
	:endfunction

和上面的函式稍有不同，這裡用 'self.words' 來查詢單詞的翻譯，但我們還沒有
self.words。所以你可以把這叫做抽象類。

讓我們現在例項化一個荷蘭語的翻譯物件: >

	:let uk2nl = copy(transdict)
	:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
	:echo uk2nl.translate('three one')
<	drie een ~

然後來一個德語的翻譯器: >

	:let uk2de = copy(transdict)
	:let uk2de.words = {'one': 'eins', 'two': 'zwei', 'three': 'drei'}
	:echo uk2de.translate('three one')
<	drei eins ~

你看到 copy() 函式被用來建立 "transdict" 字典的備份，然後修改此備份以加入單詞
表。當然，原來的字典還是保持原樣。

現在你可以再進一步，使用你偏好的翻譯器: >

	:if $LANG =~ "de"
	:  let trans = uk2de
	:else
	:  let trans = uk2nl
	:endif
	:echo trans.translate('one two three')
<	een twee drie ~

這裡 "trans" 指向兩個物件 (字典) 之一，並不涉及到備份的建立。關於列表和字典同
一性的更多說明可見 |list-identity| 和 |dict-identity|。

你使用的語言現在可能還不支援。你可以覆蓋 translate() 函式，讓它什麼都不做: >

	:let uk2uk = copy(transdict)
	:function! uk2uk.translate(line)
	:  return a:line
	:endfunction
	:echo uk2uk.translate('three one wladiwostok')
<	three one wladiwostok ~

注意 使用 ! 會覆蓋已有的函式引用。現在，在沒找到能夠識別的語言的時候，讓我們用
"uk2uk": >

	:if $LANG =~ "de"
	:  let trans = uk2de
	:elseif $LANG =~ "nl"
	:  let trans = uk2nl
	:else
	:  let trans = uk2uk
	:endif
	:echo trans.translate('one two three')
<	one two three ~

進一步的閱讀可見 |Lists| 和 |Dictionaries|。

==============================================================================
*41.9*	例外

讓我們從一個例子開始: >

	:try
	:   read ~/templates/pascal.tmpl
	:catch /E484:/
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry

如果該檔案不存在的話，":read" 命令就會失敗。這段程式碼可以捕捉到該錯誤並向用戶
給出一個友好的資訊，而不是一個一般的出錯資訊。

在 ":try" 和 ":endtry" 之間的命令產生的錯誤將被轉變成為例外。例外以字串的形
式出現。當例外是錯誤時該字串就是出錯資訊。而每一個出錯資訊都有一個對應的錯誤
碼。在上面的例子中，我們捕捉到的錯誤包括 "E484"。Vim 確保這個錯誤碼始終不變
(文字可能會變，例如被翻譯)。

當 ":read" 命令引起其它錯誤時，模式 "E484:" 不會被匹配。因此該例外不會被捕獲，
結果是一個一般的出錯資訊。

你可能想這樣做: >

	:try
	:   read ~/templates/pascal.tmpl
	:catch
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry

這意味著所有的錯誤都將被捕獲。然而這樣你就無法得到那些有用的錯誤資訊，比如說
"E21: Cannot make changes, 'modifiable' is off"。

另一個有用的機制是 ":finally" 命令: >

	:let tmp = tempname()
	:try
	:   exe ".,$write " . tmp
	:   exe "!filter " . tmp
	:   .,$delete
	:   exe "$read " . tmp
	:finally
	:   call delete(tmp)
	:endtry

這個例子將自游標處到檔案尾的所有行通過過濾器 "filter"。該程式的引數是檔名。
無論在 ":try" 和 ":finally" 之間發生了什麼，"call delete(tmp)" 命令始終被執
行。這可以確保你不會留下一個臨時檔案。

關於例外處理更多的討論可以閱讀參考手冊: |exception-handling|。

==============================================================================
*41.10*	其它的討論

這裡集中了一些和 Vim 指令碼相關的討論。別的地方其實也提到過，這裡算做一個整理。

行結束符取決於所在的系統。Unix 系統使用單個的 <NL> 字元。MS-DOS、Windows、OS/2
系列的系統使用 <CR><LF>。對於那些使用 <CR> 的對映而言，這一點很重要。參閱
|:source_crnl|。


空 白 字 符

可以使用空白行，但沒有作用。

行首的空白字元 (空格和製表符) 總被忽略。引數間的 (例如象下面命令中 "set" 和
"cpoptions" 之間的) 空白字元被歸約為單個，僅用作分隔符。而最後一個 (可見) 字元
之後的空白字元可能會被忽略也可能不會，視情況而定。見下。

對於一個帶有等號 "=" 的 ":set" 命令，如下: >

	:set cpoptions    =aABceFst

緊接著等號之前的空白字元會被忽略。然而其後的空白字元是不允許的！

為了在一個選項值內使用空格，必須像下面例子那樣使用反斜槓: >

	:set tags=my\ nice\ file

如果寫成這樣: >

	:set tags=my nice file

Vim 會給出錯誤資訊，因為它被解釋成: >

	:set tags=my
	:set nice
	:set file


注 釋

雙引號字元 " 標記註釋的開始。除了那些不接受註釋的命令外 (見下例)，從雙引號起的
直到行末的所有字元都將被忽略。註釋可以從一行的任意位置開始。

對於某些命令來說，這裡有一個小小的 "陷阱"。例如: >

	:abbrev dev development		" shorthand
	:map <F3> o#include		" insert include
	:execute cmd			" do it
	:!ls *.c			" list C files

縮寫 'dev' 會被展開成 'development     " shorthand'；<F3> 的鍵盤對映會是包括
'" insert include' 在內的那一整行；"execute" 命令會給出錯誤；"!" 命令會將其後
的所有字元傳給 shell，從而引起一個不匹配 '"' 的錯誤。
   結論是，":map"，":abbreviate"，":execute" 和 "!" 命令之後不能有註釋。(另外
還有幾個命令也是如此)。不過，對於這些命令有一個小竅門: >

	:abbrev dev development|" shorthand
	:map <F3> o#include|" insert include
	:execute cmd			|" do it

'|' 字元被用來將兩個命令分隔開。後一個命令僅僅是一個註釋。最後一個命令裡，你需
要做兩件事: |:execute| 和用 '|': >
	:exe '!ls *.c'			|" list C files

注意 在縮寫和對映後的 '|' 之前沒有空格。這是因為對於這些命令，直到行尾或者 '|'
字元為止的內容都是有效的。此行為的後果之一，是你沒法總看到這些命令後面包括的空
白字元: >

	:map <F4> o#include  

要發現這個問題，你可以在你的 vimrc 檔案內建位 'list' 選項。

Unix 上有一個特殊的辦法給一行加註釋，從而使得 Vim 指令碼可執行: >
	#!/usr/bin/env vim -S
	echo "this is a Vim script"
	quit

"#" 命令本身列出一行並帶行號。加上感嘆號後使得它什麼也不做。從而，你可以在後面
加上 shell 命令來執行其餘的檔案。 |:#!| |-S|


陷 阱

下面的例子的問題就更大了: >

	:map ,ab o#include
	:unmap ,ab 

這裡，unmap 命令是行不通的，因為它試著 unmap ",ab "。而這個對映根本就不存在。
因為 'unmap ,ab ' 的末尾的那個空白字元是不可見的，這個錯誤很難被找出。

在下面這個類似的例子裡，'unmap' 後面帶有註釋: >

	:unmap ,ab     " comment

註釋將被忽略。然而，Vim 會嘗試 unmap 不存在的 ',ab     '。可以重寫成: >

	:unmap ,ab|" comment


恢 復 一 個 視 窗 位 置

有時有你想做一些改動然後回到游標原來的位置。如果能恢復相對位置，把和改動前同樣
的行置於視窗頂端就更好了。
   這裡的例子拷貝當前行，貼上到檔案的第一行，然後恢復視窗位置: >

	map ,p ma"aYHmbgg"aP`bzt`a

解析: >
	ma"aYHmbgg"aP`bzt`a
<	ma			在當前位置做標記 a
	  "aY			將當前行拷貝至暫存器 a
	     Hmb		移動到視窗的頂行並做標記 b
		gg		移動到檔案首行
		  "aP		貼上拷貝的行到上方
		     `b		移動到剛才的頂行
		       zt	使窗口出現的文字恢復舊觀
			 `a	回到儲存的游標位置


封 裝

為了避免你的函式名同其它的函式名發生衝突，使用這樣的方法:
- 在函式名前加上獨特的字串。我通常使用一個縮寫。例如，"OW_" 被用在 option
  window 函式上。
- 將你的函式定義放在一個檔案內。設定一個全域性變數用來表示這些函式是否已經被載入
  了。當再次 source 這個檔案的時候，先將這些函式解除安裝。
例如: >

	" This is the XXX package

	if exists("XXX_loaded")
	  delfun XXX_one
	  delfun XXX_two
	endif

	function XXX_one(a)
		... body of function ...
	endfun

	function XXX_two(b)
		... body of function ...
	endfun

	let XXX_loaded = 1

==============================================================================
*41.11*	編寫外掛				*write-plugin*

用約定方式編寫的指令碼能夠被除作者外的很多人使用。這樣的指令碼叫做外掛。Vim 使用者只
要把你寫的指令碼放在 plugin 目錄下就可以立即使用了: |add-plugin|。

實際上有兩種外掛:

    全域性外掛: 適用於所有型別的檔案。
檔案型別外掛: 僅適用於某種型別的檔案。

這一節將介紹第一種。很多的東西也同樣適用於編寫檔案型別外掛。僅適用於編寫檔案類
型外掛的知識將在下一節 |write-filetype-plugin| 做介紹。


插 件 名

首先你得給你的外掛起個名字。這個名字應該很清楚地表示該外掛的用途。同時應該避免
同別的外掛用同樣的名字而用途不同。請將外掛名限制在 8 個字元以內，這樣可以使得
該外掛在老的 Windows 系統也能使用。

一個糾正打字錯誤的外掛可能被命名為 "typecorr.vim"。我們將用這個名字來舉例。

為了使一個外掛能被所有人使用，要注意一些事項。下面我們將一步步的講解。最後會給
出這個外掛的完整示例。


插 件 體

讓我們從做實際工作的外掛體開始: >

 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4

當然，真正的清單會比這長的多。

上面的行號只是為了方便解釋，不要把它們也加入到你的外掛檔案中去！


插 件 頭

你很可能對這個外掛做新的修改並很快就有了好幾個版本。並且當你釋出檔案的時候，別
人也想知道是誰編寫了這樣好的外掛或者給作者提點意見。所以，在你的外掛頭部加上一
些描述性的註釋是很必要的: >

  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change: 2000 Oct 15
  3	" Maintainer: Bram Moolenaar <Bram@vim.org>

關於版權和許可: 由於外掛很有用，而且幾乎不值得限制其發行，請考慮對你的外掛使用
公共領域 (public domain) 或 Vim 許可 |license|。在檔案頂部放上說明就行了。例
如: >

  4	" License:	This file is placed in the public domain.


續 行，避 免 副 效 應					*use-cpo-save*

在上面的第 18 行中，用到了續行機制 |line-continuation|。那些置位了
'compatible' 選項的使用者可能會在這裡遇到麻煩。他們會得到一個錯誤資訊。我們不能
簡單的復位 'compatible' 選項，因為那樣會帶來很多的副效應。為了避免這些副效應，
我們可以將 'cpoptions' 選項設為 Vim 預設值並在後面恢復之。這將允許續行功能並保
證對大多數使用者來講指令碼是可用的。就像下面這樣: >

 11	let s:save_cpo = &cpo
 12	set cpo&vim
 ..
 42	let &cpo = s:save_cpo
 43	unlet s:save_cpo

我們先將 'cpoptions' 的舊值存在 s:save_cpo 變數中。在外掛的最後該值將被恢復。

注意 上面使用了指令碼區域性變數 |s:var|。因為可能已經使用了同名的全域性變數。對於僅
在指令碼內用到的變數總應該使用指令碼區域性變數。


禁 止 加 載

有可能一個使用者並不總希望載入這個外掛。或者系統管理員在系統的外掛目錄中已經把這
個外掛刪除了，而使用者希望使用它自己安裝的外掛。使用者應該有機會選擇不載入指定的插
件。下面的一段程式碼就是用來實現這個目的的: >

  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1

這同時也避免了同一個指令碼被載入兩次以上。因為那樣使用者會得到各種各樣的錯誤資訊。
比如函式被重新定義，自動命令被多次加入等等。

建議使用的名字以 "loaded_" 開頭，然後是外掛的檔名，按原義輸入。之前加上 "g:"
以免錯誤地在函式中使用該變數 (沒有 "g:" 可以是區域性於函式的變數)。

"finish" 阻止 Vim 繼續讀入檔案的其餘部分，這比用 if-endif 包圍整個檔案要快得
多。

映 射

現在讓我們把這個外掛變得更有趣些: 我們將加入一個對映用來校正當前游標下的單詞。
我們當然可以任意選一個鍵組合，但是使用者可能已經將其定義為其它的什麼功能了。為了
使使用者能夠自己定義在外掛中的鍵盤對映使用的鍵，我們可以使用 <Leader> 標識: >

 22	  map <unique> <Leader>a  <Plug>TypecorrAdd

那個 "<Plug>TypecorrAdd" 會做實際的工作，後面我們還會做更多解釋。

使用者可以將 "mapleader" 變數設為他所希望的開始對映的鍵組合。比如假設使用者這樣
做: >

	let mapleader = "_"

對映將定義為 "_a"。如果使用者沒有這樣做，Vim 將使用預設值反斜槓。這樣就會定義一
個對映 - "\a"。

注意 其中用到了 <unique>，這會使得 Vim 在對映已經存在時給出錯誤資訊。
|:map-<unique>|

但是如果使用者希望定義自己的鍵操作呢？我們可以用下面的方法來解決: >

 21	if !hasmapto('<Plug>TypecorrAdd')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd
 23	endif

我們先檢查對 "<Plug>TypecorrAdd" 的對映是否存在。僅當不存在時我們才定義對映
"<Leader>a"。這樣使用者就可以在他自己的 vimrc 檔案中加入: >

	map ,c  <Plug>TypecorrAdd

那麼鍵序列就會是 ",c" 而不是 "_a" 或者 "\a" 了。


分 割

如果一個指令碼變得相當長，你通常希望將其分割成幾部分。常見做法是函式或對映。但同
時，你又不希望指令碼之間這些函式或對映相互干擾。例如，你定義了一個函式 Add()，但
另一個指令碼可能也試圖定一同名的函式。為了避免這樣的情況發生，我們可以在區域性函式
的前面加上 "s:"。

我們來定義一個用來新增新的錯誤更正的函式: >

 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 ..
 36	endfunction

這樣我們就可以在這個指令碼之內呼叫函式 s:Add()。如果另一個指令碼也定義 s:Add()，該
函式將只能在其所定義的指令碼內部被呼叫。獨立於這兩個函式的全域性的 Add() 函式 (不
帶 "s:") 也可以存在。

對映則可用 <SID>。它產生一個指令碼 ID。在我們的錯誤更正外掛中我們可以做以下的定
義: >

 24	noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 ..
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>

這樣當用戶鍵入 "\a" 時，將觸發下面的次序: >

	\a  ->  <Plug>TypecorrAdd  ->  <SID>Add  ->  :call <SID>Add()

如果另一個指令碼也定義了對映 <SID>Add，該指令碼將產生另一個指令碼 ID。所以它定義的映
射也與前面定義的不同。

注意 在這裡我們用了 <SID>Add() 而不是 s:Add()。這是因為該對映將被使用者鍵入，因
此是從指令碼外部呼叫的。<SID> 被翻譯成該指令碼的 ID。這樣 Vim 就知道在哪個腳本里尋
找相應的 Add() 函數了。

這的確是有點複雜，但又是使多個外掛一起工作所必需的。基本規則是: 在對映中使用
<SID>Add()；在其它地方 (該指令碼內部，自動命令，使用者命令) 使用 s:Add()。

我們還可以增加選單專案來完成對映同樣的功能: >

 26	noremenu <script> Plugin.Add\ Correction      <SID>Add

建議把外掛定義的選單項都加入到 "Plugin" 選單下。上面的情況只定義了一個選單選
項。當有多個選項時，可以建立一個子選單。例如，一個提供 CVS 操作的外掛可以新增
"Plugin.CVS" 子選單，並在其中定義 "Plugin.CVS.checkin"，"Plugin.CVS.checkout"
等選單項。

注意 為了避免其它對映引起麻煩，在第 28 行使用了 ":noremap"。比如有人可能重新映
射了 ":call"。在第 24 也用到了 ":noremap"，但我們又希望重新對映 "<SID>Add"。這
就是為什麼在這兒要用 "<script>"。它允許只執行區域性於指令碼的對映。
|:map-<script>| 同樣的道理也適用於第 26 行的 ":noremenu"。|:menu-<script>|


<SID> 和 <Plug>						*using-<Plug>*

<SID> 和 <Plug> 都是用來避免對映的鍵序列和那些僅僅用於其它對映的對映起衝突。
注意 <SID> 和 <Plug> 的區別:

<Plug>	在指令碼外部是可見的。它被用來定義那些使用者可能定義對映的對映。<Plug> 是
	無法用鍵盤輸入的特殊程式碼。
	使用結構: <Plug> 指令碼名 對映名，可以使得其它外掛使用同樣次序的字元來定
	義對映的機率變得非常小。在我們上面的例子中，指令碼名是 "Typecorr"，對映
	名是 "Add"。結果是 "<Plug>TypecorrAdd"。只有指令碼名和對映名的第一個字
	符是大寫的，所以我們可以清楚地看到對映名從什麼地方開始。

<SID>	是指令碼的 ID，用來唯一的代表一個指令碼。Vim 在內部將 <SID> 翻譯為
	"<SNR>123_"，其中 "123" 可以是任何數字。這樣一個函式 "<SID>Add()" 可能
	在一個指令碼中被命名為 "<SNR>11_Add()"，而在另一個指令碼中被命名為
	"<SNR>22_Add()"。如果你用 ":function" 命令來獲得系統中的函式列表你就可
	以看到了。對映中對 <SID> 的翻譯是完全一樣的。這樣你才有可能通過一個映
	射來呼叫某個指令碼中的區域性函式。


用 戶 命 令

現在讓我們來定義一個用來新增更正的使用者命令: >

 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40	endif

這個使用者命令只在系統中沒有同樣名稱的命令時才被定義。否則我們會得到一個錯誤。用
":command!" 來覆蓋現存的使用者命令是個壞主意。這很可能使使用者不明白自己定義的命令
為什麼不起作用。|:command|


腳 本 變 量

當一個變數前面帶有 "s:" 時，我們將它稱為指令碼變數。該變數只能在指令碼內部被使用。
在指令碼以外該變數是不可見的。這樣就避免了在不同的指令碼中使用同一個變數名的麻煩。
該變數在 Vim 的執行期間都是可用的。當再次呼叫 (source) 該指令碼時使用的是同一個
變數。|s:var|

有趣的是這些變數也可以在指令碼定義的函式、自動命令和使用者命令中使用。在我們的例子
中我們可以加入幾行用來統計更正的個數: >

 19	let s:count = 4
 ..
 30	function s:Add(from, correct)
 ..
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction

起初 s:count 被指令碼初始化為 4。當後來 s:Add() 函式被呼叫時，其值被增加了。在哪
裡呼叫函式無關緊要。只要它是定義在該指令碼以內的，就可以使用指令碼中的區域性變數。


結 果

下面就是完整的例子: >

  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change: 2000 Oct 15
  3	" Maintainer: Bram Moolenaar <Bram@vim.org>
  4	" License:	This file is placed in the public domain.
  5
  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1
 10
 11	let s:save_cpo = &cpo
 12	set cpo&vim
 13
 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4
 20
 21	if !hasmapto('<Plug>TypecorrAdd')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd
 23	endif
 24	noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 25
 26	noremenu <script> Plugin.Add\ Correction      <SID>Add
 27
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
 29
 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 33	  if a:correct | exe "normal viws\<C-R>\" \b\e" | endif
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction
 37
 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40	endif
 41
 42	let &cpo = s:save_cpo
 43	unlet s:save_cpo

第 33 行還沒有解釋過。它將新定義的更正用在當前游標下的單詞上。|:normal| 被用來
使用新的縮寫。注意 雖然這個函式是被一個以 ":noremap" 定義的對映呼叫的，這裡的
對映和縮寫還是被展開使用了。

推薦對 'fileformat' 選項使用 "unix" 值。這樣的 Vim 指令碼就可以在所有系統內使
用。對 'fileformat' 選項使用 "dos" 的指令碼無法正常的在 Unix 上使用。參見
|:source_crnl|。為確保該值被正確設定，在寫入檔案前執行下面的命令: >

	:set fileformat=unix


文 檔						 *write-local-help*

給你的外掛寫一些文件是個好主意。特別是當用戶可以自定義其中的某些功能時尤為必
要。關於如何安裝文件，請查閱 |add-local-help|。

下面是一個外掛幫助文件的簡單例子，名叫 "typecorr.txt": >

  1	*typecorr.txt*	Plugin for correcting typing mistakes
  2
  3	If you make typing mistakes, this plugin will have them corrected
  4	automatically.
  5
  6	There are currently only a few corrections.  Add your own if you like.
  7
  8	Mappings:
  9	<Leader>a   or   <Plug>TypecorrAdd
 10		Add a correction for the word under the cursor.
 11
 12	Commands:
 13	:Correct {word}
 14		Add a correction for {word}.
 15
 16							*typecorr-settings*
 17	This plugin doesn't have any settings.

其實只有第一行是文件的格式所必需的。Vim 將從該幫助檔案中提取該行並加入到
help.txt 的 "LOCAL ADDITIONS:" |local-additions| (本地附加文件) 一節中。第一個
"*" 一定要在第一行的第一列。加入你的幫助檔案之後用 ":help" 來檢查一下各項是否
很好的對齊了。

你可以為你的幫助文件在 ** 之間加入更多的標籤。但請注意不要使用現存的幫助標籤。
你最好能在標籤內使用外掛名用以區別，比如上例中的 "typecorr-settings"。

建議使用 || 來引用幫助系統中的其它部分。這可以使使用者很容易得找到相關聯的幫助。


文 件 類 型 檢 測					*plugin-filetype*

如果 Vim 還不能檢測到你的檔案型別，你需要在單獨的檔案裡創立一個檔案型別檢測的
程式碼段。通常，它的形式是一個自動命令，它在檔名字匹配某模式時設定檔案型別。例
如: >

	au BufNewFile,BufRead *.foo			set filetype=foofoo

把這個一行的檔案寫到 'runtimepath' 裡第一個目錄下的 "ftdetect/foofoo.vim"。
Unix 上應該是 "~/.vim/ftdetect/foofoo.vim"。慣例是，使用檔案型別的名字作為指令碼
的名字。

如果你願意，你可以使用更復雜的檢查。比如檢查檔案的內容以確定使用的語言。另見
|new-filetype|。


小 結							*plugin-special*

關於外掛的小結:

s:name			指令碼的區域性變數。

<SID>			指令碼 ID，用於區域性於指令碼的對映和函式。

hasmapto()		用來檢測外掛定義的對映是否已經存在的函式。

<Leader>		"mapleader" 的值。使用者可以通過該變數定義外掛所定義對映
			的起始字元。

:map <unique>		如果一個對映已經存在的話，給出警告資訊。

:noremap <script>	在對映右邊僅執行指令碼的區域性對映，而不檢查全域性對映。

exists(":Cmd")		檢查一個使用者命令是否存在。

==============================================================================
*41.12*	編寫檔案型別外掛	*write-filetype-plugin* *ftplugin*

檔案型別外掛和全域性外掛其實很相似。但是它的選項設定和對映等僅對當前緩衝區有效。
這類外掛的用法請參閱 |add-filetype-plugin|。

請先閱讀上面 |41.11| 關於全域性外掛的敘述。其中所講的對檔案型別外掛也都適用。這
裡只講述一些不同之處。最根本的區別是檔案型別外掛只應該對當前緩衝區生效。


禁 用

如果你在編寫一個提供很多人使用的檔案型別外掛，這些使用者應該有機會選擇不載入該插
件。你應該在外掛的頂端加上: >

	" Only do this when not done yet for this buffer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1

這同時也避免了同一外掛在同一緩衝區內被多次執行的錯誤 (當使用不帶引數的 ":edit"
命令時就會發生)。

現在使用者只要編寫一個如下的一行的檔案型別外掛就可以完全避免載入預設的檔案型別插
件了: >

	let b:did_ftplugin = 1

當然這要求該檔案型別外掛所處的檔案型別外掛目錄在 'runtimepath' 所處的位置在
$VIMRUNTIME 之前！

如果你的確希望使用預設的外掛，但是又想自行支配其中的某一選項，你可以用一個類似
下例的外掛: >

	set textwidth=70

現在將這個檔案存入那個 "after" 目錄中。這樣它就會在呼叫 Vim 本身的 "vim.vim"
檔案型別外掛之後被呼叫 |after-directory|。對於 Unix 系統而言，該目錄會是
"~/.vim/after/ftplugin/vim.vim"。注意 預設的外掛設定了 "b:did_ftplugin"，但在
此指令碼應該忽略之。


選 項

為了確保檔案型別外掛僅僅影響當前緩衝區，應該使用 >

	:setlocal

命令來設定選項。還要注意只設定緩衝區的區域性選項 (查查有關選項的幫助)。當
|:setlocal| 被用於設定全域性選項或者某視窗的區域性選項時，會影響到多個緩衝區，這是
檔案型別外掛應該避免的。

當一個選項的值是多個標誌位或專案的 "合" 時，考慮使用 "+=" 和 "-="，這樣可以保
留現有的值。注意 使用者可能已經改變了該選項的值了。通常先將選項的值復位成預設值
再做改動是個好主意。例: >

	:setlocal formatoptions& formatoptions+=ro


映 射

為了確保鍵盤對映只對當前緩衝區生效，應該使用 >

	:map <buffer>

命令。這還應該和上面講述的兩步對映法連起來使用。下面是一個例子: >

	if !hasmapto('<Plug>JavaImport')
	  map <buffer> <unique> <LocalLeader>i <Plug>JavaImport
	endif
	noremap <buffer> <unique> <Plug>JavaImport oimport ""<Left><Esc>

|hasmapto()| 被用來檢查使用者是否已經定義了一個對 <Plug>JavaImport 的對映。如果
沒有，該檔案型別外掛就定義預設的對映。因為預設對映是以 |<LocalLeader>| 開始，
就使得使用者可以自己定義對映的起始字元。預設的是反斜槓。
"<unique>" 的用途是當已經存在的了這樣的對映或者和已經存在的對映有重疊的時候給
出錯誤資訊。
|:noremap| 被用來防止其他使用者定義的映射干擾。不過，":noremap <script>" 仍然可
以允許進行指令碼中以 <SID> 開頭的對映。

一定要給使用者保留禁止一個檔案型別外掛內的對映而不影響其它功能的能力。下面通過
一個郵件檔案型別外掛來演示如何做到這一點: >

	" 增加對映，除非使用者反對。
	if !exists("no_plugin_maps") && !exists("no_mail_maps")
	  " Quote text by inserting "> "
	  if !hasmapto('<Plug>MailQuote')
	    vmap <buffer> <LocalLeader>q <Plug>MailQuote
	    nmap <buffer> <LocalLeader>q <Plug>MailQuote
	  endif
	  vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>
	  nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>
	endif

其中用到了兩個全域性變數:
|no_plugin_maps|	禁止所有檔案型別外掛中的對映
|no_mail_maps|		禁止 "mail" 檔案型別外掛的對映


用 戶 命 令

在使用 |:command| 命令時，如果加上 "-buffer" 開關，就可以為某一型別的檔案加入
一個使用者命令，而該命令又只能用於一個緩衝區。例: >

	:command -buffer  Make  make %:r.s


變 量

檔案型別外掛對每一個該型別的檔案都會被呼叫。指令碼區域性變數 |s:var| 會被所有的調
用共享。如果你想定義一個僅對某個緩衝區生效的變數，使用緩衝區區域性變數 |b:var|。


函 數

一個函式只需要定義一次就行了。可是檔案型別外掛會在每次開啟相應型別的檔案時都被
呼叫。下面的結構可以確保函式只被定義一次: >

	:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...
	:  endfunction
	:endif
<

撤 銷						*undo_indent* *undo_ftplugin*

當用戶執行 ":setfiletype xyz" 時，之前的檔案型別命令應該被撤銷。在你的檔案型別
外掛中設定 b:undo_ftplugin 變數，用來撤銷該外掛的各種設定。例如: >

	let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
		\ . "| unlet b:match_ignorecase b:match_words b:match_skip"

在 ":setlocal" 命令的選項後使用 "<" 會將其值復位為全域性值。這可能是最好的復位
選項值的方法。

但這也需要把 "C" 標誌位從 'cpoptions' 選項中去除，就像上面 |use-cpo-save| 提到
的那樣。

要撤銷縮排指令碼的效果，必須相應地設定 b:undo_indent 變數。


文 件 名

檔案型別必須被包括在外掛檔名中 |ftplugin-name|。可以使用以下三種形式之一:

	.../ftplugin/stuff.vim
	.../ftplugin/stuff_foo.vim
	.../ftplugin/stuff/bar.vim

"stuff" 是檔案型別，"foo" 和 "bar" 是任意名字。


小 結						*ftplugin-special*

以下是有關檔案型別外掛一些特殊環節:

<LocalLeader>		"maplocalleader" 的值，使用者可以通過它來自定義檔案型別
			外掛中對映的起始字元。

:map <buffer>		定義一個僅對緩衝區有效的區域性對映。

:noremap <script>	僅重對映指令碼中以 <SID> 開始的對映。

:setlocal		設定僅對當前緩衝區有效的選項。

:command -buffer	定義一個僅對緩衝區有效的區域性命令。

exists("*s:Func")	檢視是否已經定義了某個函式。

參閱所有外掛的特殊環節 |plugin-special|。

==============================================================================
*41.13*	編寫編譯器外掛				*write-compiler-plugin*

編譯器外掛可以用來設定於某一特定編譯器相關的選項。使用者可以使用 |:compiler| 命
令來載入之。主要是用以設定 'errorformat' 及 'makeprg' 選項。

最簡單的方法就是學習一個例子。下面的命令將編輯所有預設安裝的編譯器外掛: >

	:next $VIMRUNTIME/compiler/*.vim

用 |:next| 可以查閱下一個外掛檔案。

這類檔案有兩個特別之處。一是允許使用者否決或者增強預設檔案的機制。預設的檔案以下
面的程式碼開始: >

	:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"

當你寫了編譯器檔案並把它放到你個人的執行時目錄 (例如，Unix 上 ~/.vim/compiler)
時，你需要設定 "current_compiler" 變數，使得預設檔案不進行設定。
							*:CompilerSet*
第二個特別之處是: 用 ":set" 命令來配合 ":compiler!" 而用 ":setlocal" 來配合
":compiler"。Vim 為此定義了 ":CompilerSet" 使用者命令。然而舊版本的 Vim 沒有，因
此你的外掛應該提供該命令。下面是一個例子: >

  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal <args>
  endif
  CompilerSet errorformat&		" use the default 'errorformat'
  CompilerSet makeprg=nmake

當你為 Vim 釋出版本或者整個系統編寫編譯器外掛時，應該使用上面提到的機制。這樣
當用戶外掛已經定義了 "current_compiler" 的時候什麼也不做。

當你為了自行定義預設外掛的一些設定而編寫編譯器外掛時，不要檢查
"current_compiler"。這個外掛應該在最後載入，因此其所在目錄應該在 'runtimepath'
的最後。對於 Unix 來說可能是 ~/.vim/after/compiler。

==============================================================================
*41.14*	編寫快速載入的外掛			*write-plugin-quickload*

外掛會不斷變大而使程式碼越來越長。啟動時的延遲因而會非常顯著，而你可能幾乎不用這
個外掛。這時，就是時候讓我們來編寫可以快速載入的外掛了。

基本的方法是呼叫外掛兩次。第一次定義使用者命令和對映，提供需要的功能。第二次定義
實現這些功能的函式。

聽起來很嚇人，快速載入意味著載入兩次！我們的意思是，第一次載入很快，把指令碼的大
部分內容延遲到第二次才載入，只有實際使用這些功能時才會這麼做。當然，如果你總是
用這些功能，實際上更慢了！

注意 從 Vim 7 開始，有一個替代方法: 使用 |autoload| 功能 |41.15|。

下例演示如何這是如何完成的: >

	" 演示快速載入的 Vim 全域性外掛
	" Last Change:	2005 Feb 25
	" Maintainer:	Bram Moolenaar <Bram@vim.org>
	" License:	This file is placed in the public domain.

	if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(<f-args>)
		map <F19> :call BufNetWrite('something')<CR>

		let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' . expand('<sfile>')
		finish
	endif

	function BufNetRead(...)
		echo 'BufNetRead(' . string(a:000) . ')'
		" 讀入功能在此
	endfunction

	function BufNetWrite(...)
		echo 'BufNetWrite(' . string(a:000) . ')'
		" 寫回功能在此
	endfunction

第一次載入指令碼時，沒有設定 "s:did_load"。這時執行 "if" 和 "endif" 之間的命令。
它以 |:finish| 命令結束，這樣指令碼的其餘部分不再執行。

第二次載入指令碼時，"s:did_load" 已經存在，這時執行 "endif" 之後的命令。這裡定義
(可能很長的) BufNetRead() 和 BufNetWrite() 函式。

如果把該指令碼放到你的 plugin 目錄，Vim 啟動時會執行它。下面列出發生事件的序列:

1. 啟動期間執行指令碼時，定義 "BNRead" 命令並對映 <F19> 鍵。定義 |FuncUndefined|
   自動命令。":finish" 命令使指令碼提前終止。

2. 使用者輸入 BNRead 命令或者按了 <F19> 鍵。BufNetRead() 或 BufNetWrite() 函式會
   被呼叫。

3. Vim 找不到這些函式並因此激活了 |FuncUndefined| 自動命令事件。因為模式
   "BufNet*" 匹配要呼叫的函式，執行命令 "source fname"，其中 "fname" 被賦予腳
   本的名字，不管它實際在何處都沒問題。這是因為該名字來自 "<sfile>" 擴充套件的結果
   (見 |expand()|)。

4. 再次執行指令碼。"s:did_load" 變數已經存在，此時定義函式。

注意後來載入的函式匹配 |FuncUndefined| 自動命令的模式。要確信其它外掛沒有定義
匹配此模式的函式。

==============================================================================
*41.15*	編寫庫指令碼				*write-library-script*

有些功能會在多個地方呼叫。如果這已經不是一兩行的程式碼，你可能會希望把這些程式碼放
進指令碼，然後被許多其它指令碼使用。我們把這種指令碼稱為庫指令碼。

可以手動載入庫指令碼，只要你不要重複呼叫它就行了。用 |exists()| 函式可以判斷。
例如: >

	if !exists('*MyLibFunction')
	   runtime library/mylibscript.vim
	endif
	call MyLibFunction(arg)

這裡你需要知道 MyLibFunction() 在指令碼 "library/mylibscript.vim" 裡定義，該指令碼
在 'runtimepath' 的某個目錄裡。

為了稍稍簡化，Vim 提供了自動載入機制。現在，本例看起來像: >

	call mylib#myfunction(arg)

簡單多了，是不是？Vim 會識別函式名，如果該函式還沒有定義，查詢 'runtimepath'
裡的 "autoload/mylib.vim"。該指令碼必須定義 "mylib#myfunction()" 函式。

在 mylib.vim 腳本里可以放上許多其它函式，你可以自由組織庫指令碼的函式。但必須使
函式名 "#" 前面的部分匹配指令碼名。否則 Vim 無法知道載入哪個指令碼。

如果你真的熱情高漲寫了很多庫指令碼，現在可能想要用子目錄吧。例如: >

	call netlib#ftp#read('somefile')

Unix 上，這裡使用的庫指令碼可以是:

	~/.vim/autoload/netlib/ftp.vim

其中的函式應該如此定義: >

	function netlib#ftp#read(fname)
		"  用 ftp 讀入檔案 fname
	endfunction

注意定義所用的函式名必須和呼叫的函式名完全相同。最後一個 '#' 之前的部分必須準
確匹配子目錄和指令碼名。

同樣的機制可以用來定義變數: >

	let weekdays = dutch#weekdays

會載入指令碼 "autoload/dutch.vim"，它應該包含這樣的內容: >

	let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
		\ 'donderdag', 'vrijdag', 'zaterdag']

進一步的閱讀可見: |autoload|。

==============================================================================
*41.16*	釋出 Vim 指令碼					*distribute-script*

Vim 使用者可以在 Vim 網站上尋找指令碼: http://www.vim.org。如果你實現了對別人也有
用的功能，讓大家一起分享！

Vim 指令碼應該可以用於任何系統。它們不一定有 tar 或 gzip 命令。如果你想把檔案打
包和/或進行壓縮，建議使用 "zip" 工具。

最理想的可移植方法是讓 Vim 自己給指令碼打包，用 Vimball 工具。見 |vimball|。

最好你能加入一行內容，實現自動更新。見 |glvs-plugins|。

==============================================================================

下一章: |usr_42.txt|  新增新的選單

版權: 參見 |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
