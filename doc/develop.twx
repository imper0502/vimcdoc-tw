*develop.txt*	For Vim version 8.0.  最近更新: 2017年7月


		  VIM 參考手冊    by Bram Moolenaar
		  譯者: jwdu，iCrazy，tocer (http://vimcdoc.sf.net)


Vim 的開發						*development*

這一節的內容對那些想進一步開發 Vim 的人來說是很重要的。

1. 設計目標		|design-goals|
2. 程式設計風格		|coding-style|
3. 設計決定		|design-decisions|
4. 假定			|design-assumptions|

請先看一下 "src" 目錄下的 README.txt 以便對原始碼有一個總體的瞭解。

Vim 是開源軟體，鼓勵所有人蔘與並改進 Vim。如果你想遞交 patch，請使用 "diff -c"
來產生上下文 (context) 格式的 diff 檔案。
另見 http://vim.wikia.com/wiki/How_to_make_and_submit_a_patch 。

==============================================================================
1. 設計目標						*design-goals*

首先說最重要的內容 (概略的說一下)。

注意 許多專案是互相沖突的，但這是故意的。對於它們，你必須自己平衡一下。

VIM 是 ... 和 VI 兼 容 的				*design-compatible*

首先，必須使 Vim 能夠代替 Vi。如果使用者願意，他可以在相容模式下使用 Vim 而且很
難發現它和原先的 Vi 有什麼不同。

例外:
- 在 Vim 中不再有明顯的 Vi 錯誤。
- 有很多不同的 Vi 版本。我用 3.7 (6/7/85) 版作為參考。但是如果可能，也會支援其
  它的版本。POSIX 中的 Vi 部分不是最主要的來源。
- Vim 中有一些新的指令，你不要因為某個命令在 Vi 中不存在，就指望它會失敗。
- Vim 有許多特性是 Vi 所沒有的。從 Vim 回到 Vi ，將會出現一些不可避免的問題。
- 有一些指令可能是很少用到 (open 模式、在崩潰時傳送一封郵件等等)。只有你能說明
  為什麼應當加入這些功能，並且不會增加多少程式碼量時，它們才會被加入。
- 對一些命令是否仍需相容 Vi 是一個有爭議的問題。對這些，會使用一個選項標誌位。


VIM 是 ... 改 進 過 的					*design-improved*

Vim 的改良使它成為一個更好的 Vi，而沒有變成一個完全不同的編譯器。對它的擴充套件是
本著 "Vi 精神" 完成的。
- 儘可能多的使用鍵盤，滑鼠需要第三隻手來操作，而我們沒有第三隻手。而且，許多終
  端沒有滑鼠。
- 當使用滑鼠操作時，儘量少回到鍵盤操作，避免滑鼠和鍵盤的混合操作。
- 用一致的方式增加命令和選項。否則，人們將會很難發現並記住它們。請記住: 以後會
  加入更多的命令和選項。
- 一個人們不知道的特性是一個無用的特性。不要新增不明顯的特性，或者至少在文件中
  說明它們的存在。
- 儘量少用 CTRL 和其它修飾符，因為它們很難輸入。
- 因為對許多人來說，Vim 是他們剛接觸或不熟悉的，所以請儘量使 Vim 容易上手。
- 特性是可以無限增加的，對它們的選擇基於以下方面: (1) 使用者需要什麼 (2) 實現
  它需要多少工作量 (3) 的確有人會去實現它。


VIM 是 ... 多 平 臺 的					*design-multi-platform*

Vim 設法支援儘可能多的平臺，從而讓儘可能多的人能夠使用它。
- 支援多種終端。最小的需求是定位滑鼠和清屏。指令最好用多數鍵盤都具有的那些鍵來
  執行。在對映鍵盤時，支援鍵盤上所有的鍵。
- 支援多種平臺。必要條件是有人想在此平臺上開發 Vim，而且不要把程式碼搞亂。
- 支援多種編譯器和庫。並不是每個人都能夠安裝另一個編譯器或圖形庫。
- 人們經常從一個平臺轉移到另一個平臺，從圖形介面轉移到終端模式。特性應在每個版
  本中都加入，至少應該在儘可能多的版本中出現。儘量避免使用者為了有效的完成他們
  的工作而需要在不同平臺間轉移。
- 也許有些特性在某些平臺上沒有，或者只在某個平臺上有，但這不意味著它不應當被實
  現。[這個和上一個原則明顯的衝突了，但我們必須在它們之間做個平衡。]


VIM 是 ... 具 有 詳 盡 文 檔 的				*design-documented*

- 一個沒有文件的特性是一個無用的特性。針對新特性的補丁必須包含它的文件。
- 文件必須全面且容易理解。最好舉例說明問題。
- 請使檔案儘可能的短，短文件能使得找到它容易一些。

VIM 是 ... 速 度 快 、 體 積 小 的			*design-speed-size*

Vim 不能大量消耗系統資源，必須使它體積小且速度快。
- 計算機每年都在變得更快、更大。Vim 也可以同樣的變化，但是速度不能超過計算機的
  變化速度。要使 Vim 在老的計算機上也可以使用。
- 許多使用者經常從 shell 啟動 Vim。啟用時間必須儘量短。
- 指令必須有效的工作，它們消耗的時間要儘可能的短。有用的指令可以多消耗一點時
  間。
- 注意到許多人在慢速線路上使用 Vim，因此，要使通訊的開銷儘可能的少。
- 如果一個顯著增加 Vim 體積的功能不被大多數人使用，應該可以關閉該功能。
- Vim 只是其它許多元件中的一個，不要把它弄成一個笨重的應用程式，倒要使它能夠和
  其它程式一起很好的工作。


VIM 是 ... 可 維 護 的					*design-maintain*

- 原始碼不應該變成一團糟。它應該是可靠的程式碼。
- 所有的檔案應使用相同的風格，使得它們易讀性強 |coding-style|。
- 根據需要有效的使用註釋！_不要_引用函式和引數名。要解釋它們的意義。
- 移植到另一個平臺應該很容易，而不必改變太多獨立於平臺的程式碼。
- 使用面向物件的思想: 把資料和程式碼放在一起，波及到程式碼其它部分的知識要儘可能
  的少。


VIM 是 ... 靈 活 的					*design-flexible*

Vim 應該讓使用它的人很容易在他們喜歡的風格下工作，而不強迫他們使用一個特定的方
式工作。這個對於那些有巨大影響的選項 (如 'compatible' 選項) 和其他細節都是一
樣。預設值是經過認真挑選的，以便大多數使用者都樂意在預設設定下使用 Vim。使用者可
以用命令和選項來調整 Vim 來滿足他們和環境的需要。


VIM 不 是 ... 						*design-not*

- Vim 不是一個 shell 或作業系統。你不能在 Vim 內執行一個 shell 或使用它控制一
  個偵錯程式。應該使用相反的方式工作: 把 Vim 當作來自 shell 或 IDE 中的一個部分
  來使用。這裡有一個諷刺的說法: "Vim 不像 Emacs 那樣會包含除廚房中的水槽以外的
  每件事物，但有人說如果你需要的話，卻可以用它來洗盤子。;-)"
  要在 Vim 中使用 gdb，參見: http://www.agide.org 和 http://clewn.sf.net。
- Vim 不是一個為了看起來漂亮而犧牲多平臺一致性的華而不實的 GUI 編輯器。但我們
  依然歡迎有效的 GUI 特性。

==============================================================================
2. 程式設計風格						*coding-style*

這些是改變 Vim 原始碼的時候必須遵循的準則。為了保持原始碼的可讀性和可維護性，
請堅持使用這些原則。

這個列表是不完全的，請檢視原始碼以獲得更多的例子。


修 改 代 碼						*style-changes*

修改程式碼的基本步驟:
1. 從 github 獲取程式碼。方便你的版本隨時和主程式碼庫保持同步 (你的修改可能需要一
   段時間才會被接受)。需要花點時間學習 git，它的使用者介面不是最直觀。
2. 首先調整文件，這樣做將使你對你的更改如何影響使用者有一個印象。
3. 改變原始碼。
4. 檢查 ../doc/todo.txt，看看所作的修改是否影響其中的專案。
5. 用 "git diff" 做一個補丁。也可以在 github 上建立 pull 請求，但主要是 diff
   的部分。
6. 寫一個修改了哪些地方的記錄，最好提到相關問題和解決方案。給 vim-dev 郵件組發
   信包含這個解釋和 diff 本身。也可以在 github 上建立 pull 請求。


C COMPILER						*style-compiler*

支援的 C 編譯器最低版本是 C89，也即 ANSI C。之後的標準沒有太多新功能，而 C89
的支援最廣泛。

這意味著一個限制: 不能用 // 註釋，只能用 /* 註釋 */。


普 通 函 數 的 使 用					*style-functions*

一些普遍使用的函式都有一個特殊的 Vim 版本。它們的引入是有原因的，因此，一般應
考慮使用這些 Vim 版本。

通用名		VIM 函式名	VIM 版本的不同
free()		vim_free()	檢查釋放 NULL 的情況
malloc()	alloc()		檢查記憶體不足的情況
malloc()	lalloc()	類似於 alloc()，但是支援長引數
strcpy()	STRCPY()	對於 char_u* 型別的引數，會自動將其轉換為
				(char*) 型別
strchr()	vim_strchr()	接受特殊字元
strrchr()	vim_strrchr()	接受特殊字元
isspace()	vim_isspace()	可以處理 ASCII 碼 > 128 的字元
iswhite()	vim_iswhite()	僅對 Tab 和空格返回真值
memcpy()	mch_memmove()	能處理範圍重疊的複製
bcopy()		mch_memmove()	處理重疊的複製
memset()	vim_memset()	對所有系統通用


名 稱							*style-names*

函式名不能超過 31 個字元的長度 (因為 VMS 的緣故)。

不要使用 "delete" 或 "this" 作為變數名稱，C++ 不喜歡這樣。

因為 Vim 需要在儘可能多的平臺上執行，所以我們需要避免那些已經被系統定義過的名
稱。這裡是一個已知會造成麻煩的名稱列表 (使用正規表示式模式給出)。

is.*()		POSIX，ctype.h
to.*()		POSIX，ctype.h

d_.*		POSIX，dirent.h
l_.*		POSIX，fcntl.h
gr_.*		POSIX，grp.h
pw_.*		POSIX，pwd.h
sa_.*		POSIX，signal.h
mem.*		POSIX，string.h
str.*		POSIX，string.h
wcs.*		POSIX，string.h
st_.*		POSIX，stat.h
tms_.*		POSIX，times.h
tm_.*		POSIX，time.h
c_.*		POSIX，termios.h
MAX.*		POSIX，limits.h
__.*		POSIX，system
_[A-Z].*	POSIX，system
E[A-Z0-9]*	POSIX，errno.h

.*_t		POSIX，用於 typedefs。請用 .*_T 代替。

wait		不要使用它作為函式的引數，和 types.h 衝突
index		遮蔽全域性宣告
time		遮蔽全域性宣告
new		C++ 保留關鍵字
try		Borland C++ 不希望它作為變數名被使用。

clear		Mac curses.h
echo		Mac curses.h
instr		Mac curses.h
meta		Mac curses.h
newwin		Mac curses.h
nl		Mac curses.h
overwrite	Mac curses.h
refresh		Mac curses.h
scroll		Mac curses.h
typeahead	Mac curses.h

basename()	GNU 串函式
dirname()	GNU 串函式
get_env_value()	Linux 系統函式


雜 項							*style-various*

型別定義 (typedef) 的名稱應該以 "_T" 結尾: >
    typedef int some_T;
巨集 (define) 的名稱應該全部是大寫: >
    #define SOME_THING
特性 (feature) 應該總是以 "FEAT_" 開頭: >
    #define FEAT_FOO

不要使用 '\"'，一些編譯器不能處理它。用 '"' 比較合適。

不要使用:
    #if HAVE_SOME
一些編譯器不能處理它並報告說 "HAVE_SOME" 沒有被定義。
請使用
    #ifdef HAVE_SOME
或
    #if defined(HAVE_SOME)


風 格							*style-examples*

一般原則: 每行一條語句。

錯誤: 	    if (cond) a = 1;

正確: 	    if (cond)
		a = 1;

錯誤: 	    while (cond);

正確: 	    while (cond)
		;

錯誤: 	    do a = 1; while (cond);

正確: 	    do
		a = 1;
	    while (cond);

錯誤:	    if (cond) {
               cmd;
               cmd;
	    } else {
               cmd;
               cmd;
	    }

正確:	    if (cond)
            {
               cmd;
               cmd;
	    }
	    else
	    {
               cmd;
               cmd;
	    }

使用 ANSI (新風格) 函式宣告，返回型別在單獨縮排的一行上。

錯誤: 	int function_name(int arg1, int arg2)

正確: 	/*
	 * 解釋函式的功能。
	 *
	 * 解釋返回值。
	 */
	    int
	function_name(
	    int		arg1,		/* arg1 的簡短註釋 */
	    int		arg2)		/* arg2 的簡短註釋 */
	{
	    int		local;		/* local 的註釋 */

	    local = arg1 * arg2;



空 格 和 標 點						*style-spaces*

不要在函式名和括號間留空格:

錯誤:   func (arg);
正確: 	func(arg);

但請在 if，while，switch 等之後留一個空格:

錯誤: 	if(arg)		for(;;)
正確: 	if (arg)	for (;;)

在逗號和分號後留一個空格:

錯誤:   func(arg1,arg2);	for (i = 0;i < 2;++i)
正確: 	func(arg1, arg2);	for (i = 0; i < 2; ++i)

在 '='，'+'，'/' 等的前後各留一個空格:

錯誤: 	var=a*5;
正確: 	var = a * 5;

一般地: 使用空行來把程式碼分組。在每組程式碼的上面寫上註釋，這樣就可以快速的知道這
些程式碼是用來幹什麼的。

正確: 	/* Prepare for building the table. */
	get_first_item();
	table_idx = 0;

	/* Build the table */
	while (has_item())
	    table[table_idx++] = next_item();

	/* Finish up. */
	cleanup_items();
	generate_hash(table);

==============================================================================
3. 設計決定						*design-decisions*

摺疊

對同一個緩衝區可以有多種摺疊形式。例如，一個視窗顯示函式體摺疊後的文字，另一個
視窗顯示函式體。

摺疊是一種顯示文字的方式。它不應該改變文字自身。所以摺疊是被當作緩衝區文字 (緩
衝區行) 和視窗內顯示的文字 (邏輯行) 之間的過濾器來實現的。


為視窗命名

我們一般用單詞 "視窗" 來稱呼很多東西: 螢幕上的一個視窗、xterm 視窗、Vim 中一個
用來檢視緩衝區內容的視窗。
為避免混淆，我們給其他有時被稱作視窗的專案起了其他的名稱。這些是相關專案的概
述:

screen		整個螢幕。對於 GUI 來說，就是類似於 1024x768 畫素之類的東西。
		Vim shell 可以使用整個螢幕 (例如，在控制檯上執行時) 或它的一部
		分 (xterm 或 GUI)。
shell		Vim 這個應用程式。它可以覆蓋整個螢幕 (例如，在控制檯上執行時)
		或它的一部分 (xterm 或 GUI)。
window		用來檢視緩衝區內容的地方。Vim 中可以包括很多視窗，還有命令列、
		選單欄、工具欄等。它們被整合到 shell 中。


拼寫檢查						*develop-spell*

當要把拼寫檢查加進 Vim 時，考察了一些可用的拼寫檢查庫和程式。不幸的是，沒有一
個能提供足夠的能力使其能夠作為 Vim 的拼寫檢查引擎，原因很多:

- 缺乏對多位元組編碼的支援。至少要支援 UTF-8，以便同一檔案能使用多種語言。
  實時轉換未必總是可行的 (這需要 iconv 支援)。
- 對於那些程式和庫: 如果不作任何改動，需要和 Vim 分開單獨安裝才能使用。一般來
  說，這不是不可以，但總是個問題。
- 效能: 測試表明這些程式和庫可以像語法高亮那樣支援 (重畫時) 實時的拼寫檢查，但
  那些程式碼所用的機制太慢了。例如使用雜湊表的 Myspell。大部分的拼寫檢查程式使用
  字綴壓縮 (affix compression) 演算法也會使其速度減慢不少。
- 使用像 aspell 這樣的外部程式需要設定通訊機制。這會使可移植性變得複雜 (只考慮
  Unix 系統相對簡單點，但還遠遠不夠)。而且效能也是個問題 (大量的程序切換)。
- 缺乏對包含非單詞字元的單詞的支援，如 "Etten-Leur" 和 "et al."。需要把詞中每
  個部分都標識為好詞，但這樣就降低了檢測的可靠性。
- 缺乏對區域或方言的支援。例如，接受所有英語單詞並且單獨高亮出非加拿大的單詞是
  很困難的。
- 缺乏對生僻詞的支援。有很多詞拼寫正確但幾乎很少使用，卻有可能是拼寫錯誤的常用
  詞。
- 對於拼寫建議，速度不太重要，要安裝其他的程式或者庫也是可以接受的。但是這些程
  序或庫提供的單詞列表也許與拼寫檢查程式使用的不一致，給出的建議可能是拼寫檢查
  程式檢測出的拼寫錯誤的單詞。


拼寫建議					*develop-spell-suggestions*

對於實現拼寫建議，有兩種基本的方法:
1. 嘗試輕微改變錯誤的單詞，然後檢查能否和正確的單詞匹配。或者瀏覽正確單詞列
   表，輕微改變它們，看能否和錯誤的單詞匹配。這裡所指的改動包括: 刪除一個字
   符，插入一個字元，交換兩個字元等。
2. 比較壞詞和好詞列表的發音來尋找匹配。可能也需要象第一種方法那樣對單詞做少許
   改變。

第一種方法的優勢在於查詢錄入錯誤。在使用雜湊表試驗和參考了其他拼寫檢查程式的方
案後，得出結論: trie (一種樹結構) 是理想方案。既可以減少記憶體佔用，又可以嘗試合
理的改變。例如，只有在能夠拼成正確單詞的情況下才插入字元。其他方式 (使用雜湊
表) 需要在單詞的所有位置嘗試所有可能的字元。而且，雜湊表需要單獨標識單詞的邊
界。而 trie 就不需要這樣做。這樣會簡化很多。

當我們知道單詞如何發音卻不知道如何拼寫時，按發音摺疊匹配就很有用了。例如，單詞
"dictionary" 可能寫成 "daktonerie"。第一種方法需要嘗試的次數非常多，很難找到正
確的單詞。按發音匹配後，這兩個單詞變成了 "tkxnry" 和 "tktnr"，兩者僅有兩個字元
的差異。

為了通過相似的發音來查詢單詞 (尋找按發音摺疊等價的單詞)，我們需要所有發音相似
的單詞列表。為此，我們作了一些試驗來尋找最好的方法。可供選擇的方案是:
1. 在尋找拼寫建議時，實時進行發音匹配。這意味著瀏覽 trie 樹以尋找正確單詞，匹
   配每個單詞發音，並檢查它與錯誤單詞的不同。這種方式記憶體佔用少，但花費時間
   多。在一臺比較快的電腦上，對於英文需要幾秒，這對於互動式使用還可以接受。但
   是對於某些語言，則超過 10 秒 (如: 德語、加泰羅尼亞語)，這就慢得無法忍受了。
   對於成批處理 (自動更正)，所有的語言處理起來都很慢。
2. 把 trie 用於發音匹配的單詞，這樣查詢時就可以和沒有用發音摺疊的方法一模一
   樣。但這需要對每個相近的發音記住所有好詞的列表。這種方式搜尋匹配很快，但是
   要佔用大量記憶體，其級別大約在 1M 到 10M 之間。對於某些語言，甚至會大於原單詞
   列表。
3. 類似於第二種方案，但用字綴壓縮 (affix compression) 並且只儲存發音相近的單詞
   基本部分 (字根) 來減少記憶體開銷。aspell 就是這麼做的。缺點是，在按發音進行匹
   配前，需要從錯誤的單詞上分開字綴，這意味著在單詞頭和/或尾出現的錯誤會導致本
   方案失敗。而且當錯誤的單詞和正確的單詞間有很大不同時，本方案會變得很慢。

我們作出的選擇是使用第二種方案，並使用單獨的檔案。這樣，有足夠記憶體的使用者可以得
到很好的拼寫建議，而記憶體不足或者只想要拼寫檢查而不需要建議的使用者就可以不用那麼
多記憶體。


單詞頻率

對建議進行排序時，知道單詞常見與否很有幫助。理論上，我們可以在字典中對應單詞保
存一個單詞頻率。但是每個單詞都需要計數。這會使單詞樹的壓縮效率大為降低。而且對
所有的語言都要維護單詞頻率，將是個繁重的任務。另外，最好優先考慮文本里已經出現
的單詞。這樣在特定文本里出現的單詞可以被建議列表優先列出。

現已實現的是統計已經顯示的單詞。雜湊表用於快速查詢單詞的計數。字綴檔案的
COMMON 專案中列出的單詞會先有初始計數，這樣，即使新編輯檔案時也能馬上用此功
能。

這還不夠理想，因為 Vim 執行的時間越長，單詞計數就會越大。但實際應用中，這仍然
比不使用單詞計數的情形要改進不少。

==============================================================================
4. 假定							*design-assumptions*

變數的大小:
char	    8 位有符號數
char_u	    8 位無符號數
int	    32 或 64 位有符號數 (16 位是可能的，但功能會有限制)
unsigned    32 或 64 位無符號數 (16 位情況同 int)
long	    32 或 64 位有符號數，可具有指標

注意: 某些編譯器不能處理過長的原始碼行或者字串。C89 標準規定限制在 509 個字元
以內。

 vim:tw=78:ts=8:ft=help:norl:
