*eval.txt*      For Vim version 8.0.  最近更新: 2017年7月


		  VIM 參考手冊    by Bram Moolenaar
				譯者: Willis
				http://vimcdoc.sf.net


表示式求值				*expression* *expr* *E15* *eval*

使用者手冊第 41 章 |usr_41.txt| 有使用表示式的介紹。

注意: 表示式求值可以在編譯時關閉。如果你這麼做，本文件介紹的特性就不復存在。見
|+eval| 和 |no-eval-feature|。

1.  變數		|variables|
    1.1 變數型別
    1.2 函式引用		|Funcref|
    1.3 列表			|Lists|
    1.4 字典			|Dictionaries|
    1.5 變數的更多細節		|more-variables|
2.  表示式語法		|expression-syntax|
3.  內部變數		|internal-variables|
4.  內建函式		|functions|
5.  定義函式		|user-functions|
6.  花括號名字		|curly-braces-names|
7.  命令		|expression-commands|
8.  例外處理		|exception-handling|
9.  示例		|eval-examples|
10. 不包含 +eval 特性	|no-eval-feature|
11. 沙盤 (sandbox)	|eval-sandbox|
12. 文字鎖		|textlock|
13. 測試		|testing|

{Vi 無此功能}

==============================================================================
1. 變數							*variables*

1.1 變數型別 ~
							*E712*
有九種類型的變數:

數值		32 位或 64 位帶符號整數。|expr-number| *Number*
		64-位整數只有在編譯時帶 |+num64| 特性時才有效。
		示例:  -123  0x10  0177  0b1011

浮點數		帶小數的數值。|floating-point-format| *Float*
		{僅當編譯時加入 |+float| 特性才有效}
		示例: 123.456  1.15e-6  -1.1e3

							*E928*
字串		NUL 結尾的 8 位無符號字元 (即位元組) 的串。|expr-string|
		示例: "ab\txx\"--"  'x-z''a,c'

列表		專案的有序的序列 |List|。
		示例: [1, 2, ['a', 'b']]

字典		關聯的無序陣列: 每個專案包含一個鍵和一個值。|Dictionary|
		示例: {'blue': "#0000ff", 'red': "#ff0000"}

函式引用	指向一個函式的引用 |Funcref|。
		示例: function("strlen")
		可以繫結到字典或引數上，這樣就類似於一個偏函式。
		示例: function("Callback", [arg], myDict)

特殊		|v:false|、|v:true|、|v:none| 和 |v:null|。 *Special*

作業		用於作業，見 |job_start()|。 *Job* *Jobs*

通道		用於通道，見 |ch_open()|。 *Channel* *Channels*


數值和字串型別之間會根據使用的情況自動轉換。

數值到字串的轉換使用數值的 ASCII 表示。例如:
	數值 123	-->	字串 "123" ~
	數值 0		-->	字串 "0" ~
	數值 -1		-->	字串 "-1" ~
							*octal*
字串到數值的轉換則把字串開頭的一系列數字位轉換成數值。十六進位制 "0xf9"、八
進位制 "017" 和二進位制 "0b10" 形式的數值可以識別。如果字串不以數字開始，則結果
為零。例如:
	字串 "456"	-->	數值 456 ~
	字串 "6bar"	-->	數值 6 ~
	字串 "foo"	-->	數值 0 ~
	字串 "0xf1"	-->	數值 241 ~
	字串 "0100"	-->	數值 64 ~
	字串 "0b101"	-->	數值 5 ~
	字串 "-8"	-->	數值 -8 ~
	字串 "+8"	-->	數值 0 ~

要強制從字串轉換到數值，給它加零: >
	:echo "0100" + 0
<	64 ~

要避免開頭的零導致八進位制的轉換，或者想換不同的基底，用 |str2nr()|。

							*TRUE* *FALSE*
布林型的操作使用數值型別。零代表假值 (FALSE)，非零代表真值 (TRUE)。也可用
|v:false| 和 |v:true|。函式返回 TRUE 時相當於數值一，FALSE 相當於數值零。

注意 在命令: >
	:if "foo"
	:" _不_ 執行
裡，"foo" 被轉換成 0，也就是假值。如果字串以非零數字開始，則代表真值: >
	:if "8foo"
	:" 執行
要測試字串非空，應該使用 empty(): >
	:if !empty("foo")
<
							*non-zero-arg*
函式引數和 |TRUE| 行為通常略有差異: 如果引數存在且其值為非零數值、|v:true| 或
非空字串，則視之為真值。
注意  " " 和 "0" 也是非空字串，因而模式被清 (譯者注: 原文如此，大約意義為亦
應視為真值)。列表、字典和浮點數不是數值或字串，因而視為假值。

		*E745* *E728* *E703* *E729* *E730* *E731* *E908* *E910* *E913*
列表、字典、函式引用、作業和通道型別不會自動進行轉換。

							*E805* *E806* *E808*
混合數值和浮點數的計算時，數值轉換為浮點數。否則沒有自動到浮點數的轉換。用
str2float() 可轉換字串到浮點數，printf() 從浮點數到字串，float2nr() 則從浮
點數到數值。

			*E891* *E892* *E893* *E894* *E907* *E911* *E914*
期待浮點數的地方也可用數值代替，但其它都不行。

						*no-type-checking*
試圖改變變數型別不會報錯。


1.2 函式引用 ~
					*Funcref* *E695* *E718*
函式引用變數可以通過 |function()| 函式、|funcref()| 函式或者 |expr-lambda| 匿
名錶達式得到。可以在表示式裡用它來代替函式名，在圍繞引數的括號之前，以呼叫它引
用的函式。例如: >

	:let Fn = function("MyFunc")
	:echo Fn()
<							*E704* *E705* *E707*
函式引用變數必須以大寫字母、"s:"、"w:"、"t:" 或 "b:" 開始。可以用 "g:"，但後面
的名字必須以大寫開始。函式引用變數不能和任何函式重名。

特例是可以定義函式並直接把它的函式引用賦給字典的一個專案。例如: >
	:function dict.init() dict
	:   let self.val = 0
	:endfunction

該字典的鍵可以用小寫字母開始。這裡不用實際的函式名。另見 |numbered-function|。

函式引用可以用 |:call| 命令呼叫: >
	:call Fn()
	:call dict.init()

所引用的函式的名字可以用 |string()| 得到， >
	:let func = string(Fn)

你可以用 |call()| 來呼叫函式引用並用一個列表變數來傳遞引數: >
	:let r = call(Fn, mylist)
<
								*Partial*
函式引用可以選擇繫結字典和/或引數，也叫偏函式。通過向 function() 或 funcref()
提供字典和/或引數完成。呼叫函式時，該字典和/或引數被傳入函式。例如: >

	let Cb = function('Callback', ['foo'], myDict)
	call Cb()

這類似於如下方式地呼叫函式: >
	call myDict.Callback('foo')

對 |ch_open()| 這樣傳遞函式作為引數的情況，這很有用。

注意 把函式作為字典的一個成員時，也會繫結函式到字典: >

	let myDict.myFunction = MyFunction
	call myDict.myFunction()

這裡，呼叫 "myFunction" 成員時，MyFunction() 會通過 "self" 得到 myDict。如果把
"myFunction" 賦給 otherDict 並呼叫之，則相應繫結到 otherDict 上: >

	let otherDict.myFunction = myDict.myFunction
	call otherDict.myFunction()

現在 "self" 變成了 "otherDict"。但字典如果是顯式繫結，這不會發生: >

	let myDict.myFunction = function(MyFunction, myDict)
	let otherDict.myFunction = myDict.myFunction
	call otherDict.myFunction()

這裡 "self" 還是 "myDict"，因為是通過顯式繫結的。


1.3 列表 ~
						*list* *List* *Lists* *E686*
列表是專案的有序序列。專案可以是任何型別，用索引號可以進行訪問。可以在序列的任
何位置上增加或者刪除專案。


列表建立 ~
							*E696* *E697*
列表用方括號裡逗號分隔的專案序列建立。例如: >
	:let mylist = [1, two, 3, "four"]
	:let emptylist = []

專案可以是任何表示式。用列表作為專案就能建立列表的列表: >
	:let nestlist = [[11, 12], [21, 22], [31, 32]]

忽略末項之後額外的逗號。


列表索引 ~
							*list-index* *E684*
在列表之後的方括號中放上索引號可以訪問列表專案。索引從零開始，也就是說，第一個
專案的索引值為零。 >
	:let item = mylist[0]		" 得到第一個專案: 1
	:let item = mylist[2]		" 得到第三個專案: 3

如果返回的專案本身是列表，可以重複這樣的操作: >
	:let item = nestlist[0][1]	" 得到第一個列表的第二個專案: 12
<
負索引從尾端開始計算。索引 -1 指向列表的最後一個專案，-2 指向倒數第二個專案，
依此類推。 >
	:let last = mylist[-1]		" 得到最後一個專案: "four"

要避免非法索引值產生的錯誤，用 |get()| 函式。如果專案不存在，它返回零或者你指
定的預設值: >
	:echo get(mylist, idx)
	:echo get(mylist, idx, "NONE")


列表連線 ~

兩個列表可以用 "+" 操作符連線: >
	:let longlist = mylist + [5, 6]
	:let mylist += [7, 8]

要在前面或後面附加專案，在專案外面加上 [] 從而把它變為一個列表。要改變列表內部
的值，見下 |list-modification|。


子列表~
							*sublist*
列表的一部分可以通過指定首末兩個索引獲得，方括號內以冒號分隔兩者: >
	:let shortlist = mylist[2:-1]	" 得到列表 [3, "four"]

首索引的省略類似於用 0。末索引的省略類似於用 -1。 >
	:let endlist = mylist[2:]	" 從專案 2 到結束: [3, "four"]
	:let shortlist = mylist[2:2]	" 單個專案的列表: [3]
	:let otherlist = mylist[:]	" 複製列表

如果首索引在列表末項之後或者末索引小於首索引，返回空列表。沒有錯誤資訊。

如果末索引大於等於列表的長度，使用列表長度減一: >
	:let mylist = [0, 1, 2, 3]
	:echo mylist[2:8]		" 返回: [2, 3]
<
注意: mylist[s:e] 意味著用變數 "s:e" 作為索引。在 ":" 之前用單個字母作為變數要
小心。需要的話加上空格: mylist[s : e]。


列表同一 ~
							*list-identity*
如果變數 "aa" 是列表，把它賦給另一個變數 "bb" 後，兩個變數指向同一列表。因此，
對列表 "aa" 的修改也同時修改了 "bb": >
	:let aa = [1, 2, 3]
	:let bb = aa
	:call add(aa, 4)
	:echo bb
<	[1, 2, 3, 4]

|copy()| 函式可以複製列表。如上所述，用 [:] 也可。這種方式建立列表的淺備份: 改
變列表中的列表專案仍然會修改複製列表的相應專案: >
	:let aa = [[1, 'a'], 2, 3]
	:let bb = copy(aa)
	:call add(aa, 4)
	:let aa[0][1] = 'aaa'
	:echo aa
<	[[1, aaa], 2, 3, 4] >
	:echo bb
<	[[1, aaa], 2, 3]

要建立一個完全獨立的列表，用 |deepcopy()|。它遞迴地建立列表值的備份。最深可達
100 層。

可用操作符 "is" 檢查兩個變數是否指向同一個列表。"isnot" 剛好相反。與此對照，
"==" 比較兩個列表的值是否相同。 >
	:let alist = [1, 2, 3]
	:let blist = [1, 2, 3]
	:echo alist is blist
<	0 >
	:echo alist == blist
<	1

比較列表時 注意: 如果長度相同，所有專案用 "==" 的比較的結果也相同，兩個列表就
認為相同。有一個例外: 數值和字串總被認為不相同。這裡不進行自動型別轉換，而在
變數間直接用 "==" 卻不是如此。例如: >
	echo 4 == "4"
<	1 >
	echo [4] == ["4"]
<	0

因此可以說，列表的比較比數值和字串的比較更嚴格。你同樣可以用這種方式比較簡單
型別的值，把它們放到列表裡就行了: >

	:let a = 5
	:let b = "5"
	:echo a == b
<	1 >
	:echo [a] == [b]
<	0


列表解包 ~

要給列表專案解包，即把它們分別存入單獨的變數，用方括號把變數括起來，如同把它們
當作列表專案: >
	:let [var1, var2] = mylist

如果變數和列表的專案數量不同，報錯。要處理列表中所有額外的專案，加上 ";" 和單
個變數: >
	:let [var1, var2; rest] = mylist

它的工作方式就像: >
	:let var1 = mylist[0]
	:let var2 = mylist[1]
	:let rest = mylist[2:]

如果只有兩個專案，不會報錯。這時 "rest" 成為空表。


列表修改 ~
							*list-modification*
要修改列表的指定專案，用 |:let|: >
	:let list[4] = "four"
	:let listlist[0][3] = item

要修改列表的一部分，可以指定要修改的首末專案。提供的值的個數必須不少於該範圍內
的專案數: >
	:let list[3:5] = [3, 4, 5]

給列表增加和刪除專案可以通過函式完成。一些例子如下: >
	:call insert(list, 'a')		" 在最前面插入 'a'
	:call insert(list, 'a', 3)	" 在 list[3] 前插入專案 'a'
	:call add(list, "new")		" 在最後附加字串專案
	:call add(list, [1, 2])		" 在最後附加新的列表專案
	:call extend(list, [1, 2])	" 在最後擴充套件列表，使之多包含兩個專案
	:let i = remove(list, 3)	" 刪除專案 3
	:unlet list[3]			" 同上
	:let l = remove(list, 3, -1)	" 從專案 3 刪除到最後
	:unlet list[3 : ]		" 同上
	:call filter(list, 'v:val !~ "x"')  " 刪除有 'x' 的專案

改變列表專案的順序: >
	:call sort(list)		" 按字母給列表排序
	:call reverse(list)		" 反轉專案的順序
	:call uniq(sort(list))		" 排序並刪除重複項


For 迴圈 ~

|:for| 迴圈為每個列表專案執行命令。一個變數被依次設為每個列表專案。例如: >
	:for item in mylist
	:   call Doit(item)
	:endfor

它的工作方式就像: >
	:let index = 0
	:while index < len(mylist)
	:   let item = mylist[index]
	:   :call Doit(item)
	:   let index = index + 1
	:endwhile

如果你只是想要修改每個列表專案，|map()| 函式比 for 迴圈簡單得多。

就像 |:let| 命令，|:for| 也可以接受變數的列表。這需要引數是列表的列表。 >
	:for [lnum, col] in [[1, 3], [2, 8], [3, 0]]
	:   call Doit(lnum, col)
	:endfor

這就像對列表的每個專案使用了 |:let| 命令。重複一次，型別必須相同，否則會報錯。

也可以用變數儲存列表變數的其餘專案: >
	:for [i, j; rest] in listlist
	:   call Doit(i, j)
	:   if !empty(rest)
	:      echo "remainder: " . string(rest)
	:   endif
	:endfor


列表的相關函式 ~
						*E714*
可用於列表的函式: >
	:let r = call(funcname, list)	" 呼叫帶引數列表的函式
	:if empty(list)			" 檢查 list 是否為空
	:let l = len(list)		" list 專案的數量
	:let big = max(list)		" list 專案的最大值
	:let small = min(list)		" list 專案的最小值
	:let xs = count(list, 'x')	" 計算 list 裡 'x' 出現的次數
	:let i = index(list, 'x')	" list 第一個 'x' 的位置
	:let lines = getline(1, 10)	" 得到緩衝區十行文字行
	:call append('$', lines)	" 附加若干文字行到緩衝區尾部
	:let list = split("a b c")	" 用字串中的專案建立列表
	:let string = join(list, ', ')	" 用 list 專案構造字串
	:let s = string(list)		" list 的字串表示
	:call map(list, '">> " . v:val')  " 在每個專案前加上 ">> "

不要忘記組合使用不同功能可以簡化任務。例如，要計算列表中所有數值的總和: >
	:exe 'let sum = ' . join(nrlist, '+')


1.4 字典 ~
					*dict* *Dictionaries* *Dictionary*
字典是關聯陣列: 每個專案有一個鍵和一個值。用鍵可以定位專案，而專案的儲存不能確
定任何特定順序。


字典建立 ~
						*E720* *E721* *E722* *E723*
字典通過花括號裡逗號分隔的專案列表建立。每個專案包含以冒號分隔的鍵和值。一個鍵
只能出現一次。例如: >
	:let mydict = {1: 'one', 2: 'two', 3: 'three'}
	:let emptydict = {}
<							*E713* *E716* *E717*
鍵必須是字串。用數值也可以，但它總被自動轉換為字串。所以字串 '4' 和數值
4 總會找到相同的專案。注意 字串 '04' 和數值 04 是不一樣的，因為後者被轉換成
字串 '4'。空字串可用作鍵。

值可以是任何表示式。如果值本身是字典，就可以建立巢狀的字典: >
	:let nestdict = {1: {11: 'a', 12: 'b'}, 2: {21: 'c'}}

忽略末項之後的逗號。


訪問專案 ~

常見的訪問專案的方式是把鍵放入方括號: >
	:let val = mydict["one"]
	:let mydict["four"] = 4

用這種方式可以給已存在的字典增加新專案，這和列表不同。

如果鍵只包含字母、數字和下劃線，可以使用如下形式 |expr-entry|: >
	:let val = mydict.one
	:let mydict.four = 4

因為專案可以是包括列表和字典的任何型別，你可以反覆使用索引和鍵進行訪問: >
	:echo dict.key[idx].key


字典到列表的轉換 ~

你可以迴圈遍歷字典的所有專案。為此，你需要把字典轉為列表，然後把它傳遞給
|:for|。

通常，你期望遍歷所有的鍵，用 |keys()| 函式就可以了: >
	:for key in keys(mydict)
	:   echo key . ': ' . mydict[key]
	:endfor

鍵列表沒有經過排序。你可能希望先進行排序: >
	:for key in sort(keys(mydict))

要遍歷所有的值，用 |values()| 函式: >
	:for v in values(mydict)
	:   echo "value: " . v
	:endfor

如果你想同時得到鍵和值，用 |items()| 函式。它返回一個列表，其中每個專案是兩個
專案的列表: 鍵和值: >
	:for [key, value] in items(mydict)
	:   echo key . ': ' . value
	:endfor


字典同一 ~
							*dict-identity*
就像列表那樣，你需要用 |copy()| 和 |deepcopy()| 來構造字典的備份。否則，賦值產
生的結果會引用同一個字典: >
	:let onedict = {'a': 1, 'b': 2}
	:let adict = onedict
	:let adict['a'] = 11
	:echo onedict['a']
	11

如果所有的鍵-值組對的比較結果相同，兩個字典比較的結果也相同。詳情見
|list-identity|。


字典修改 ~
							*dict-modification*
要修改字典已經存在的專案或者增加新的專案，用 |:let|: >
	:let dict[4] = "four"
	:let dict['one'] = item

從字典裡刪除專案可以通過 |remove()| 或 |:unlet| 完成。
從 dict 裡刪除鍵 "aaa" 的專案有三種方法: >
	:let i = remove(dict, 'aaa')
	:unlet dict.aaa
	:unlet dict['aaa']

兩個字典的合併可以用 |extend()|: >
	:call extend(adict, bdict)
這使得 adict 得到擴充套件，加入所有的 bdict 專案。對於重複的鍵，adict 專案被覆蓋。
可選的第三個引數可以改變這一點。
注意 這不影響字典專案的順序，不要希望 ":echo adict" 會先顯示原有 adict 專案，
然後再顯示 bdict 的專案。

從字典裡刪除多個專案可以用 |filter()| 完成: >
	:call filter(dict, 'v:val =~ "x"')
刪除 "dict" 裡所有值不匹配 "x" 的專案。


字典函式 ~
				*Dictionary-function* *self* *E725* *E862*
定義函式時，如果帶有 "dict" 屬性，可以以一種特殊方式使用字典。例如: >
	:function Mylen() dict
	:   return len(self.data)
	:endfunction
	:let mydict = {'data': [0, 1, 2, 3], 'len': function("Mylen")}
	:echo mydict.len()

這類似於面向物件程式設計的方法。字典專案用作 |Funcref|。區域性變數 "self" 引用函式所
在的字典。

字典裡也可以加入指向沒有 "dict" 屬性的函式的函式引用，不過這時無法使用 "self"
變數。

				*numbered-function* *anonymous-function*
要避免額外的函式名，可以定義時直接賦給字典: >
	:let mydict = {'data': [0, 1, 2, 3]}
	:function mydict.len()
	:   return len(self.data)
	:endfunction
	:echo mydict.len()

該函式會得到一個編號，而 dict.len 的值是指向此函式的 |Funcref|。該函式只能通過
|Funcref| 訪問。如果沒有任何 |Funcref| 引用，它會被自動刪除。

編號函式不一定要有 "dict" 屬性。

如果你的編號函式有錯，可以用一個技巧知道它是什麼內容。假定函式是 42，命令為: >
 :function {42}


字典相關函式 ~
							*E715*
可以用於字典的函式: >
	:if has_key(dict, 'foo')	" 如果 dict 有帶 "foo" 鍵的專案則為真
	:if empty(dict)			" 如果 dict 為空則為真
	:let l = len(dict)		" dict 專案的數量
	:let big = max(dict)		" dict 專案的最大值
	:let small = min(dict)		" dict 專案的最小值
	:let xs = count(dict, 'x')	" 統計 dict 裡 'x' 出現的數目
	:let s = string(dict)		" dict 的字串表示
	:call map(dict, '">> " . v:val')  " 在每個專案前加上 ">> "


1.5 變數的更多細節 ~
							*more-variables*
如果你需要知道變數或表示式的型別，使用 |type()| 函式。

如果 'viminfo' 選項包含 '!' 標誌位，大寫開頭且不包含小寫字母的全域性變數被儲存在
viminfo 檔案裡 |viminfo-file|。

如果 'sessionoptions' 選項包含 "global"，大寫開頭且包含至少一個小寫字母的全域性
變數被儲存在會話檔案裡 |session-file|。

變數名			可以儲存的位置 ~
my_var_6		無
My_Var_6		會話檔案
MY_VAR_6		viminfo 檔案


可以使用花括號來構造變數名，見 |curly-braces-names|。

==============================================================================
2. 表示式語法						*expression-syntax*

表示式語法小結，優先順序從低到高排列:

|expr1|	expr2
	expr2 ? expr1 : expr1	if-then-else

|expr2|	expr3
	expr3 || expr3 ..	邏輯或

|expr3|	expr4
	expr4 && expr4 ..	邏輯與

|expr4|	expr5
	expr5 == expr5		等於
	expr5 != expr5		不等於
	expr5 >	 expr5		大於
	expr5 >= expr5		大於等於
	expr5 <	 expr5		小於
	expr5 <= expr5		小於等於
	expr5 =~ expr5		匹配正規表示式
	expr5 !~ expr5		不匹配正規表示式

	expr5 ==? expr5		等於，忽略大小寫
	expr5 ==# expr5		等於，匹配大小寫
	等等			如上，? 忽略大小寫，# 則匹配之

	expr5 is expr5		相同的 |List| 例項
	expr5 isnot expr5	不同的 |List| 例項

|expr5|	expr6
	expr6 +	 expr6 ..	數值加法或列表連線
	expr6 -	 expr6 ..	數值減法
	expr6 .	 expr6 ..	字串連線

|expr6|	expr7
	expr7 *	 expr7 ..	數值乘法
	expr7 /	 expr7 ..	數值除法
	expr7 %	 expr7 ..	數值求餘

|expr7|	expr8
	! expr7			邏輯非
	- expr7			一元減法: 取反
	+ expr7			一元加法: 原值

|expr8|	expr9
	expr8[expr1]		字串裡的位元組或者 |List| 的專案
	expr8[expr1 : expr1] 	字串子串或 |List| 的子列表
	expr8.name		|Dictionary| 的專案
	expr8(expr1, ...)	使用 |Funcref| 變數的函式呼叫

|expr9|	number			數值常數
	"string"		字串常數，反斜槓有特殊含義
	'string'		字串常數，' 加倍
	[expr1, ...]		|List|
	{expr1: expr1, ...}	|Dictionary|
	&option			選項值
	(expr1)			巢狀表示式
	variable		內部變數
	va{ria}ble		帶花括號的內部變數
	$VAR			環境變數
	@r			暫存器 'r' 的值
	function(expr1, ...)	函式呼叫
	func{ti}on(expr1, ...)	帶花括號的函式呼叫
	{args -> expr1}		匿名函式表示式


".." 標明這一層上的操作可以連線。比如: >
	&nu || &list && &shell == "csh"

同一層的表示式從左到右進行分析。


expr1							*expr1* *E109*
-----

expr2 ? expr1 : expr1

'?' 之前的表示式作為數值求值。如果結果為 |TRUE|，最終的結果是 '?' 和 ':' 之間
的表示式的值，不然最終的結果是 ':' 之後的表示式的值。例如: >
	:echo lnum == 1 ? "top" : lnum

因為第一個表示式是 "expr2"，它不能包含另一個 ?:。另外兩個表示式則沒有這個限
制，從而使得遞迴使用 ?: 成為可能。例如: >
	:echo lnum == 1 ? "top" : lnum == 1000 ? "last" : lnum

要使之可讀，建議使用續行符 |line-continuation|: >
	:echo lnum == 1
	:\	? "top"
	:\	: lnum == 1000
	:\		? "last"
	:\		: lnum

在 ':' 前，你總是應該加上空格，否則它可能被錯誤用在如 "a:1" 這樣的變數裡。


expr2 和 expr3						*expr2* *expr3*
---------------

expr3 || expr3 ..	邏輯或			*expr-barbar*
expr4 && expr4 ..	邏輯與			*expr-&&*

"||" 和 "&&" 操作符左右兩邊各接受一個引數。引數是 (或轉化為) 數值。運算結果是:

    輸入			 輸出 ~
n1	n2		n1 || n2	n1 && n2 ~
|FALSE|	|FALSE|		|FALSE|		|FALSE|
|FALSE|	|TRUE|		|TRUE|		|FALSE|
|TRUE|	|FALSE|		|TRUE|		|FALSE|
|TRUE|	|TRUE|		|TRUE|		|TRUE|

操作符可以連線。比如: >

	&nu || &list && &shell == "csh"

注意 "&&" 比 "||" 優先順序高，所以這等價於: >

	&nu || (&list && &shell == "csh")

一旦結果可以確定，表示式使用 "短路" 計算，也就是，不再計算後面的引數，這和 C
的情形類似。比如: >

	let a = 1
	echo a || b

這是合法的，即使沒有叫 "b" 的變數也是如此。因為 "a" 已經是 |TRUE|，結果必然是
|TRUE|。下面的情形類似: >

	echo exists("b") && b == "yes"

無論 "b" 定義與否，這是合法的。第二個子句只有在 "b" 定義的時候才會被計算。


expr4							*expr4*
-----

expr5 {cmp} expr5

比較兩個 expr 表示式，如果結果為假，返回 0，如果結果為真，返回 1。

			*expr-==*  *expr-!=*  *expr->*	 *expr->=*
			*expr-<*   *expr-<=*  *expr-=~*  *expr-!~*
			*expr-==#* *expr-!=#* *expr->#*  *expr->=#*
			*expr-<#*  *expr-<=#* *expr-=~#* *expr-!~#*
			*expr-==?* *expr-!=?* *expr->?*  *expr->=?*
			*expr-<?*  *expr-<=?* *expr-=~?* *expr-!~?*
			*expr-is* *expr-isnot* *expr-is#* *expr-isnot#*
			*expr-is?* *expr-isnot?*
		使用 'ignorecase'    匹配大小寫	    忽略大小寫 ~
等於			==		==#		==?
不等於			!=		!=#		!=?
大於			>		>#		>?
大於等於		>=		>=#		>=?
小於			<		<#		<?
小於等於		<=		<=#		<=?
匹配正規表示式		=~		=~#		=~?
不匹配正規表示式	!~		!~#		!~?
相同例項		is		is#		is?
不同例項		isnot		isnot#		isnot?

示例:
"abc" ==# "Abc"	  結果為 0
"abc" ==? "Abc"	  結果為 1
"abc" == "Abc"	  如果置位了 'ignorecase'，結果為 1，不然結果為 0

							*E691* *E692*
|List| 只能和 |List| 比較，而且只能用 "等於"、"不等於" 和 "is"。比較針對列表的
值，遞迴進行。忽略大小寫意味著比較專案的值時忽略大小寫。

							*E735* *E736*
|Dictionary| 只能和 |Dictionary| 比較，而且只能用 "等於"、"不等於" 和 "is"。比
較針對 |Dictionary| 的鍵/值，遞迴進行。忽略大小寫意味著比較專案的值時忽略大小
寫。

							*E694*
|Funcref| 只能和 |Funcref| 比較，而且只能用 "等於"、"不等於"、“is" 和
"isnot"。這裡永不忽略大小寫。引數或字典是否繫結 (即偏函式的情況) 是有關係的。
繫結的字典必須相等 (或 "is" 的情況下，相同例項)，引數亦然。

要比較函式引用是否指向相同的函式但忽略繫結的字典和引數，用 |get()| 來取得函式
名: >
	if get(Part1, 'name') == get(Part2, 'name')
	   " Part1 and Part2 refer to the same function

|List| 或 |Dictionary| 用 "is" 或 "isnot" 時，檢查表示式是否指向同一個 |List|
或 |Dictionary| 例項。一個 |List| 的備份和原來的 |List| 不同。如果不是 |List|
或 |Dictionary|，用 "is" 等價於用 "等於"，而 "isnot" 等價於 "不等於"，有一點區
別: 不同的型別總認為有不同的值: >
	echo 4 == '4'
	1
	echo 4 is '4'
	0
	echo 0 is []
	0
"is#"/"isnot#" 和 "is?"/“isnot?" 用於強制匹配和忽略大小寫。

如果比較字串和數值，字串被轉化成數值，而比較是在數值之間進行的。這意味
著: >
	echo 0 == 'x'
	1
因為 'x' 轉化的數值為零。不過: >
	echo [0] == ['x']
	0
在列表或字典裡不進行這種轉換。

如果比較兩個字串，使用 strcmp() 或 stricmp()。因而，比較的是數學上的差異 (比
較位元組碼)，而不必然是本地語言的字母的差異。

如果操作符後帶上 '#'，或者 'ignorecase' 關閉時使用無 '#' 的版本時，比較使用
strcmp(): 大小寫相關。

如果操作符後帶上 '?'，或者 'ignorecase' 開啟時使用無 '?' 的版本時，比較使用
stricmp(): 大小寫無關。

這裡 'smartcase' 不適用。

"=~" 和 "!~" 操作符使用右邊的引數作為模式來匹配左邊的引數。模式的定義見
|pattern|。匹配進行時，總是假設定位了 'magic' 並且 'cpoptions' 為空，無論
'magic' 或 'cpoptions' 實際的值為何。這使得指令碼可移植。要避免在正規表示式裡使
用的反斜槓需要加倍的問題，可以使用單引號的字串，見 |literal-string|。
既然字串假定為單行，多行的模式 (包含 \n，即反斜槓-n) 不會被匹配。不過，按本
義出現的單個 NL 字元可以像普通字元一樣匹配。比如:
	"foo\nbar" =~ "\n"	結果為 1
	"foo\nbar" =~ "\\n"	結果為 0


expr5 和 expr6						*expr5* *expr6*
---------------
expr6 +	 expr6 ..	數值加法或 |List| 連線			*expr-+*
expr6 -	 expr6 ..	數值減法				*expr--*
expr6 .	 expr6 ..	字串連線				*expr-.*

|Lists| 只能用 "+"，而且兩個 expr6 必須都是列表。返回兩者連線以後的新列表。

expr7 *	 expr7 ..	數值乘法				*expr-star*
expr7 /	 expr7 ..	數值除法				*expr-/*
expr7 %	 expr7 ..	數值求餘				*expr-%*

除了 "." 以外，這裡所有的操作都把字串轉化成數值。
按位操作運算見 |and()|、|or()| 和 |xor()|。

注意 "+" 和 "." 的差異:
	"123" + "456" = 579
	"123" . "456" = "123456"

因為 '.' 和 '+' 與 '-' 的優先順序相同，你需要把: >
	1 . 90 + 90.0
看作: >
	(1 . 90) + 90.0
這沒問題，因為字串 "190" 被自動轉換為數值 190，然後和浮點數 90.0 相加。不
過: >
	1 . 90 * 90.0
應被看作: >
	1 . (90 * 90.0)
因為 '.' 的優先順序比 '*' 低，這_不能_工作，因為它試圖連線浮點數和字串。

數值除以零時，結果取決於該值:
	  0 / 0  = -0x80000000	(類似於浮點數的 NaN)
	 >0 / 0  =  0x7fffffff	(類似於正無窮大)
	 <0 / 0  = -0x7fffffff	(類似於負無窮大)
	(Vim 7.2 之前，總是返回 0x7fffffff)

啟用 64-位數值支援時:
	  0 / 0  = -0x8000000000000000	(類似於浮點數的 NaN)
	 >0 / 0  =  0x7fffffffffffffff	(類似於正無窮大)
	 <0 / 0  = -0x7fffffffffffffff	(類似於負無窮大)

如果 '%' 的右邊為零，結果為 0。

這些操作不適用於 |Funcref|。

而 % 也不適用於浮點數。 *E804*


expr7							*expr7*
-----
! expr7			邏輯非			*expr-!*
- expr7			一元減法: 取反		*expr-unary--*
+ expr7			一元加法: 原值		*expr-unary-+*

'!' 把 |TRUE| 變為 |FALSE|，|FALSE| 變為 |TRUE| (一)。
'-' 改變數值的符號。
'+' 保持原值。

字串會先轉化為數值。

可以重複和混合這三種運算。例如:
	!-1	    == 0
	!!8	    == 1
	--9	    == 9


expr8							*expr8*
-----
expr8[expr1]		字串或 |List| 的專案		*expr-[]* *E111*
							*E909* *subscript*
如果 expr8 是數值或字串，結果是字串，包含 expr8 裡第 expr1 個位元組。expr8
視作字串，expr1 視作數值。這裡不識別多位元組編碼，但可考慮使用 `byteidx()`，或
用 `split()` 把字串變為字元的列表。

索引 0 給出第一個位元組。這和 C 類同。要小心: 文字列號可是從 1 開始的！例如，要
得到游標所在的位元組: >
	:let c = getline(line("."))[col(".") - 1]

如果字串的長度小於索引值，結果為空字串。負索引總是給出空字串 (原因: 反向
相容)。用 [-1:] 得到最後一個位元組。

如果 expr8 是 |List|，返回索引值為 expr1 的專案。可用的索引值見 |list-index|。
如果索引越界，產生錯誤。例如: >
	:let item = mylist[-1]		" 得到最後一個專案

一般的，如果 |List| 索引大於等於 |List| 的長度，或者比 |List| 的長度更負，產生
錯誤。


expr8[expr1a : expr1b]	子字串或子列表		*expr-[:]*

如果 expr8 是數值或字串，結果是子字串，包含第 expr1a 到第 expr1b (包含) 個
位元組。expr8 視作字串，expr1a 和 expr1b 視作數值。這裡不識別多位元組編碼，需用
|byteidx()| 來計算索引值。

如果省略 expr1a，用零。如果省略 expr1b，用字串的長度減一。

可以用負數來從字串尾部開始計算位置。-1 代表最後一個字元，-2 倒數第二個，依此
類推。

如果索引越界，忽略這些字元。如果 expr1b 小於 expr1a，結果是空字串。

例如: >
	:let c = name[-1:]		" 字串最後一個位元組
	:let c = name[-2:-2]		" 字串倒數第二個位元組
	:let s = line(".")[4:]		" 從第五個位元組到最後
	:let s = s[:-3]			" 刪除最後兩個位元組
<
							*slice*
如果 expr8 是 |List|，結果是新的 |List|，包含 expr1 和 expr1b 索引指定的專案。
和上面描述的字串情形類似。另見下面的 |sublist|。例如: >
	:let l = mylist[:3]		" 前四個專案
	:let l = mylist[4:4]		" 單個專案的列表
	:let l = mylist[:]		" 列表的淺備份

在 |Funcref| 上用 expr8[expr1] 或 expr8[expr1a : expr1b] 出錯。

小心名稱空間和變數後加冒號的子列表用法引起的混淆: >
	mylist[n:]     " 使用變數 n
	mylist[s:]     " 使用名稱空間 s:，報錯！


expr8.name		|Dictionary| 的專案		*expr-entry*

如果 expr8 是一個 |Dictionary| 且後跟句號再跟一個名字，該名字用作 |Dictionary|
的鍵。這相當於: expr8[name]。

該名字必須由字母數字字元組成。這和變數名一樣，不過這裡可以用數字開始。但不能用
花括號。

句號前後不能用空白。

例如: >
	:let dict = {"one": 1, 2: "two"}
	:echo dict.one
	:echo dict .2

注意 句號也用於字串連線。要避免混淆，用於字串連線的句號前後加上空白。


expr8(expr1, ...)	|Funcref| 函式呼叫

如果 expr8 是 |Funcref| 型別的變數，呼叫它指向的函式。



						*expr9*
number
------
number			數值常數			*expr-number*
				*hex-number* *octal-number* *binary-number*

十進位制、十六進位制 (0x 或 0X 開始)、二進位制 (0b 或 0B 開始) 和 八進位制 (0 開始)。

						*floating-point-format*
浮點數可用兩種形式給出:

	[-+]{N}.{M}
	[-+]{N}.{M}[eE][-+]{exp}

{N} 和 {M} 都是數值。{N} 和 {M} 都必須存在，且只能包含數位。
[-+] 意味著有一個可選的正負號。
{exp} 是指數部分，以 10 為基。
只能接受小數點，逗號不行。這和當前的 locale 無關。
{僅當編譯時加入 |+float| 特性才有效}

示例:
	123.456
	+0.0001
	55.0
	-0.123
	1.234e03
	1.0E-6
	-3.1416e+88

下面的形式是_非法的_:
	3.		{M} 為空
	1e40		{M} 為空

							*float-pi* *float-e*
可以複製-貼上的一些常用值: >
	:let pi = 3.14159265359
	:let e  = 2.71828182846

邏輯:
浮點數引入之前，文字 "123.456" 被解釋為兩個數值 "123" 和 "456"，轉換為字串，
然後進行連線而生成字串 "123456"。這被認為沒有意義，也沒有找到有意使用此特性
的 Vim 指令碼，因此我們採納了這種普遍的浮點數記法，而接受其後向不相容性。

						*floating-point-precision*
浮點數的精度和取值範圍取決於 Vim 編譯時使用的庫如何理解 "double"。執行時無法改
變。

浮點數 |Float| 的顯示預設使用 6 位十進位制位，類似於 printf("%g", f)。使用
|printf()| 函式時可以指定其它位數。例如: >
	:echo printf('%.15e', atan(1))
<	7.853981633974483e-01



string					*string* *String* *expr-string* *E114*
------
"string"		字串常數		*expr-quote*

注意 使用的是雙引號。

字串常數接受以下特殊字元:
\...	三位八進位制數 (例如，"\316")
\..	兩位八進位制數 (必須後跟非數字)
\.	一位八進位制數 (必須後跟非數字)
\x..	兩位十六進位制數指定的位元組 (例如，"\x1f")
\x.	一位十六進位制數指定的位元組 (必須後跟非十六進位制數字)
\X..	等同於 \x..
\X.	等同於 \x.
\u....  四位十六進位制指定的字元。根據 'encoding' 的當前值決定的編碼進行存貯 (例
	如，"\u02a4")
\U....	等同於 \u 但接受多達 8 位十六進位制數。
\b	退格 <BS>
\e	escape <Esc>
\f	換頁 <FF>
\n	換行 <NL>
\r	回車 <CR>
\t	製表 <Tab>
\\	反斜槓
\"	雙引號
\<xxx>	"xxx" 命名的特殊字元，例如 "\<C-W>" 代表 CTRL-W。用於對映，0x80 位元組被
        轉義。
	雙引號必須轉義: "<M-\">"。
	不要用 <Char-xxxx> 來得到 utf-8 字元，用上面提到的 \uxxxxx。

注意 "\xff" 儲存為位元組 255，在某些編碼中它是不合法的。使用 "\u00ff" 可以按照
'encoding' 的當前值儲存字元 255。

注意 "\000" 和 "\x00" 強制字串結束。


literal-string						*literal-string* *E115*
---------------
'string'		字串常數			*expr-'*

注意 使用的是單引號。

字串這裡按原義出現。不去掉反斜槓，它也沒有特殊含義。唯一的特例是兩個單引號代
表一個單引號。

單引號字串有助於模式的使用，因為反斜槓不再需要加倍。以下兩個命令等價: >
	if a =~ "\\s*"
	if a =~ '\s*'


option						*expr-option* *E112* *E113*
------
&option			選項值，如有存在，使用區域性值
&g:option		全域性選項值
&l:option		區域性選項值

例如: >
	echo "tabstop is " . &tabstop
	if &insertmode

這裡可以使用任何選項值。見 |options|。如果指定要使用區域性值，但不存在區域性於緩衝
區或區域性於視窗的選項，則還是使用全域性值。


register						*expr-register* *@r*
--------
@r			暫存器 'r' 的值

結果是命名暫存器的內容，以單個字串表達。換行符在需要時會被插入。要得到無名寄
存器的內容，使用 @" 或 @@。可用暫存器的相關解釋可見 |registers|。

如果用 '=' 暫存器，你得到表示式自身，而不是它計算的結果。用 |eval()| 來進行計
算。


nesting							*expr-nesting* *E110*
-------
(expr1)			巢狀表示式


environment variable					*expr-env*
--------------------
$VAR			環境變數

任何環境變數的字串值。如果該環境變數沒有定義，結果為空字串。
						*expr-env-expand*
注意 直接使用 $VAR 和使用 expand("$VAR") 有區別。直接使用的形式只能擴充套件當前
Vim 會話所知的環境變數。使用 expand() 會先嚐試當前 Vim 會話所知的環境變數，如
果不成功，則使用外殼擴充套件該變數。這會變慢，但可以用來擴充套件只有外殼知道的變數。
例如: >
	:echo $shell
	:echo expand("$shell")
前者可能不會回顯任何內容，後者會回顯 $shell 變數 (如果你的外殼支援的話)。


internal variable					*expr-variable*
-----------------
variable		內部變數
見下面的 |internal-variables|。


function call		*expr-function* *E116* *E118* *E119* *E120*
-------------
function(expr1, ...)	函式呼叫
見下面的 |functions|。


lambda expression				*expr-lambda* *lambda*
-----------------
{args -> expr1}		匿名函式表示式

匿名函式表示式建立一個新的無名函式，返回 |expr1| 的計算結果。匿名函式表示式和
|user-functions| 的區別如下:

1. 匿名函式表示式的本體是 |expr1| 而不是 |Ex| 命令序列。
2. 字首 "a:" 不用於引數。例如: >
	:let F = {arg1, arg2 -> arg1 - arg2}
	:echo F(5, 2)
<	3

引數可選。例如: >
	:let F = {-> 'error function'}
	:echo F()
<	error function
							*closure*
匿名函式表示式可能訪問外層變數和引數。這通常被稱為閉包。下例中匿名函式可以使用
存在於函式作用域的 "i" 和 "a:arg"。在函式返回後它們依然有效: >
	:function Foo(arg)
	:  let i = 3
	:  return {x -> x + i - a:arg}
	:endfunction
	:let Bar = Foo(4)
	:echo Bar(6)
<	5

另見 |:func-closure|。可以這樣來檢查匿名函式和閉包的支援: >
	if has('lambda')

示例如何在 |sort()|、|map()| 和 |filter()| 中使用匿名函式: >
	:echo map([1, 2, 3], {idx, val -> val + 1})
<	[2, 3, 4] >
	:echo sort([3,7,2,1,4], {a, b -> a - b})
<	[1, 2, 3, 4, 7]

匿名函式表示式也可用於通道、作業和定時器中: >
	:let timer = timer_start(500,
			\ {-> execute("echo 'Handler called'", "")},
			\ {'repeat': 3})
<	Handler called
	Handler called
	Handler called

注意 execute() 是如何用來執行 Ex 命令的。這不怎樣好看。


匿名函式表示式使用的內部名形如 '<lambda>42'。如果有關於某匿名函式的錯誤，可以
用下述命令檢視它的定義: >
	:function {'<lambda>42'}
另見: |numbered-function|

==============================================================================
3. 內部變數					*internal-variables* *E461*
內部變數的名字由字母、數字和 '_' 組成。但不能由數字開始。可以使用花括號，見
|curly-braces-names|。

內部變數通過 ":let" 命令建立 |:let|。
內部變數通過 ":unlet" 命令顯式刪除 |:unlet|。
使用非內部變數的名字或引用已經刪除的內部變數會產生錯誤。

變數有不同的名稱空間，根據附加的字首決定:

		     (無) 函式內: 區域性於函式；否則: 全域性
|buffer-variable|    b:	  區域性於當前緩衝區。
|window-variable|    w:	  區域性於當前視窗。
|tabpage-variable|   t:	  區域性於當前標籤頁。
|global-variable|    g:	  全域性。
|local-variable|     l:	  區域性於函式。
|script-variable|    s:	  區域性於 |:source| 的 Vim 指令碼。
|function-argument|  a:	  函式引數 (只限於函式內使用)。
|vim-variable|       v:	  Vim 預定義的全域性變數。

作用域本身可以用作 |Dictionary|。例如，要刪除所有區域性於指令碼的變數: >
	:for k in keys(s:)
	:    unlet s:[k]
	:endfor
<
						*buffer-variable* *b:var* *b:*
"b:" 開頭的變數名區域性於當前緩衝區。這樣，你可以為每個緩衝區定義不同的 "b:foo"
變數。這種變數在緩衝區被刪除時 (:bwipeout 或 :bdelete |:bdelete|) 同時被刪除。

預定義瞭如下的緩衝區區域性變數:
					*b:changedtick* *changetick*
b:changedtick	當前緩衝區的改變次數。每次改變都會遞增。撤銷命令在此情形下也被
		視作一次改變。這可用來在緩衝區發生改變時執行一些動作。比如: >
		    :if my_changedtick != b:changedtick
		    : let my_changedtick = b:changedtick
		    : call My_Update()
		    :endif
<		不可改變或刪除 b:changedtick 變數。

						*window-variable* *w:var* *w:*
"w:" 開頭的變數名區域性於當前視窗。視窗關閉時被刪除。

						*tabpage-variable* *t:var* *t:*
"t" 開始的變數名區域性於當前標籤頁。標籤頁關閉時，這些變數被刪除。{僅當編譯時加
入 |+windows| 特性才有效}

						*global-variable* *g:var* *g:*
函式內部，全域性變數可以通過 "g:" 訪問。如果不提供字首，會使用函式的區域性變數。在
其他地方，如果你想的話。也可以使用 "g:"。

						*local-variable* *l:var* *l:*
訪問函式的區域性變數無需任何字首。但如果你想要，可以使用 "l:"。不過，如果沒有
"l:" 字首，你可能會和保留的變數名衝突。例如 "count"。它本身指代 "v:count"。但
使用了 "l:count" 你就可以使用同名的區域性變數。


						*script-variable* *s:var*
Vim 腳本里，可以使用 "s:" 開頭的變數。它們不能在指令碼之外訪問，因而可以稱為區域性
於指令碼的變數。

它們可以用於:
- 載入指令碼時執行的命令
- 指令碼定義的函式
- 指令碼定義的自動命令
- 指令碼定義的函式和自動命令裡定義的函式和自動命令 (遞迴)
- 腳本里定義的使用者定義命令
但不能用在:
- 該指令碼載入的其它指令碼
- 對映
- 選單
- 等等

指令碼變數可以用來防止和全域性變數名的衝突。看看這個例子: >

	let s:counter = 0
	function MyCounter()
	  let s:counter = s:counter + 1
	  echo s:counter
	endfunction
	command Tick call MyCounter()

你可以從任何腳本里啟動 "Tick"，但那個腳本里的 "s:counter" 變數不會被改變，只有
在 "Tick" 定義所在指令碼的 "s:counter" 才會。

另一個完成相同功能的例子: >

	let s:counter = 0
	command Tick let s:counter = s:counter + 1 | echo s:counter

如果呼叫函式或者啟動使用者定義命令，指令碼變數的上下文設定為函式和命令定義所在的腳
本。

指令碼變數也可用於腳本里定義的函式裡定義的函式。例如: >

	let s:counter = 0
	function StartCounting(incr)
	  if a:incr
	    function MyCounter()
	      let s:counter = s:counter + 1
	    endfunction
	  else
	    function MyCounter()
	      let s:counter = s:counter - 1
	    endfunction
	  endif
	endfunction

呼叫 StartCounting() 時，定義 MyCounter() 函式或者遞增或者遞減計數器。不管
StartCounting() 在哪裡呼叫，s:counter 變數總可以在 MyCounter() 裡訪問。

如果相同的指令碼多次執行，使用的是同一個指令碼變數。只要 Vim 還在執行，就保持有
效。這可以用於維護計數: >

	if !exists("s:counter")
	  let s:counter = 1
	  echo "指令碼首次執行"
	else
	  let s:counter = s:counter + 1
	  echo "指令碼現在執行了 " . s:counter . " 次"
	endif

注意 這意味著 filetype 外掛不能為每個緩衝區提供不同的指令碼變數。這時應使用緩衝
區的區域性變數 |b:var|。


預定義的 Vim 變數:				*vim-variable* *v:var* *v:*

					*v:beval_col* *beval_col-variable*
v:beval_col	滑鼠指標所在的列號，即 |v:beval_lnum| 行中的位元組位置。
		僅當計算 'balloonexpr' 選項時有效。

					*v:beval_bufnr* *beval_bufnr-variable*
v:beval_bufnr	滑鼠指標所在的緩衝區號。僅當計算 'balloonexpr' 選項時有效。

					*v:beval_lnum* *beval_lnum-variable*
v:beval_lnum	滑鼠指標所在的行號。僅當計算 'balloonexpr' 選項時有效。

					*v:beval_text* *beval_text-variable*
v:beval_text	滑鼠指標所在或之後的文字。通常是一個單詞，可用於除錯 C 程式。
		此處用到 'iskeyword'，但也包括此位置之前的句號和 "->"。如果在
		']' 上，使用它之前的文字，包括匹配的 '[' 和它之前的單詞。如果
		在單行的可視區域上，使用高亮文字。
		僅當計算 'balloonexpr' 選項時有效。

					*v:beval_winnr* *beval_winnr-variable*
v:beval_winnr	滑鼠指標所在的視窗號。僅當計算 'balloonexpr' 選項時有效。首個
		視窗的編號為零 (這和多數需要視窗編號的地方不同)。

					*v:beval_winid* *beval_winid-variable*
v:beval_winid	滑鼠指標所在的視窗 ID |window-ID|。其它類同於 v:beval_winnr。

					*v:char* *char-variable*
v:char		計算 'formatexpr' 時使用的引數和用於帶 <expr> 的縮寫中輸入的字
		符 |:map-<expr>|。
		也用於 |InsertCharPre| 和 |InsertEnter| 事件。

			*v:charconvert_from* *charconvert_from-variable*
v:charconvert_from
		要轉換的檔案字元編碼名。只在計算 'charconvert' 選項時有效。

			*v:charconvert_to* *charconvert_to-variable*
v:charconvert_to
		轉換後的檔案字元編碼名。只在計算 'charconvert' 選項時有效。

					*v:cmdarg* *cmdarg-variable*
v:cmdarg	該變數有兩個目的:
		1. 檔案讀寫命令的額外引數。目前，它們包括 "++enc=" 和
		   "++ff="。該變數在檔案讀寫命令的自動命令事件啟用之前設定。開
		   頭有一個空格，以便直接把該變數附加到讀寫命令之後。注意: 這
		   裡不包括 "+cmd" 引數，因為它總要被執行的。
		2. 使用 ":hardcopy" 列印 PostScript 檔案時，":hardcopy" 命令的
		   引數。在 'printexpr' 裡用得到。

					*v:cmdbang* *cmdbang-variable*
v:cmdbang	檔案讀寫命令時，和 v:cmdarg 設定的時間類似。如果使用了 "!"，其
		值為 1，不然為 0。注意 它只能用於自動命令。使用者命令裡可以用
		|<bang>|。

				*v:completed_item* *completed_item-variable*
v:completed_item
		包含 |complete-items| 的 |Dictionary|，用於得到 |CompleteDone|
		之後的最近補全。如果補全失敗，|Dictionary| 為空。

					*v:count* *count-variable*
v:count		最近的普通模式命令使用的計數。在對映前可用於得到計數。只讀。
		例如: >
	:map _x :<C-U>echo "計數為 " . v:count<CR>
<		注意: <C-U> 是必要的，它刪除緊跟在計數之後 ':' 所給出的行範
		圍。
		如果有兩個計數，如 "3d2w"，它們進行相乘，如同命令列實際發生的
		那樣，等同於 "d6w"。
		也用於計算 'formatexpr' 選項。
		為了後向相容，這裡也可以用 "count"。

					*v:count1* *count1-variable*
v:count1	類似於 "v:count"，但沒有給出計數時，預設為 1。

						*v:ctype* *ctype-variable*
v:ctype		執行環境當前的字元 locale 設定。它使得 Vim 指令碼能得到當前的
		locale 編碼。技術細節: 這就是 LC_CTYPE 的值。如果沒有使用
		locale，其值為 "C"。
		該變數不能直接設定，請使用 |:language| 命令。
		見 |multi-lang|。

					*v:dying* *dying-variable*
v:dying		通常為零。如果捕獲到某個 "致命" 的 signal，設為 1。如果同時捕
		獲到多個 signal，其值相應增加。在自動命令裡可以用來檢查 Vim
		是否被異常終止。{僅限於 Unix}
		例如: >
	:au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif
<		備註: 如果 v:dying 為一而同時又捕捉到另一個致命的 signal，不執
		行 VimLeave 自動命令。

					*v:errmsg* *errmsg-variable*
v:errmsg	最近給出的錯誤資訊。該變數可以設定。
		例如: >
	:let v:errmsg = ""
	:silent! next
	:if v:errmsg != ""
	:  ... handle error
<		為了後向相容，這裡也可以用 "errmsg"。

					*v:errors* *errors-variable*
v:errors	assert 函式找到的錯誤，如 |assert_true()|。
		是一個字串列表。
		assert 函式在 assert 失敗後附加專案。
		要清空舊的結果: >
	:let v:errors = []
<		如果用非列表來設定 v:errors，assert 函式會把它變成空列表。

					*v:exception* *exception-variable*
v:exception	最近捕獲且沒有完成的例外的值。見 |v:throwpoint| 和
		|throw-variables|。
		例如: >
	:try
	:  throw "oops"
	:catch /.*/
	:  echo "caught" v:exception
	:endtry
<		輸出: "caught oops"。

					*v:false* *false-variable*
v:false		取值為零的數值。用於在 JSON 裡填入 "false"。見
		|json_encode()|。
		用於字串時會返回 "v:false"。 >
			echo v:false
<			v:false ~
		這樣 eval() 可以把該字串解析回相同的值。只讀。

					*v:fcs_reason* *fcs_reason-variable*
v:fcs_reason	啟用 |FileChangedShell| 事件的原因。
		可以在自動命令裡用來決定該做什麼和/或如何設定 v:fcs_choice。可
		能的值是:
			deleted		檔案不再存在
			conflict	檔案內容、模式或修改時間被改變，而緩衝
					區同時被修改
			changed		檔案內容被改變
			mode		檔案模式被改變
			time		檔案修改時間被改變

					*v:fcs_choice* *fcs_choice-variable*
v:fcs_choice	|FileChangedShell| 事件啟用後該做什麼。可以在自動命令裡用來告
		訴 Vim 如何處理涉及的緩衝區:
			reload		重新載入緩衝區 (如果檔案已刪除，不能工
					作)。
			ask		詢問使用者該做什麼，就像沒有自動命令一
					樣。不過，如果只有修改時間被改變，不做
					任何事。
			<空>		不做任何事。自動命令應該已經處理完畢。
		預設為空。如果使用別的 (非法的) 值，Vim 的行為就像它為空一樣。
		不會有警告資訊。

					*v:fname_in* *fname_in-variable*
v:fname_in	輸入檔名。在計算以下選項時合法:
			選項		用於 ~
			'charconvert'	要轉換的檔案
			'diffexpr'	原始檔案
			'patchexpr'	原始檔案
			'printexpr'	要列印的檔案
		|SwapExists| 裡設為交換檔名。

					*v:fname_out* *fname_out-variable*
v:fname_out	輸出檔名。只有在計算以下選項時才合法:
			選項		用於 ~
			'charconvert'	生成的轉換完成的檔案 (*)
			'diffexpr'	diff 的結果
			'patchexpr'	產生的補丁檔案
		(*) 如果用於為寫入命令進行轉換 (比如，":w file")，等價於
		v:fname_in。如果用於為讀入命令進行轉換 (比如，":e file")，它是
		一個臨時檔名，和 v:fname_in 不同。

					*v:fname_new* *fname_new-variable*
v:fname_new	檔案新版本的名字。只有在計算 'diffexpr' 的時候才有效。

					*v:fname_diff* *fname_diff-variable*
v:fname_diff	比較結果 (或補丁) 的檔名。只有在計算 'patchexpr' 的時候才有
		效。

					*v:folddashes* *folddashes-variable*
v:folddashes	用於 'foldtext': 反映關閉的摺疊的摺疊級別的連字元。
		|sandbox| 裡只讀。|fold-foldtext|

					*v:foldlevel* *foldlevel-variable*
v:foldlevel	用於 'foldtext': 關閉的摺疊的摺疊級別。
		|sandbox| 裡只讀。|fold-foldtext|

					*v:foldend* *foldend-variable*
v:foldend	用於 'foldtext': 關閉的摺疊的最後一行。
		|sandbox| 裡只讀。|fold-foldtext|

					*v:foldstart* *foldstart-variable*
v:foldstart	用於 'foldtext': 關閉的摺疊的第一行。
		|sandbox| 裡只讀。|fold-foldtext|

					*v:hlsearch* *hlsearch-variable*
v:hlsearch	用於指定搜尋高亮是否開啟的變數。只有在啟動 'hlsearch' 時它的設
		置才有意義，這需要 |+extra_search|。設定該變數為零相當
		|:nohlsearch| 命令，設定為一則相當於 >
			let &hlsearch = &hlsearch
<		備註 函式返回時復原其值。|function-search-undo|。

					*v:insertmode* *insertmode-variable*
v:insertmode	用於 |InsertEnter| 和 |InsertChange| 自動命令事件。取值:
			i	插入模式
			r	替換模式
			v	虛擬替換模式

						*v:key* *key-variable*
v:key		|Dictionary| 裡當前專案的鍵。只有在 |map()| 和 |filter()| 裡計
		算表示式時有效。
		只讀。

						*v:lang* *lang-variable*
v:lang		執行環境當前的訊息 locale 設定。它使得 Vim 指令碼能得到當前使用
		的語言。技術細節: 這就是 LC_MESSAGES 的值。該值和系統有關。
		該變數不能直接設定，請使用 |:language| 命令。
		它和 |v:ctype| 不同，因為訊息可能使用不同於字元編碼的語言。見
		|multi-lang|。

						*v:lc_time* *lc_time-variable*
v:lc_time	執行環境當前的時間訊息 locale 設定。它使得 Vim
		指令碼能得到當前使用的語言。技術細節: 這就是 LC_TIME 的值。
		該變數不能直接設定，請使用 |:language| 命令。見 |multi-lang|。

						*v:lnum* *lnum-variable*
v:lnum		'foldexpr' |fold-expr|、'formatexpr' 和 'indentexpr' 表示式中
		的行號和 'guitablevel' 和 'guitabtooltip' 中的標籤頁號。只有在
		計算這些表示式時才合法。在 |sandbox| 裡時只讀。

					*v:mouse_win* *mouse_win-variable*
v:mouse_win	用 |getchar()| 得到滑鼠點選時所在的視窗號。首個視窗的編號為
		1 ，就像 |winnr()| 那樣。如果那時沒有滑鼠點選，該值為零。

					*v:mouse_winid* *mouse_winid-variable*
v:mouse_winid	用 |getchar()| 得到滑鼠點選時所在的視窗 ID。如果那時沒有滑鼠點
		擊，該值為零。

					*v:mouse_lnum* *mouse_lnum-variable*
v:mouse_lnum	用 |getchar()| 得到滑鼠點選時所在的行號。這是文字行號，不是屏
		幕行號。如果那時沒有滑鼠點選，該值為零。

					*v:mouse_col* *mouse_col-variable*
v:mouse_col	用 |getchar()| 得到滑鼠點選時所在的列號。這是螢幕列號，就像
		|virtcol()| 那樣。如果那時沒有滑鼠點選，該值為零。

					*v:none* *none-variable*
v:none		空字串。用於在 JSON 裡填入空專案。見 |json_encode()|。
		用於數值時返回零。
		用於字串時會返回 "v:none"。 >
			echo v:none
<			v:none ~
		這樣 eval() 可以把該字串解析回相同的值。只讀。

					*v:null* *null-variable*
v:null		空字串。用於在 JSON 裡填入 "null"。見 |json_encode()|。
		用於數值時返回零。
		用於字串時會返回 "v:null"。 >
			echo v:null
<			v:null ~
		這樣 eval() 可以把該字串解析回相同的值。只讀。

					*v:oldfiles* *oldfiles-variable*
v:oldfiles	啟動時從 |viminfo| 檔案載入的檔名列表。Vim 記住的位置標記所
		在的就是這些檔案。列表長度的上限由 'viminfo' 選項的 ' 引數定義
		(預設是 100)。
		如果不用 |viminfo|，該列表為空。
		另見 |:oldfiles| 和 |c_#<|。
		此列表可修改，但並不影響之後 |viminfo| 檔案儲存什麼。同時，如
		果使用非字串的值，會有問題。
		{僅當編譯時加入 |+viminfo| 特性才有效}

						    *v:option_new*
v:option_new    選項的新值。執行 |OptionSet| 自動命令時有效。
						    *v:option_old*
v:option_old    選項的舊值。執行 |OptionSet| 自動命令時有效。
						    *v:option_type*
v:option_type   設定命令的作用域。執行 |OptionSet| 自動命令時有效。可能為
		"global" 或 "local"
					*v:operator* *operator-variable*
v:operator	普通模式給出的最近的操作符。除了 <g> 或 <z> 開始的命令是兩個
		字元外，這是單個字元。最好和 |v:prevcount| 和 |v:register| 一
		起使用。常常，先中止操作符等待模式，然後使用操作符，例如: >
			:omap O <Esc>:call MyMotion(v:operator)<CR>
<		直到輸入下一個操作符之前，該值保持不變。因此不要期待該值會為
		空。
		|:delete|、|:yank| 或其它 Ex 命令不改變 v:operator。
		只讀。

					*v:prevcount* *prevcount-variable*
v:prevcount	倒數第二次的普通模式命令使用的計數，也就是再上一個命令用的
		v:count 的值。可以用來先中止可視模式或操作符等待模式，然後使用
		計數。 >
			:vmap % <Esc>:call MyFilter(v:prevcount)<CR>
<		只讀。

					*v:profiling* *profiling-variable*
v:profiling	通常為零。開始用 ":profile start" 之後設為一。見 |profiling|。

					*v:progname* *progname-variable*
v:progname	包含 Vim 啟動時使用的名字 (路徑已被去掉)。可以用來為 |view|、
		|evim| 等符號連結到 Vim 的名字提供特殊的設定。
		只讀。

					*v:progpath* *progpath-variable*
v:progpath	包含 Vim 啟動時使用的命令，帶路徑。可用於通過 |--remote-expr|
		給 Vim 伺服器發訊息。
		要得到完整路徑: >
			echo exepath(v:progpath)
<		這樣就會把相對路徑擴充套件為完整路徑，從而可在 `:cd` 後使用。假定
		用 "./vim" 啟動，返回 "/home/user/path/to/vim/src/vim"。
		MS-Windows 上的可執行檔案可能叫做 "vim.exe"，但 v:progpath 中
		不會帶上 ".exe"。
		只讀。

					*v:register* *register-variable*
v:register	當前的普通模式命令使用的暫存器名字 (不管該命令是否使用寄存
		器)，也用於當前執行的普通模式的對映 (用於其中的接受暫存器的自
		定義命令)。
		如果沒有特殊指定，使用預設暫存器 '"'。除非 'clipboard' 包含
		"unamed" 或 "unamedplus"，此時它為 '*' 或 '+'。
		另見 |getreg()| 和 |setreg()|

					*v:scrollstart* *scrollstart-variable*
v:scrollstart	指示使螢幕上滾的指令碼或函式的字串。只有在原來為空時才設定，因
		此只記住第一個原因。如果來自輸入的命令，設為 "Unknown"。
		可以用來發現你的指令碼為什麼產生 hit-enter 提示。

					*v:servername* *servername-variable*
v:servername	如果有的話，註冊過的 |x11-clientserver| 名字。
		只讀。


v:searchforward			*v:searchforward* *searchforward-variable*
		搜尋方向: 正向搜尋後為 1，反向搜尋後為 0。直接設定最近搜尋模式
		會復位此值為正向，見 |quote/|。
		注意 從函式返回時該值被複原 |function-search-undo|。
		可讀寫。

					*v:shell_error* *shell_error-variable*
v:shell_error	最近一次外殼命令的返回值。如果非零，最近一次外殼命令有錯。如果
		為零，則該命令成功返回。這隻有在外殼把錯誤程式碼返回給 Vim 的時
		候才工作。-1 通常用來告知該命令無法執行。只讀。
		例如: >
	:!mv foo bar
	:if v:shell_error
	:  echo '不能把 "foo" 換名為 "bar"!'
	:endif
<		為了後向相容，這裡也可以用 "shell_error"。

					*v:statusmsg* *statusmsg-variable*
v:statusmsg	最近給出的狀態訊息。可以設定該變數。

					*v:swapname* *swapname-variable*
v:swapname	只有在執行 |SwapExists| 自動命令時才合法: 找到的交換檔名。只
		讀。

					*v:swapchoice* *swapchoice-variable*
v:swapchoice	|SwapExists| 自動命令可以設定此值，以選擇如何處理已有交換檔案:
			'o'	以只讀方式開啟
			'e'	仍然編輯
			'r'	恢復
			'd'	刪除交換檔案
			'q'	退出
			'a'	中止
		該值應是單個字元的字串。如果為空，使用者會被詢問，就像沒有
		SwapExists 自動命令那樣。預設為空。

					*v:swapcommand* *swapcommand-variable*
v:swapcommand	開啟檔案後執行的普通模式命令。可以用於 |SwapExists| 自動命令，
		用以讓另一個 Vim 開啟檔案並跳轉到合適的位置。例如，要跳轉到某
		標籤，用的值是 ":tag tagname\r"。":edit +cmd file" 用的值是
		":cmd\r"。

				*v:t_TYPE* *v:t_bool* *t_bool-variable*
v:t_bool	布林的型別值。只讀。見: |type()|
					*v:t_channel* *t_channel-variable*
v:t_channel	通道的型別值。只讀。見: |type()|
					*v:t_dict* *t_dict-variable*
v:t_dict	字典的型別值。只讀。見: |type()|
					*v:t_float* *t_float-variable*
v:t_float	浮點數的型別值。只讀。見: |type()|
					*v:t_func* *t_func-variable*
v:t_func	函式引用的型別值。只讀。見: |type()|
					*v:t_job* *t_job-variable*
v:t_job		作業的型別值。只讀。見: |type()|
					*v:t_list* *t_list-variable*
v:t_list	列表的型別值。只讀。見: |type()|
					*v:t_none* *t_none-variable*
v:t_none	None 的型別值。只讀。見: |type()|
					*v:t_number* *t_number-variable*
v:t_number	數值的型別值。只讀。見: |type()|
					*v:t_string* *t_string-variable*
v:t_string	字串的型別值。只讀。見: |type()|

				*v:termresponse* *termresponse-variable*
v:termresponse	使用 |t_RV| termcap 專案返回的終端的轉義序列。Vim 收到 ESC [
		或者 CSI 開始，以一個 'c' 結束，並且其間只包含數字，';' 和 '.'
		的轉義序列的時候，會設定該值。
		如果設定該選項，會啟用 TermResponse 自動命令事件，這樣你就可以
		對終端的應答做出反應。
		新的 xterm 的應答是: "<Esc>[ Pp ; Pv ; Pc c"。 Pp 是終端型別:
		0 代表 vt100，而 1 代表 vt220。 Pv 是補丁號 (因為這是 patch 95
		引入的，補丁號應該總是 95 會更高)。Pc 總是零。
		{僅當編譯時加入 |+termresponse| 特性才有效}

					*v:testing* *testing-variable*
v:testing	必須在 `test_garbagecollect_now()` 之前設定。
		另外，設定時，在 2 秒內不會顯示特定的錯誤資訊 (例如
		"'dictionary' option is empty")

				*v:this_session* *this_session-variable*
v:this_session	最近載入或者儲存的會話檔案的檔名 |:mksession|。可以設定該變
		量。如果沒有儲存過會話檔案，該變數為空。
		為了後向相容，這裡也可以用 "this_session"。

					*v:throwpoint* *throwpoint-variable*
v:throwpoint	最近捕獲且未完成的例外的丟擲位置。輸入的命令不會設定此變數。另
		見 |v:exception| 和 |throw-variables|。
		例如: >
	:try
	:  throw "oops"
	:catch /.*/
	:  echo "Exception from" v:throwpoint
	:endtry
<		輸出: "Exception from test.vim, line 2"

					*v:true* *true-variable*
v:true		取值為一的數值。用於在 JSON 裡填入 "true"。見
		|json_encode()|。
		用於字串時會返回 "v:true"。 >
			echo v:true
<			v:true ~
		這樣 eval() 可以把該字串解析回相同的值。只讀。

						*v:val* *val-variable*
v:val		|List| 或 |Dictionary| 當前專案的值。只有在計算 |map()| 和
		|filter()| 裡的表示式時才有效。只讀。

					*v:version* *version-variable*
v:version	Vim 的版本號: 主版本號乘以 100 加上副版本號。5.0 版本對應的是
		500。5.1 版本 (5.01) 則是 501。只讀。為了後向相容，這裡也可以
		用 "version"。
		用 |has()| 可以檢查是否包含某補丁，例如: >
			if has("patch-7.4.123")
<		注意 補丁號和版本有關，5.0 和 5.1 版本都有補丁號 123，但完全不
		同。

				*v:vim_did_enter* *vim_did_enter-variable*
v:vim_did_enter	直到絕大部分的初始化工作做完之前保持為零。在 |VimEnter| 自動命
		令剛剛啟用之前，設為一。

					*v:warningmsg* *warningmsg-variable*
v:warningmsg	最近給出的警告訊息。該變數可以設定。

					*v:windowid* *windowid-variable*
v:windowid	執行基於 X11 的任何 GUI，或者在終端執行且 Vim 連線到 X 伺服器
		(|-X|) 時，給出視窗號。
		執行 MS-Windows GUI 時，給出視窗的控制代碼。
		否則該值為零。
		注意: Vim 內部的視窗請用 |winnr()| 或 |win_getid()|，見
		|window-ID|。

==============================================================================
4. 內建函式						*functions*

|function-list| 提供了按功能分組的一個函式列表。

(在函式名上使用 CTRL-] 跳轉到完整的功能說明。)

用法				結果	描述	~

abs({expr})			浮點或數值  {expr} 的絕對值
acos({expr})			浮點	{expr} 的反餘弦值
add({list}, {item})		列表	在 |List| {list} 最後附加 {item}
and({expr}, {expr})		數值	按位與
append({lnum}, {string})	數值	在第 {lnum} 行下附加字串 {string}
append({lnum}, {list})		數值	在第 {lnum} 行下附加行 {list}
argc()				數值	引數列表的檔案數目
argidx()			數值	引數列表的當前索引
arglistid([{winnr} [, {tabnr}]]) 數值	引數列表的 id
argv({nr})			字串	引數列表第 {nr} 個引數
argv()				列表	引數列表
assert_equal({exp}, {act} [, {msg}])
				無	斷言 {exp} 等於 {act}
assert_exception({error} [, {msg}])
				空	斷言 v:exception 中有 {error}
assert_fails({cmd} [, {error}])	空	斷言 {cmd} 失敗
assert_false({actual} [, {msg}])
				空	斷言 {actual} 為假
assert_inrange({lower}, {upper}, {actual} [, {msg}])
				空	斷言 {actual} 在指定範圍內
assert_match({pat}, {text} [, {msg}])
				空	斷言 {pat} 匹配 {text}
assert_notequal({exp}, {act} [, {msg}])
				空	斷言 {exp} 不等於 {act}
assert_notmatch({pat}, {text} [, {msg}])
				空	斷言 {pat} 不匹配 {text}
assert_report({msg})		空	報告一個測試失敗
assert_true({actual} [, {msg}])	空	斷言 {actual} 為真
asin({expr})			浮點	{expr} 的反正弦值
atan({expr})			浮點	{expr} 的反正切值
atan2(`{expr}, {expr})		浮點	{expr1} / {expr2} 的反正切值
balloon_show({msg})		空	在氣泡內顯示{msg}
browse({save}, {title}, {initdir}, {default})
				字串	啟動檔案請求視窗
browsedir({title}, {initdir})	字串	啟動目錄請求視窗
bufexists({expr})		數值	如果緩衝區 {expr} 存在則為 |TRUE|
buflisted({expr})		數值	如果緩衝區 {expr} 在列表內則為 |TRUE|
bufloaded({expr})		數值	如果緩衝區 {expr} 被載入則為 |TRUE|
bufname({expr})			字串	緩衝區 {expr} 的名字
bufnr({expr} [, {create}])	數值	緩衝區 {expr} 的編號
bufwinid({expr})		數值	緩衝區 {expr} 的視窗 ID
bufwinnr({expr})		數值	緩衝區 {expr} 的視窗號
byte2line({byte})		數值	第 {byte} 個位元組所在的行號
byteidx({expr}, {nr})		數值	{expr} 裡第 {nr} 個字元的位元組位置
byteidxcomp({expr}, {nr})	數值	{expr} 裡第 {nr} 個字元的位元組位置
call({func}, {arglist} [, {dict}])
				可變	呼叫函式 {func}，使用引數 {arglist}
ceil({expr})			浮點	{expr} 向上取整
ch_canread({handle})		數值	檢查是否有可讀的內容
ch_close({handle})		空	關閉 {handle}
ch_close_in({handle})		空	關閉 {handle} 的 in 部分
ch_evalexpr({handle}, {expr} [, {options}])
				可變	在 JSON {handle} 上執行 {expr}
ch_evalraw({handle}, {string} [, {options}])
				可變	在原始 {handle} 上執行 {string}
ch_getbufnr({handle}, {what})	數值	獲得 {handle}/{what} 的緩衝區號
ch_getjob({channel})		作業	獲得 {channel} 的相關作業
ch_info({handle})		字串	有關通道 {handle} 的資訊
ch_log({msg} [, {handle}])	空	在通道日誌檔案中寫入 {msg}
ch_logfile({fname} [, {mode}])	空	開始記錄通道活動
ch_open({address} [, {options}])
				通道	開啟到 {address} 的通道
ch_read({handle} [, {options}]) 字串	從 {handle} 讀取
ch_readraw({handle} [, {options}])
				字串	從 {handle} 讀取原始格式
ch_sendexpr({handle}, {expr} [, {options}])
				可變	在 JSON {handle} 上傳送 {expr}
ch_sendraw({handle}, {string} [, {options}])
				可變	在原始 {handle} 上傳送 {string}
ch_setoptions({handle}, {options})
				空	設定 {handle} 的選項
ch_status({handle} [, {options}])
				字串	通道 {handle} 的狀態
changenr()			數值	當前改變號
char2nr({expr}[, {utf8}])	數值	{expr} 裡第一個字串的 ASCII/UTF8 值
cindent({lnum})			數值	第 {lnum} 行的 C 縮排
clearmatches()			無	清除所有的匹配
col({expr})			數值	游標或位置標記的列號
complete({startcol}, {matches}) 無	設定插入模式補全
complete_add({expr})		數值	增加補全匹配
complete_check()		數值	補全時檢查輸入的鍵
confirm({msg} [, {choices} [, {default} [, {type}]]])
				數值	使用者選擇的序號
copy({expr})			可變	提供 {expr} 的淺備份
cos({expr})			浮點	{expr} 的餘弦值
cosh({expr})			浮點	{expr} 的雙曲餘弦值
count({list}, {expr} [, {ic} [, {start}]])
				數值	計算 {list} 裡有多少個 {expr}
cscope_connection([{num} , {dbpath} [, {prepend}]])
				數值	檢查 cscope 連線是否存在
cursor({lnum}, {col} [, {off}])
				數值	移動游標到 {lnum}，{col}，{off}
cursor({list})			數值	移動游標到 {list} 裡的位置
deepcopy({expr} [, {noref}])	可變	提供 {expr} 的完整備份
delete({fname} [, {flags}])	數值	刪除檔案或目錄 {fname}
did_filetype()			數值	用過 FileType 自動命令事件則為 |TRUE|
diff_filler({lnum})		數值	{lnum} 行之上的 diff 填充行數
diff_hlID({lnum}, {col})	數值	{lnum}/{col} 位置的 diff 高亮
empty({expr})			數值	如果 {expr} 為空則為 |TRUE|
escape({string}, {chars})	字串	在 {string} 裡用 '\' 轉義 {chars}
eval({string})			可變	計算 {string}，返回結果
eventhandler()			數值	如果在事件處理中則為 |TRUE|
executable({expr})		數值	如果可執行檔案 {expr} 存在則為 1
execute({command})		字串	執行 {command} 並取得輸出結果
exepath({expr})			字串	命令 {expr} 的完整路徑
exists({expr})			數值	如果 {expr} 存在則為 |TRUE|
extend({expr1}, {expr2} [, {expr3}])
				列表/字典 把 {expr2} 裡的專案插入 {expr1}
exp({expr})			浮點	{expr} 的指數函式值
                                        (譯者注: 以 e 為底)
expand({expr} [, {nosuf} [, {list}]])
				可變	擴充套件 {expr} 裡的特殊關鍵字
feedkeys({string} [, {mode}])	數值	給預輸入緩衝區加入鍵序列
filereadable({file})		數值	如果 {file} 是個可讀檔案則為 |TRUE|
filewritable({file})		數值	如果 {file} 是個可寫檔案則為 |TRUE|
filter({expr1}, {expr2})	列表/字典 刪除 {expr1} 裡 {expr2} 為 0 的專案
finddir({name}[, {path}[, {count}]])
				字串	在 {path} 裡尋找目錄 {name}
findfile({name}[, {path}[, {count}]])
				字串	在 {path} 裡尋找檔案 {name}
float2nr({expr})		數值	轉換浮點數 {expr} 為數值
floor({expr})			浮點	{expr} 向下取整
fmod({expr1}, {expr2})		浮點	{expr1} / {expr2} 的浮點餘數
fnameescape({fname})		字串  轉義 {fname} 中的特殊字元
fnamemodify({fname}, {mods})	字串	修改檔名
foldclosed({lnum})		數值	{lnum} 所在摺疊的首行，如果是關閉的話
foldclosedend({lnum})		數值	{lnum} 所在摺疊的末行，如果是關閉的話
foldlevel({lnum})		數值	{lnum} 的摺疊級別
foldtext()			字串	關閉的摺疊顯示的行
foldtextresult({lnum})		字串	{lnum} 所在的關閉的摺疊的文字
foreground()			數值	把 Vim 視窗帶到前臺
funcref({name} [, {arglist}] [, {dict}])
				函式引用  函式 {name} 的引用
function({name} [, {arglist}] [, {dict}])
				函式引用  函式 {name} 的命名引用
garbagecollect([{atexit}])	無	釋放記憶體，打破迴圈引用
get({list}, {idx} [, {def}])	可變	得到 {list} 或 {def} 的專案 {idx}
get({dict}, {key} [, {def}])	可變	得到 {dict} 或 {def} 的專案 {idx}
get({func}, {what})		可變	得到函式引用/偏函式 {func} 的屬性
getbufinfo([{expr}])		列表	緩衝區資訊
getbufline({expr}, {lnum} [, {end}])
				列表	緩衝區 {expr} 第 {lnum} 到 {end} 行
getbufvar({expr}, {varname} [, {def}])
				可變	緩衝區 {expr} 的變數 {varname}
getchar([expr])			數值	讓使用者輸入一個字元
getcharmod()			數值	最近輸入字元的修飾符
getcharsearch()			字典	最近字元搜尋選項
getcmdline()			字串	返回當前命令列
getcmdpos()			數值	返回命令列的游標位置
getcmdtype()			字串	返回當前命令列型別
getcmdwintype()			字串	返回當前命令列視窗型別
getcompletion({pat}, {type} [, {filtered}])
				列表	命令列補全匹配列表
getcurpos()			列表	游標位置
getcwd([{winnr} [, {tabnr}]])	字串	當前工作目錄
getfontname([{name}])		字串	使用的字型名
getfperm({fname})		字串	檔案 {fname} 的檔案許可權
getfsize({fname})		數值	位元組計算的檔案 {fname} 大小
getftime({fname})		數值	檔案的最新修改時間
getftype({fname})		字串	檔案 {fname} 型別的描述
getline({lnum})			字串	當前緩衝區的第 {lnum} 行
getline({lnum}, {end})		列表	當前緩衝區第 {lnum} 到 {end} 行
getloclist({nr}[, {what}])	列表	位置列表專案的列表
getmatches()			列表	當前匹配的列表
getpid()			數值	Vim 的程序號
getpos({expr})			列表	游標、位置標記等的位置
getqflist([{what}])		列表	quickfix 專案的列表
getreg([{regname} [, 1 [, {list}]]])
				字串/列表	暫存器內容
getregtype([{regname}])		字串	暫存器型別
gettabinfo([{expr}])		列表	標籤頁列表
gettabvar({nr}, {varname} [, {def}])
				可變	{tabnr} 標籤頁的 {varname} 變數
gettabwinvar({tabnr}, {winnr}, {name} [, {def}])
				可變	{tabnr} 標籤頁 {winnr} 視窗的 {name}
getwininfo([{winid}])		列表	視窗列表
getwinposx()			數值	GUI Vim 視窗以畫素計的 X 座標
getwinposy()			數值	GUI Vim 視窗以畫素計的 Y 座標
getwinvar({nr}, {varname} [, {def}])
				可變	視窗 {expr} 的變數 {varname}
glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])
				可變	擴充套件 {expr} 裡的檔案萬用字元
glob2regpat({expr})		字串	轉化 glob 模式為搜尋模式
globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
				字串	在 {path} 所有目錄下執行 glob({expr})
has({feature})			數值	如果支援特性 {feature} 則為 |TRUE|
has_key({dict}, {key})		數值	如果 {dict} 有專案 {key} 則為 |TRUE|
haslocaldir([{winnr} [, {tabnr}]])
				數值	如果當前視窗執行過 |:lcd| 則為 |TRUE|
hasmapto({what} [, {mode} [, {abbr}]])
				數值	如果 {what} 的對映存在則為 |TRUE|
histadd({history},{item})	字串	在歷史裡增加專案
histdel({history} [, {item}])	字串	從歷史裡刪除專案
histget({history} [, {index}])	字串	得到歷史的第 {index} 項
histnr({history})		數值	歷史裡最高的專案號
hlexists({name})		數值	如果高亮組 {name} 存在則為 |TRUE|
hlID({name})			數值	高亮組 {name} 的語法 ID
hostname()			字串	Vim 執行的機器名字
iconv({expr}, {from}, {to})	字串	轉換 {expr} 的編碼
indent({lnum})			數值	第 {lnum} 行的縮排
index({list}, {expr} [, {start} [, {ic}]])
				數值	{list} 列表裡出現 {expr} 的專案的索引
input({prompt} [, {text} [, {completion}]])
				字串	從使用者得到輸入
inputdialog({prompt} [, {text} [, {completion}]]])
				字串  類似於 input()，但使用 GUI 對話方塊
inputlist({textlist})		數值	讓使用者從選擇列表裡挑選
inputrestore()			數值	恢復預輸入
inputsave()			數值	儲存和清除預輸入
inputsecret({prompt} [, {text}]) 字串  類似於 input()，但隱藏文字
insert({list}, {item} [, {idx}]) 列表	在 {list} 裡插入 {item} [{idx} 之前]
invert({expr})			數值	按位取反
isdirectory({directory})	數值	如果 {directory} 是目錄則為 |TRUE|
islocked({expr})		數值	如果 {expr} 被鎖住則為 |TRUE|
isnan({expr})			數值	如果 {expr} 為 NaN 則為 |TRUE|
items({dict})			列表	{dict} 裡的鍵-值組對
job_getchannel({job})		通道	獲取 {job} 的通道控制代碼
job_info({job})			字典	獲取 {job} 的資訊
job_setoptions({job}, {options}) 無	設定 {job} 選項
job_start({command} [, {options}])
				作業	啟動作業
job_status({job})		字串	獲取 {job} 的狀態
job_stop({job} [, {how}])	數值	停止 {job}
join({list} [, {sep}])		字串	連線 {list} 的專案成為一個字串
js_decode({string})		可變	解碼 JS 風格的 JSON
js_encode({expr})		字串	編碼 JS 風格的 JSON
json_decode({string})		可變	解碼 JSON
json_encode({expr})		字串	編碼 JSON
keys({dict})			列表	{dict} 的所有鍵
len({expr})			數值	{expr} 的長度
libcall({lib}, {func}, {arg})	字串	呼叫庫 {lib} 的函式 {func}，使用引數
					{arg}
libcallnr({lib}, {func}, {arg})	數值	同上，但返回數值
line({expr})			數值	游標所在、末行或者位置標記所在的行號
line2byte({lnum})		數值	行 {lnum} 的位元組位置
lispindent({lnum})		數值	行 {lnum} 的 Lisp 縮排
localtime()			數值	當前時間
log({expr})			浮點	{expr} 的自然對數 (以 e 為底)
log10({expr})			浮點	{expr} 以 10 為底的對數
luaeval({expr}[, {expr}])	可變	執行 |Lua| 表示式
map({expr1}, {expr2})		列表/字典  {expr1} 的每個專案改變為 {expr2}
maparg({name}[, {mode} [, {abbr} [, {dict}]]])
				字串/字典
					模式 {mode} 的對映 {name} 的右手邊
mapcheck({name}[, {mode} [, {abbr}]])
				字串	檢查匹配 {name} 的對映
match({expr}, {pat}[, {start}[, {count}]])
				數值	{expr} 裡 {pat} 的匹配位置
matchadd({group}, {pattern}[, {priority}[, {id} [, {dict}]]])
				數值	用 {group} 高亮 {pattern}
matchaddpos({group}, {pos}[, {priority}[, {id}[, {dict}]]])
				數值	{group} 的高亮位置
matcharg({nr})			列表	|:match| 的引數
matchdelete({id})		數值	刪除 {id} 指定的匹配
matchend({expr}, {pat}[, {start}[, {count}]])
				數值	{expr} 裡 {pat} 的結束位置
matchlist({expr}, {pat}[, {start}[, {count}]])
				列表	{expr} 裡 {pat} 的匹配和子匹配
matchstr({expr}, {pat}[, {start}[, {count}]])
				字串	{expr} 裡 {pat} 的第 {count} 個匹配文
					本
matchstrpos({expr}, {pat}[, {start}[, {count}]])
				列表	{expr} 裡 {pat} 的第 {count} 個匹配
max({expr})			數值	{expr} 的專案的最大值
min({expr})			數值	{expr} 的專案的最小值
mkdir({name} [, {path} [, {prot}]])
				數值	建立目錄 {name}
mode([expr])			字串	當前編輯模式
mzeval({expr})			可變	計算 |MzScheme| 表示式
nextnonblank({lnum})		數值	第一個 >= {lnum} 的非空白行的行號
nr2char({expr}[, {utf8}])	字串	ASCII/UTF8 值為 {expr} 的單個字元
or({expr}, {expr})		數值	按位或
pathshorten({expr})		字串	縮短路徑裡的目錄名
perleval({expr})		可變	計算 |Perl| 表示式
pow({x}, {y})			浮點	{x} 的 {y} 次方
prevnonblank({lnum})		數值	最後一個 <= {lnum} 的非空白行的行號
printf({fmt}, {expr1}...)	字串	排版文字
pumvisible()			數值	彈出視窗是否可見
pyeval({expr})			可變	計算 |Python| 表示式
py3eval({expr})			可變	計算 |python3| 表示式
pyxeval({expr})			可變	計算 |python_x| 表示式
range({expr} [, {max} [, {stride}]])
				列表	從 {expr} 到 {max} 的序列
readfile({fname} [, {binary} [, {max}]])
				列表	得到檔案 {fname} 的行列表
reltime([{start} [, {end}]])	列表	得到時間值
reltimefloat({time})		浮點數	把時間值轉化為浮點數
reltimestr({time})		字串	把時間值轉化為字串
remote_expr({server}, {string} [, {idvar} [, {timeout}]])
				字串	傳送表示式
remote_foreground({server})	數值	把 Vim 伺服器帶到前臺
remote_peek({serverid} [, {retvar}])
				數值	檢查應答字串
remote_read({serverid} [, {timeout}])
				字串	讀入應答字串
remote_send({server}, {string} [, {idvar}])
				字串	傳送鍵序列
remote_startserver({name})	空	成為伺服器 {name}
remove({list}, {idx} [, {end}])  可變	從 {list} 裡刪除專案 {idx}-{end}
remove({dict}, {key})		可變	從 {dict} 裡刪除專案 {key}
rename({from}, {to})		數值	換名 (移動) 檔案，從 {from} 到 {to}
repeat({expr}, {count})		字串	重複 {expr} {count} 次
resolve({filename})		字串	解析快捷方式對應的檔名
reverse({list})			列表	反轉 {list}，直接修改 {list}
round({expr})			浮點	{expr} 四捨五入
screenattr({row}, {col})	數值	當前游標位置的屬性
screenchar({row}, {col})	數值	當前游標所在的字元
screencol()			數值	當前游標列
screenrow()			數值	當前游標行
search({pattern} [, {flags} [, {stopline} [, {timeout}]]])
				數值	搜尋 {pattern}
searchdecl({name} [, {global} [, {thisblock}]])
				數值	搜尋變數宣告
searchpair({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
				數值	搜尋 start/end 對的另一側
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
				列表	搜尋 start/end 隊的另一側
searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])
				列表	搜尋 {pattern}
server2client({clientid}, {string})
				數值	傳送應答字串
serverlist()			字串	得到可用的伺服器列表
setbufvar({expr}, {varname}, {val})
				空	設定緩衝區 {expr} 的 {varname} 為
					{val}
setcharsearch({dict})		字典	從 {dict} 設定字元搜尋選項
setcmdpos({pos})		數值	設定命令列的游標位置
setfperm({fname}, {mode})	數值	設定 {fname} 檔案許可權為 {mode}
setline({lnum}, {line})		數值	設定第 {lnum} 行的內容為 {line}
setloclist({nr}, {list}[, {action}[, {what}]])
				數值	用 {list} 修改位置列表
setmatches({list})		數值	還原匹配列表
setpos({expr}, {list})		數值	設定 {expr} 的位置為 {list}
setqflist({list}[, {action}[, {what}]])
				數值	用 {list} 修改 quickfix 列表
setreg({n}, {v}[, {opt}])	數值	設定暫存器的值和型別
settabvar({nr}, {varname}, {val}) 無	設定標籤頁 {nr} 的 {varname} 變數為
					{val}
settabwinvar({tabnr}, {winnr}, {varname}, {val})
				無	設定標籤頁 {tabnr} 視窗 {winnr} 的
					{varname} 變數為 {val}
setwinvar({nr}, {varname}, {val}) 空	設定視窗 {expr} 的 {varname} 為 {val}
sha256({string})		字串	{string} 的 SHA256 校驗碼
shellescape({string} [, {special}])
				字串	轉義 {string} 以便用作外殼命令的引數
shiftwidth()			數值	'shiftwidth' 的有效值
simplify({filename})		字串	儘可能簡化檔名
sin({expr})			浮點	{expr} 的正弦值
sinh({expr})			浮點	{expr} 的雙曲正弦值
sort({list} [, {func} [, {dict}]])
				列表	排序 {list}，用比較函式 {func}
soundfold({word})		字串	按發音摺疊 {word}
spellbadword()			字串	游標所在的拼寫錯誤的單詞
spellsuggest({word} [, {max} [, {capital}]])
				列表	拼寫建議
split({expr} [, {pat} [, {keepempty}]])
				列表	從 {pat} 分割的 {expr} 裡構造 |List|
sqrt({expr})			浮點	{expr} 的平方根
str2float({expr})		浮點	轉換字串為浮點數
str2nr({expr} [, {base}])	數值	把字串轉換為數值
strchars({expr} [, {skipcc}])	數值	{expr} 字串的字元長度
strcharpart({str}, {start}[, {len}])
				字串	{str} 從 {start} 開始的 {len} 個字元
strdisplaywidth({expr} [, {col}]) 數值	{expr} 字串的顯示長度
strftime({format}[, {time}])	字串	指定格式的時間
strgetchar({str}, {index})	數值	從 {str} 取得字元 {index}
stridx({haystack}, {needle}[, {start}])
				數值	{haystack} 裡 {needle} 的位置
string({expr})			字串	{expr} 值得字串表示
strlen({expr})			數值	字串 {expr} 的長度
strpart({str}, {start}[, {len}])
				字串	{str} 從 {start} 開始的 {len} 個位元組
strridx({haystack}, {needle} [, {start}])
				數值	{haystack} 裡最後一個 {needle} 的位置
strtrans({expr})		字串	翻譯字串，使之可以顯示
strwidth({expr})		數值	{expr} 字串的顯示單元長度
submatch({nr}[, {list}])	字串/列表
					":s" 或 substitute() 的特定匹配
substitute({expr}, {pat}, {sub}, {flags})
				字串	{expr} 裡的所有 {pat} 被 {sub} 替代
synID({lnum}, {col}, {trans})	數值	{lnum} 行 {col} 列所在的語法 ID
synIDattr({synID}, {what} [, {mode}])
				字串	syntax ID {synID} 的 {what} 屬性
synIDtrans({synID})		數值	{synID} 經過翻譯的語法 ID
synconcealed({lnum}, {col})	列表    關於隱藏的資訊
synstack({lnum}, {col})		列表	{lnum} 行 {col} 列所在的語法 ID 堆疊
system({expr} [, {input}])	字串	外殼命令/過濾 {expr} 的輸出
systemlist({expr} [, {input}])	列表	外殼命令/過濾 {expr} 的輸出
tabpagebuflist([{arg}])		列表	標籤頁裡的緩衝區號列表
tabpagenr([{arg}])		數值	當前或最後標籤頁的編號
tabpagewinnr({tabarg}[, {arg}]) 數值	標籤頁裡當前視窗的編號
taglist({expr}[, {filename}])	列表	匹配 {expr} 的標籤列表
tagfiles()			列表	使用的標籤檔案
tan({expr})			浮點	{expr} 的正切值
tanh({expr})			浮點	{expr} 的雙曲正切值
tempname()			字串	臨時檔案的檔名
test_alloc_fail({id}, {countdown}, {repeat})
				空	使記憶體分配失敗
test_autochdir()		空	系統啟動中啟動 'autochdir'
test_garbagecollect_now()	空	為測試用，立即釋放記憶體
test_ignore_error({expr})	空	忽略特定的錯誤
test_null_channel()		通道	用作測試的空值
test_null_dict()		字典	用作測試的空值
test_null_job()			作業	用作測試的空值
test_null_list()		列表	用作測試的空值
test_null_partial()		函式引用	用作測試的空值
test_null_string()		字串	用作測試的空值
test_override({expr}, {val})    空	Vim 內部覆蓋用作測試
test_settime({expr})		空	用作測試的當前時間
timer_info([{id}])		列表	定時器資訊
timer_pause({id}, {pause})	空	暫停或繼續定時器
timer_start({time}, {callback} [, {options}])
				數值	新建定時器
timer_stop({timer})		空	停止定時器
timer_stopall()			空	停止所有定時器
tolower({expr})			字串	字串 {expr} 變為小寫
toupper({expr})			字串	字串 {expr} 變為大寫
tr({src}, {fromstr}, {tostr})	字串	把 {src} 裡的 {fromstr} 字元翻譯為
					{tostr} 字元
trunc({expr})			浮點	浮點數 {expr} 截斷小數點
type({name})			數值	變數 {name} 的型別
undofile({name})		字串	對應 {name} 的撤銷檔名
undotree()			列表	撤銷檔案樹
uniq({list} [, {func} [, {dict}]])
				列表	從列表中刪除相鄰的重複項
values({dict})			列表	{dict} 的所有值
virtcol({expr})			數值	游標或位置標記的螢幕列
visualmode([expr])		字串	最近使用的可視模式
wildmenumode()			數值	'wildmenu' 模式是否啟用
win_findbuf({bufnr})		列表	尋找包含 {bufnr} 的視窗
win_getid([{win} [, {tab}]])	數值	得到 {tab} 中 {win} 的視窗 ID
win_gotoid({expr})		數值	轉到 ID 為 {expr} 的視窗
win_id2tabwin({expr})		列表	從視窗 ID 獲得標籤頁與視窗
win_id2win({expr})		數值	從視窗 ID 獲得視窗號
winbufnr({nr})			數值	視窗 {nr} 的緩衝區號
wincol()			數值	游標所在的視窗列
winheight({nr})			數值	視窗 {nr} 的高度
winline()			數值	游標所在的視窗行
winnr([{expr}])			數值	當前視窗的編號
winrestcmd()			字串	返回恢復視窗大小的命令
winrestview({dict})		無	恢復當前視窗的檢視
winsaveview()			字典	儲存當前視窗的檢視
winwidth({nr})			數值	視窗 {nr} 的寬度
wordcount()			字典	位元組/字元/單詞統計
writefile({list}, {fname} [, {flags}])
				數值	把行列表寫到檔案 {fname}
xor({expr}, {expr})		數值	按位異或

abs({expr})							*abs()*
		返回 {expr} 的絕對值。如果 {expr} 計算結果為浮點數，abs() 返回
		浮點數。如果 {expr} 可以轉換為數值，abs() 返回數值。否則報錯並
		返回 -1。
		示例: >
			echo abs(1.456)
<			1.456  >
			echo abs(-5.456)
<			5.456  >
			echo abs(-4)
<			4
		{僅當編譯時加入 |+float| 特性才有效}


and({expr}, {expr})					*and()*
		對兩個引數進行按位與。引數須轉換為數值。列表、字典或浮點數引數
		會報錯。
		示例: >
			:let flag = and(bits, 0x80)


acos({expr})							*acos()*
		返回以弧度表示的 {expr} 的反餘弦值，返回值為 [0, pi] 區間內的
		浮點數。
		{expr} 的計算結果必須是 [-1, 1] 區間內的浮點數或數值。
		示例: >
			:echo acos(0)
<			1.570796 >
			:echo acos(-0.5)
<			2.094395
		{僅當編譯時加入 |+float| 特性才有效}

add({list}, {expr})					*add()*
		在 |List| {list} 最後附加專案 {expr}。返回新產生的 |List|。例
		如: >
			:let alist = add([1, 2, 3], item)
			:call add(mylist, "woodstock")
<		注意 如果 {expr} 是 |List|，它被作為單個專案附加進去。
		|extend()| 可以用來連線 |List|。
		|insert()| 可以用來把一個專案加到其它的位置上。

append({lnum}, {expr})					*append()*
		當 {expr} 為 |List|: 把每個 |List| 專案作為文字行，附加到當前
		緩衝區第 {lnum} 行之下。
		否則，把 {expr} 作為單個文字行，附加於當前緩衝區第 {lnum} 行之
		下。
		{lnum} 可以為零，用於在第一行前插入一行。如果失敗 ({lnum} 越
		界)，返回 1，成功則返回 0。例如: >
			:let failed = append(line('$'), "# THE END")
			:let failed = append(0, ["Chapter 1", "the beginning"])
<
							*argc()*
argc()		返回當前視窗引數列表的檔案數目。見 |arglist|。

							*argidx()*
argidx()	返回引數列表的當前索引。0 是第一個檔案。argc() - 1 是最後一
		個。見 |arglist|。

							*arglistid()*
arglistid([{winnr} [, {tabnr}]])
		返回引數列表 ID，這是一個用來標識正在使用的引數列表的數值。零
		代表全域性引數列表。見 |arglist|。
		如果引數非法，返回 -1。

		無引數時，使用當前視窗。
		只提供 {winnr} 時，使用當前標籤頁的指定視窗。
		同時提供 {winnr} 和 {tabnr} 時，使用指定標籤頁的指定視窗。
		{winnr} 可以是視窗號或 |window-ID|。

							*argv()*
argv([{nr}])	返回當前視窗引數列表第 {nr} 個引數。見 |arglist|。"argv(0)" 是
		第一個引數。
		例如: >
	:let i = 0
	:while i < argc()
	:  let f = escape(fnameescape(argv(i)), '. ')
	:  exe 'amenu Arg.' . f . ' :e ' . f . '<CR>'
	:  let i = i + 1
	:endwhile
<		如果沒有 {nr} 引數，返回完整的 {arglist} 的 |List|。

							*assert_equal()*
assert_equal({expected}, {actual} [, {msg}])
		{expected} 不等於 {actual} 時，加入錯誤資訊到 |v:errors|。
		沒有自動轉換，字串 "4" 不同於數值 4。數值 4 又不同於浮點數
		4.0。不適用 'ignorecase'，大小寫永遠敏感。
		省略 {msg} 則生成形如 "Expected {expected} but got {actual}"
		的錯誤。
		示例: >
	assert_equal('foo', 'bar')
<		會在 |v:errors| 加入字串:
	test.vim line 12: Expected 'foo' but got 'bar' ~

assert_exception({error} [, {msg}])			*assert_exception()*
		v:exception 不包含 {error} 時，加入錯誤資訊到 |v:errors|。
		可用於斷言命令丟擲例外。使用錯誤號後加冒號，就不用擔心翻譯的問
		題: >
			try
			  commandthatfails
			  call assert_false(1, 'command should have failed')
			catch
			  call assert_exception('E492:')
			endtry

assert_fails({cmd} [, {error}])					*assert_fails()*
		執行 {cmd}，如果_不_出錯，加入錯誤資訊到 |v:errors|。
		給出 {error} 時，必須匹配 |v:errmsg|。

assert_false({actual} [, {msg}])				*assert_false()*
		{actual} 不為假時，加入錯誤資訊到 |v:errors|，餘類同
		|assert_equal()|。
		零值為假值。{actual} 不是數值時，斷言失敗。
		省略 {msg} 則生成形如 "Expected False but got {actual}" 的錯
		誤。

assert_inrange({lower}, {upper}, {actual} [, {msg}])	 *assert_inrange()*
		對數值進行斷言。{actual} 小於 {lower} 會大於 {upper} 時，加入
		錯誤資訊到 |v:errors|。
		省略 {msg} 則生成形如 "Expected range {lower} - {upper}, but
		got {actual}" 的錯誤。

								*assert_match()*
assert_match({pattern}, {actual} [, {msg}])
		{pattern} 不匹配 {actual} 時，加入錯誤資訊到 |v:errors|。

		{pattern} 的用法類同於 |=~|: 匹配總是假定 'magic' 置位而
		'cpoptions' 為空，而忽略 'magic' 或 'cpoptions' 的實際值。

		{actual} 作字串使用，適用自動轉換。
		"^" 和 "$" 可用來匹配文字的開始和結尾。兩者皆用則可匹配整個文
		本。

		省略 {msg} 則生成形如 "Pattern {pattern} does not match
		{actual}" 的錯誤。
		示例: >
	assert_match('^f.*o$', 'foobar')
<		會在 |v:errors| 加入字串:
	test.vim line 12: Pattern '^f.*o$' does not match 'foobar' ~

							*assert_notequal()*
assert_notequal({expected}, {actual} [, {msg}])
		和 `assert_equal()` 相反: {expected} 等於 {actual} 時，加入錯
		誤資訊到 |v:errors|。

							*assert_notmatch()*
assert_notmatch({pattern}, {actual} [, {msg}])
		和 `assert_match()` 相反: {pattern} 匹配 {actual} 時，加入錯
		誤資訊到 |v:errors|。

assert_report({msg})					*assert_report()*
		直接報告測試失敗，用 {msg}。

assert_true({actual} [, {msg}])				*assert_true()*
		{actual} 不為真時，加入錯誤資訊到 |v:errors|，餘類同
		|assert_equal()|。
		非零值為真值。{actual} 不是數值時，斷言失敗。
		省略 {msg} 則生成形如 "Expected True but got {actual}" 的錯
		誤。

asin({expr})						*asin()*
		返回以弧度表示的 {expr} 的反正弦值，返回值為 [-pi/2, pi/2] 區
		間內的浮點數。
		{expr} 的計算結果必須是 [-1, 1] 區間內的浮點數或數值。
		示例: >
			:echo asin(0.8)
<			0.927295 >
			:echo asin(-0.5)
<			-0.523599
		{僅當編譯時加入 |+float| 特性才有效}


atan({expr})						*atan()*
		返回 {expr} 反正切的主值，返回值為 [-pi/2, +pi/2] 區間內的弧度
		值浮點數。
		{expr} 計算結果必須為浮點數或數值。
		示例: >
			:echo atan(100)
<			1.560797 >
			:echo atan(-4.01)
<			-1.326405
		{僅當編譯時加入 |+float| 特性才有效}

atan2({expr1}, {expr2})					*atan2()*
		返回 {expr1} / {expr2} 的反正切值，以弧度計算，返回值為 [-pi,
		+pi] 區間內的浮點數。
		{expr1} 和 {expr2} 計算結果必須為浮點數或數值。
		示例: >
			:echo atan2(-1, 1)
<			-0.785398 >
			:echo atan2(1, -1)
<			2.356194
		{僅當編譯時加入 |+float| 特性才有效}

balloon_show({msg})					*balloon_show()*
		在氣泡中顯示 {msg}。
		示例: >
			func GetBalloonContent()
			   " 啟動內容的獲取過程
			   return ''
			endfunc
			set balloonexpr=GetBalloonContent()

			func BalloonCallback(result)
			  call balloon_show(a:result)
			endfunc
<
		期待的用法是從 'balloonexpr' 啟動氣泡內容的獲取過程。它應呼叫
		非同步方法，然後在其回撥中執行 balloon_show()。'balloonexpr' 自
		身可返回空字串或任何佔位符。

		如果不能顯示氣泡，不做任何事，不會報錯。
		{僅當編譯時加入 |+balloon_eval| 特性才有效}

							*browse()*
browse({save}, {title}, {initdir}, {default})
		啟動檔案請求視窗。只有在 "has("browse")" 返回 |TRUE| 時 (只有
		在一些 GUI 版本里) 才可以。
		輸入的欄位包括:
		    {save}	|TRUE| 時，選擇要寫入的檔案
		    {title}	請求視窗的標題
		    {initdir}	開始瀏覽的目錄
		    {default}	預設檔名
		如果按了 "Cancel" 按鈕、出錯、或者無法瀏覽，返回空字串。

							*browsedir()*
browsedir({title}, {initdir})
		啟動目錄請求視窗。只有在 "has("browse")" 返回 |TRUE| 時 (只有
		在一些 GUI 版本里) 才能工作。
		有的系統上不支援目錄瀏覽器，這時使用檔案瀏覽器。此時: 選擇要用
		的目錄裡的檔案。
		輸入的欄位包括:
		    {title}	請求視窗的標題
		    {initdir}	開始瀏覽的目錄
		如果按了 "Cancel" 按鈕、出錯、或者無法瀏覽，返回空字串。

bufexists({expr})					*bufexists()*
		返回數值，如果名為 {expr} 的緩衝區存在的話，返回 |TRUE|。
		如果 {expr} 引數是數值，指定緩衝區號。
		如果 {expr} 引數是字串，緩衝區的名字必須與其完全匹配。該名字
		可以是:
		- 相對於當前目錄。
		- 完整路徑。
		- 'buftype' 設為 "nofile" 的緩衝區名。
		- URL 名。
		列表外緩衝區也會被找到。
		注意 幫助檔案在 |:buffers| 裡列出的是它們的短名字。但
		bufexists() 需要它們的長名字才能找到它們。
		bufexists() 可能報告緩衝區存在，但要使其名字可用於 |:buffer|
		命令，可能需用到 |expand()|。尤其 MS-Windows 8.3 名字可能形
		如 "c:\DOCUME~1"。
		使用 "bufexists(0)" 可以測試是否存在輪換檔名。

							*buffer_exists()*
		已廢棄的名字: buffer_exists()。

buflisted({expr})					*buflisted()*
		返回數值，如果名為 {expr} 的緩衝區在列表內的話 (置位了
		'buflisted' 選項)，返回 |TRUE|。
		{expr} 引數用法同 |bufexists()|。

bufloaded({expr})					*bufloaded()*
		返回數值，如果名為 {expr} 的緩衝區存在且已載入的話 (在視窗顯
		示，或者至少被隱藏)，返回 |TRUE|。
		{expr} 引數用法同 |bufexists()|。

bufname({expr})						*bufname()*
		返回緩衝區的名字，如同 ":ls" 命令顯示的那樣。
		如果 {expr} 引數是數值，指定緩衝區號。數值零代表當前視窗的輪換
		緩衝區。
		如果 {expr} 引數是字串，它用作 |file-pattern| 來匹配緩衝區名
		字。這裡總假設定位 'magic' 而 'cpoptions' 為空。如果有超過一個
		匹配，返回空字串。
		"" 或 "%" 可用來指定當前緩衝區，"#" 指定輪換緩衝區。
		完整的匹配優先，如果沒有，也接受在緩衝區名的開始，結束和中間的
		匹配。如果你只願意接受完整的匹配，在模式的開始放上 "^"，在結尾
		放上 "$"。
		先查詢列表內緩衝區。如果列出緩衝區有唯一的匹配，返回之。不然，
		再查詢列表外的緩衝區。
		如果 {expr} 是字串，但你想用作緩衝區號，給它加零可以強制轉化
		為數值型: >
			:echo bufname("3" + 0)
<		如果緩衝區不存在，或者沒有名字，返回空字串。 >
	bufname("#")		輪換緩衝區名
	bufname(3)		緩衝區 3 的名字
	bufname("%")		當前緩衝區名
	bufname("file2")	匹配 "file2" 的緩衝區名。
<							*buffer_name()*
		已廢棄的名字: buffer_name()。

							*bufnr()*
bufnr({expr} [, {create}])
		返回緩衝區的編號，如同 ":ls" 命令顯示的那樣。關於 {expr} 的使
		用，見上 |bufname()|。
		如果不存在符合的緩衝區，返回 -1。或者，如果提供了 {create} 參
		數而且非零，建立一個新的列表外緩衝區，並返回其編號。
		bufnr("$") 是最後一個緩衝區: >
	:let last_buffer = bufnr("$")
<		返回數值，即最大的已有的緩衝區的編號。注意 較小的編號不一定都
		對應存在的緩衝區，因為 ":bwipeout" 可能永久地刪除了部分的緩衝
		區。用 bufexists() 可以測試緩衝區是否存在。
							*buffer_number()*
		已廢棄的名字: buffer_number()。
							*last_buffer_nr()*
		bufnr("$") 已廢棄的名字: last_buffer_nr()。

bufwinid({expr})					*bufwinid()*
		返回數值，帶緩衝區 {expr} 相關的第一個視窗的 |window-ID|。
		關於 {expr} 的使用，見上 |bufname()|。 如果緩衝區 {expr} 不存
		在或沒有對應視窗，返回 -1。示例: >

	echo "A window containing buffer 1 is " . (bufwinid(1))
<
		只處理當前標籤頁。

bufwinnr({expr})					*bufwinnr()*
		返回數值，即緩衝區 {expr} 對應的第一個視窗的編號。{expr} 的使
		用方式見上 |bufname()|。如果緩衝區 {expr} 不存在或者沒有對應的
		視窗，返回 -1。例如: >

	echo "包含緩衝區 1 的視窗是 " . (bufwinnr(1))

<		該編號可用於 |CTRL-W_w| 和 ":wincmd w" |:wincmd|。
		只處理當前標籤頁。

byte2line({byte})					*byte2line()*
		返回當前緩衝區第 {byte} 個位元組所在的行號。取決於當前緩衝區的
		'fileformat' 選項，這可以包括不同的換行符。第一個字元的位元組編
		號為 1。
		另見 |line2byte()|、|go| 和 |:goto|。
		{僅當編譯時加入 |+byte_offset| 特性才有效}

byteidx({expr}, {nr})					*byteidx()*
		返回字串 {expr} 裡第 {nr} 個字元的位元組位置。零代表第一個字
		符，此時返回零。
		該函式只對多位元組字元有用，不然返回值總是等於 {nr}。
		合成用字元不單獨計數，其位元組長度加到其前導的基礎字元上。要將合
		成用字元分別計數，見下 |byteidxcomp()|。
		例如: >
			echo matchstr(str, ".", byteidx(str, 3))
<		顯示第四個字元。另一個方法也能達到相同的效果: >
			let s = strpart(str, byteidx(str, 3))
			echo strpart(s, 0, byteidx(s, 1))
<		另見 |strgetchar()| 和 |strcharpart()|。

		如果字元數不足 {nr}，返回 -1。
		如果剛好 {nr} 個字元，返回字串的位元組長度。

byteidxcomp({expr}, {nr})					*byteidxcomp()*
		類似於 byteidx()，但合成用字元作為一個單獨的字元計算。示例: >
			let s = 'e' . nr2char(0x301)
			echo byteidx(s, 1)
			echo byteidxcomp(s, 1)
			echo byteidxcomp(s, 2)
<		第一個和第三個 echo 返回 3 ('e' 加上合成用字元是 3 個位元組)，第
		二個 echo 返回 1 ('e' 是一個位元組)。
		只有當 'encoding' 設為某種 Unicode 編碼時，才會和 byteidx() 有
		所不同。

call({func}, {arglist} [, {dict}])			*call()* *E699*
		呼叫函式 {func}，使用 |List| {arglist} 專案作為引數。
		{func} 可以是 |Funcref| 或函式名。
		a:firstline 和 a:lastline 設為當前行。
		返回呼叫的函式的結果。
		{dict} 用於為函式指定 "dict" 屬性。其目的是設定區域性變數
		"self"。|Dictionary-function|

ceil({expr})							*ceil()*
		返回浮點數，即大於等於 {expr} 的最小整數 (向上取整)。
		{expr} 的計算結果必須是浮點數或數值。
		示例: >
			echo ceil(1.456)
<			2.0  >
			echo ceil(-5.456)
<			-5.0  >
			echo ceil(4.0)
<			4.0
		{僅當編譯時加入 |+float| 特性才有效}

ch_canread({handle})						*ch_canread()*
		如果從 {handle} 有內容可讀，返回非零。
		{handle} 可以是通道或帶有通道的作業。

		用於在合適的時間才從通道讀取的場合，例如在定時器中。

		注意 如果通道沒有回撥，這些訊息被丟棄。要避免這一點，加上關閉
		回撥函式。

		{僅當編譯時加入 |+channel| 特性才有效}

ch_close({handle})						*ch_close()*
		關閉 {handle}。見 |channel-close|。
		{handle} 可以是通道或帶有通道的作業。
		不呼叫關閉回撥函式。

		{僅當編譯時加入 |+channel| 特性才有效}

ch_close_in({handle})						*ch_close_in()*
		只關閉 {handle} 的 ”in" 部分。見 |channel-close-in|。
		{handle} 可以是通道或帶有通道的作業。
		不呼叫關閉回撥函式。

		{僅當編譯時加入 |+channel| 特性才有效}

ch_evalexpr({handle}, {expr} [, {options}])			*ch_evalexpr()*
		傳送 {expr} 到 {handle} 上。{expr} 用通道型別進行編碼。不能於
		原始通道。見 |channel-use|。
		{handle} 可以是通道或帶有通道的作業。
								*E917*
		{options} 必須是字典。不能有 "callback" 專案。可以有 "timeout"
		專案來指明此特定請求的超時。

		ch_evalexpr() 等待響應並返回經解碼的表示式。如果有錯或超時，
		返回空字串。

		{僅當編譯時加入 |+channel| 特性才有效}

ch_evalraw({handle}, {string} [, {options}])		*ch_evalraw()*
		傳送 {expr} 到 {handle} 上。
		{handle} 可以是通道或帶有通道的作業。

		類似於 |ch_evalexpr()|，但不對請求編碼也不對響應結果解碼。呼叫
		者負責內容的正確性。也不對 NL 模式的通道附加換行符，呼叫者須負
		責。響應中的 NL 則被清除。
		見 |channel-use|。

		{僅當編譯時加入 |+channel| 特性才有效}

ch_getbufnr({handle}, {what})				 *ch_getbufnr()*
		返回 {handle} 用於 {what} 的緩衝區號。
		{handle} 可以是通道或帶有通道的作業。
		{what} 可以是 "err"，代表 stderr，"out" 代表 stdout，或空，代
		表套接字輸出。
		如果沒有這樣的緩衝區，返回 -1。
		{僅當編譯時加入 |+channel| 特性才有效}

ch_getjob({channel})						*ch_getjob()*
		取得 {channel} 相關的作業。
		如果沒有這樣的作業，在返回的作業上呼叫 |job_status()| 會返回
		"fail"。

		{僅當編譯時加入 |+channel| 和 |+job| 特性才有效}

ch_info({handle})						*ch_info()*
		返回 {handle} 相關資訊的一個字典。其專案為:
		   "id"		  通道號
		   "status"	  "open"、"buffered" 或 "closed"，可見
				  ch_status()
		用於 ch_open() 開啟的通道時:
		   "hostname"	  地址的機器名
		   "port"	  地址的埠號
		   "sock_status"  "open" 或 "closed"
		   "sock_mode"	  "NL"、"RAW"、"JSON" 或 "JS"
		   "sock_io"	  "socket"
		   "sock_timeout" 毫秒計的超時
		用於 job_start() 開啟的通道時:
		   "out_status"	  "open"、"buffered" 或 "closed"
		   "out_mode"	  "NL"、"RAW"、"JSON" 或 "JS"
		   "out_io"	  "null"、"pipe"、"file" 或 "buffer"
		   "out_timeout"  毫秒計的超時
		   "err_status"	  "open"、"buffered" 或 "closed"
		   "err_mode"	  "NL"、"RAW"、"JSON" 或 "JS"
		   "err_io"	  "out"、"null"、"pipe"、"file" 或 "buffer"
		   "err_timeout"  毫秒計的超時
		   "in_status"	  "open" 或 "closed"
		   "in_mode"	  "NL"、"RAW"、"JSON" 或 "JS"
		   "in_io"	  "null"、"pipe"、"file" 或 "buffer"
		   "in_timeout"	  毫秒計的超時

ch_log({msg} [, {handle}])					*ch_log()*
		如果用 |ch_logfile()| 開啟日誌，把 {msg} 寫入通道日誌檔案中。
		如果傳入 {handle}，使用該通道號寫入資訊。
		{handle} 可以是通道或帶有通道的作業。所用的通道號對應的通道必
		須已開啟。

ch_logfile({fname} [, {mode}])					*ch_logfile()*
		啟動通道活動記錄，寫入 {fname}。
		如果 {fname} 為空字串，停止記錄。

		如果 {mode} 省略或為 "a"，附加到檔案。
		如果 {mode} 為 "w"，用新檔案開始。

		每條訊息後都會重新整理檔案，Unix 上可用 "tail -f" 實時監控。


ch_open({address} [, {options}])				*ch_open()*
		開啟通道到 {address}。見 |channel|。
		返回通道。錯誤檢查可用 |ch_status()|。

		{address} 形如 "hostname:port"，例如 "localhost:8765"。

		{options} 如果給出，必須是 |Dictionary|。
		見 |channel-open-options|。

		{僅當編譯時加入 |+channel| 特性才有效}

ch_read({handle} [, {options}])					*ch_read()*
		從 {handle} 讀取，返回收到的訊息。
		{handle} 可以是通道或帶有通道的作業。
		見 |channel-more|。
		{僅當編譯時加入 |+channel| 特性才有效}

ch_readraw({handle} [, {options}])			*ch_readraw()*
		類似於 ch_read()，但 JS 和 JSON 通道不對訊息解碼。見
		|channel-more|。
		{僅當編譯時加入 |+channel| 特性才有效}

ch_sendexpr({handle}, {expr} [, {options}])			*ch_sendexpr()*
		傳送 {expr} 到 {handle} 上。{expr} 用通道型別進行編碼。不能於
		原始通道。見 |channel-use|。			*E912*
		{handle} 可以是通道或帶有通道的作業。

		{僅當編譯時加入 |+channel| 特性才有效}

ch_sendraw({handle}, {string} [, {options}])		*ch_sendraw()*
		傳送 {expr} 到 {handle} 上。
		類似於 |ch_sendexpr()|，但不對請求編碼也不對響應結果解碼。呼叫
		者負責內容的正確性。也不對 NL 模式的通道附加換行符，呼叫者須負
		責。響應中的 NL 則被清除。
		見 |channel-use|。

		{僅當編譯時加入 |+channel| 特性才有效}

ch_setoptions({handle}, {options})			*ch_setoptions()*
		設定 {handle} 的選項:
			"callback"	通道回撥函式
			"timeout"	預設讀操作以毫秒計的超時
			"mode"		整個通道所用的模式
		更多的解釋可見 |ch_open()|。
		{handle} 可以是通道或帶有通道的作業。

		注意 改變模式可能會丟失正在排隊的訊息。

		以下選項不可改變:
			"waittime"	只適用於 |ch_open()|

ch_status({handle} [, {options}])				*ch_status()*
		返回 {handle} 的狀態:
			"fail"		開啟通道失敗
			"open"		通道可用
			"buffered"	通道可讀，不可寫
			"closed"	通道不可用
		{handle} 可以是通道或帶有通道的作業。
		"buffered" 用於通道已關閉但還有資料用 |ch_read()| 可讀的情況。

		{options} 給出時，可以包含 "part" 專案，指定通道要返回狀態的部
		分: "out" 還是 "err"。例如，要得到錯誤輸出的狀態: >
			ch_status(job, {"part": "err"})
<
changenr()						*changenr()*
		返回最近改變的編號。這和 |:undolist| 顯示的編號相同，可用於
		|:undo| 命令。
		如果發生了改變，返回的是此改變的編號。在重做以後，返回的是重做
		的改變的編號。在撤銷以後，返回撤銷的改變的編號減一。

char2nr({expr}[, {utf8}])					*char2nr()*
		返回 {expr} 第一個字元的數值結果。例如: >
			char2nr(" ")		返回 32
			char2nr("ABC")		返回 65
<		如果 {utf8} 省略或為零，使用當前的 'encoding'。比如對 "utf-8"
		來說: >
			char2nr("á")		返回 225
			char2nr("á"[0])		返回 195
<		如果 {utf8} 為 1，則總視為 utf-8 字元。
		組合用字元是一個單獨的字元。
		|nr2char()| 是它的逆操作。

cindent({lnum})						*cindent()*
		得到第 {lnum} 行根據 C 縮排規則應有的縮排距離，見 'cindent'。
		縮排的計算以空格計，因而和 'tabstop' 的值是有關係的。{lnum} 的
		使用方式和 |getline()| 相同。
		如果 {lnum} 非法或者 Vim 編譯時不帶 |+cindent| 特性，返回 -1。
		見 |C-indenting|。

clearmatches()						*clearmatches()*
		清除之前 |matchadd()| 和 |:match| 命令定義的匹配。

							*col()*
col({expr})	返回數值，即 {expr} 給定的列位置的位元組索引。可接受的位置是:
		    .	    游標位置
		    $	    游標行的行尾 (返回游標行的位元組數加 1)
		    'x	    位置標記 x 的位置 (如果該位置標記沒有設定，返回 0)
		    v       可視模式下: 可視區域的開始位置 (游標是結束位置)。
			    如果不在可視模式下，返回當前游標位置。和 |'<| 不同
			    的是，會被立即更新。
		另外，{expr} 可以是 [lnum, col]: 包含行號和列號的 |List|。常用
		於指定列號為 "$" 以得到特定行的末列列號。如果 "lnum" 或 "col"
		超出範圍，col() 返回零。
		要得到行號用 |line()|。兩者都要用 |getpos()|。
		要得到螢幕列的位置，用 |virtcol()|。
		注意 只能使用當前檔案的位置標記。
		例如: >
			col(".")		游標所在列
			col("$")		游標行的長度加 1
			col("'t")		位置標記 t 的列號
			col("'" . markname)	等於 markname 的位置標記的列號
<		第一列為 1。0 用來返回錯誤。
		大寫位置標記的對應列可能在另一個緩衝區中。
		如果激活了 'virtualedit' 並且如果游標在行尾之後的話，計算游標
		位置得到的列號比實際的多 1。可用來在插入模式得到列數: >
			:imap <F2> <C-O>:let save_ve = &ve<CR>
				\<C-O>:set ve=all<CR>
				\<C-O>:echo col(".") . "\n" <Bar>
				\let &ve = save_ve<CR>
<

complete({startcol}, {matches})			*complete()* *E785*
		設定插入模式補全的匹配。
		只能用於插入模式。需要使用 CTRL-R = 的對映 (見 |i_CTRL-R|)。不
		能在 CTRL-O 之後或者在表示式對映裡使用。
		{startcol} 是行內待補全文字開始的位元組偏移。直到游標為止的文字
		就是原始的文字，它將要被匹配所替代。用 col('.') 會得到空串。而
		"col('.') - 1" 將用匹配替換單個字元。
		{matches} 必須是 |List|。每個 |List| 專案是一個匹配。
		|complete-items| 說明可能的專案型別。
		注意 呼叫此函式後，你不應插入任何使補全停止的內容。
		用 CTRL-N 和 CTRL-P 選擇匹配，就像普通的插入模式補全那樣。如果
		指定，會出現彈出選單，見 |ins-completion-menu|。
		示例: >
	inoremap <F5> <C-R>=ListMonths()<CR>

	func! ListMonths()
	  call complete(col('.'), ['January', 'February', 'March',
		\ 'April', 'May', 'June', 'July', 'August', 'September',
		\ 'October', 'November', 'December'])
	  return ''
	endfunc
<		此例並不很有用，但可以說明功能。注意這裡返回空串，以免插入零。

complete_add({expr})				*complete_add()*
		把 {expr} 加到匹配的列表裡。只能用於 'completefunc' 選項指定的
		函式裡。
		返回 0 代表失敗 (空字串或者記憶體不足)，1 代表加入了匹配，2 代
		表匹配已經在列表裡。
		|complete-functions| 解釋 {expr}。它和 'omnifunc' 應該返回的列
		表中單個專案相同。

complete_check()				*complete_check()*
		尋找補全匹配時，檢查輸入的鍵。如果尋找匹配需要一定時間時有用。
		如果匹配的搜尋被中止，返回 |TRUE|。否則返回零。
		只能用於 'completefunc' 選項指定的函式裡。

						*confirm()*
confirm({msg} [, {choices} [, {default} [, {type}]]])
		confirm() 提供使用者一個對話方塊，從中可以作出選擇。返回選擇的序
		號。第一個選擇為 1。
		注意: confirm() 只有在編譯時加入對話方塊支援才存在，見
		|+dialog_con| 和 |+dialog_gui|。
		在 |dialog| 裡顯示 {msg} 訊息，並提供可能的選擇 {choices}。如
		果 {choices} 不存在或者為空，使用 "&OK" (經過翻譯)。
		{msg} 是字串，'\n' 用來包含換行符。在有些系統上該字串在放
		不下時被迴繞，但並非所有系統都如此。
		{choices} 是一個字串，用 '\n' 分隔各個選擇，例如 >
			confirm("Save changes?", "&Yes\n&No\n&Cancel")
<		'&' 之後的字元提供該選擇的快捷鍵。這樣，你可以輸入 'c' 來選擇
		"Cancel"。快捷鍵不一定是第一個字元: >
			confirm("file has been modified", "&Save\nSave &All")
<		控制檯裡，每個選擇的第一個字元用作預設的快捷鍵。
		可選的 {default} 引數是使用者按 <CR> 使用的選擇號。設定 1 使得第
		一個選項成為預設，如果是 0，則不設定任何預設。如果不提供
		{default}，假設為 1。

		可選的 {type} 引數指定對話方塊的型別。只有在 GTK、Mac、Motif 和
		Win32 GUI 上才用得上，它用以指定圖示。可以取的值是: "Error"、
		"Question"、 "Info"、 "Warning" 或 "Generic"。只有第一個字元是
		重要的。如果忽略 {type}，使用 "Generic"。

		如果使用者用 <Esc>、CTRL-C 或者別的合法的中斷鍵中止對話方塊，
		confirm() 返回 0。

		一個例子: >
   :let choice = confirm("你要吃什麼？", "&蘋果\n&桔子\n&香蕉", 2)
   :if choice == 0
   :	echo "快下定決心！"
   :elseif choice == 3
   :	echo "好吃"
   :else
   :	echo "我本人喜歡香蕉。"
   :endif
<		GUI 的對話方塊使用按鈕。按鈕的排放方式取決於 'guioptions' 裡的
		'v' 標誌位。如果包含該標誌位，按鈕總是豎排的。不然，confirm()
		試圖把按鈕放在一行裡。如果放不下，那麼還是使用豎排的方式。在有
		的系統上，無論如何總是使用橫排。

							*copy()*
copy({expr})	構造 {expr} 的備份。對數值和字串而言，這和直接使用 {expr}
		並無不同。
		如果 {expr} 是 |List|，建立一個淺備份。這意味著，原來的 |List|
		可以被改變，而不會影響新建的備份。反之亦然。不過，其中的專案只
		有一份，所以修改專案同時修改兩個 |List| 的內容。
		|Dictionary| 的複製和 |List| 類似。
		另見 |deepcopy()|。

cos({expr})						*cos()*
		返回浮點數，即以弧度測量的 {expr} 的餘弦值。
		{expr} 的計算結果必須是浮點數或數值。
		示例: >
			:echo cos(100)
<			0.862319 >
			:echo cos(-4.01)
<			-0.646043
		{僅當編譯時加入 |+float| 特性才有效}


cosh({expr})						*cosh()*
		返回 {expr} 的雙曲餘弦值，返回值為 [1, inf] 區間內的浮點數。
		{expr} 的計算結果必須是浮點數或數值。
		示例: >
			:echo cosh(0.5)
<			1.127626 >
			:echo cosh(-0.5)
<			-1.127626
		{僅當編譯時加入 |+float| 特性才有效}


count({comp}, {expr} [, {ic} [, {start}]])			*count()*
		返回 |List| 或 |Dictionary| {comp} 裡值為 {expr} 的專案出現的
		次數。
		如果給出 {start}，從該索引指定的專案開始。{start} 只能用於
		|List|。
		如果給出 {ic} 並且為 |TRUE|，忽略大小寫。


							*cscope_connection()*
cscope_connection([{num} , {dbpath} [, {prepend}]])
		檢查 |cscope| 連線是否存在。如果沒有引數，則函式返回:
			0，如果 cscope 不存在 (編譯沒有帶該特性)，或者不存在
			   cscope 連線；
			1，如果至少有一個 cscope 連線。

		如果指定了引數，那麼 {num} 的值指定如何檢查 cscope 連線存在與
		否的方式:

		{num}	存在檢查的方式描述 ~
		-----	------------------------------
		0	等同於無引數 (例如，"cscope_connection()")。
		1	忽略 {prepend}，使用 {dbpath} 的字串部分匹配。
		2	忽略 {prepend}，使用 {dbpath} 的字串完整匹配。
		3	使用 {prepend}，使用 {dbpath} 和 {prepend} 的字串部
			分匹配。
		4	使用 {prepend}，使用 {dbpath} 和 {prepend} 的字串完
			整匹配。

		注意: 所有的字串比較都對大小寫敏感！

		示例。假定我們有如下設定 (":cs show" 的輸出): >

  # pid    database name			prepend path
  0 27664  cscope.out				/usr/local
<
		啟動方式					   返回值 ~
		----------					---------- >
		cscope_connection()					1
		cscope_connection(1, "out")				1
		cscope_connection(2, "out")				0
		cscope_connection(3, "out")				0
		cscope_connection(3, "out", "local")			1
		cscope_connection(4, "out")				0
		cscope_connection(4, "out", "local")			0
		cscope_connection(4, "cscope.out", "/usr/local")	1
<
cursor({lnum}, {col} [, {off}])				*cursor()*
cursor({list})
		把游標定位在第 {lnum} 行的第 {col} 列 (位元組計數)。第一列為 1。

		如果只有一個引數 {list}，它被看作帶兩個、三個或四個引數的
		|List|:
			[{lnum}, {col}]
			[{lnum}, {col}, {off}]
			[{lnum}, {col}, {off}, {curswant}]
		和 |getpos()| 和 |getcurpos()| 的返回值類似，但沒有第一項。

		不改變跳轉表。
		如果 {lnum} 超過緩衝區的行數，游標定位在緩衝區的末行。
		如果 {lnum} 為零，游標留在當前行。
		如果 {col} 超過該行的位元組數，游標定位在該行的最後一個字元上。
		如果 {col} 為零，游標留在當前列。
		如果 {curswant} 給出，它被用於設定垂直移動的首選列，否則使用
		{col}。

		如果使用 'virtualedit'，{off} 指定從該字元開始以螢幕列計算的偏
		移。例如，在製表裡或者在最後一個字元之後的某個位置。
		如果定位成功，返回 0，否則返回 -1。


deepcopy({expr}[, {noref}])				*deepcopy()* *E698*
		構造 {expr} 的備份。對數值和字串而言，這和直接使用 {expr}
		並無不同。
		如果 {expr} 是 |List|，建立一個完整的備份。這意味著，原來的
		|List| 可以被改變，而不會影響新建的備份。反之亦然。如果某個項
		目是 |List| 或 |Dictionary|，遞迴地建立它的備份。這樣，備份裡
		專案的修改也不會影響到原來 |List| 的內容。
		|Dictionary| 的複製和 |List| 類似。
		如果省略 {noref} 或為零，包含的 |List| 或 |Dictionary| 只複製
		一次。所有指向它的引用指向此一備份。如果 {noref} 設為 1，每次
		|List| 或 |Dictionary| 的出現會導致建立一個新的備份。這意味著
		迴圈引用會使得 deepcopy() 失敗。
								*E724*
		巢狀可達 100 層。如果有指向較高層的引用，{noref} 為 1 的深備份
		會失敗。
		另見 |copy()|。

delete({fname} [, {flags}])					*delete()*
		無 {flags} 或 {flags} 為空: 刪除名為 {fname} 的檔案。{fname}
		是符號連結也可以。

		如果 {flags} 是 "d": 刪除名為 {fname} 的目錄。如果目錄 {fname}
		非空會失敗。

		如果 {flags} 是 "rf": 遞迴刪除名為 {fname} 的目錄和其下的所有
		檔案。_要小心_！
		備註: 在 MS-Windows 上不能刪除正在使用的目錄。

		符號連結本身被刪除，而不是它連結到的檔案。

		返回型別為數值。如果成功刪除檔案，返回 0，如果刪除失敗或部分失
		敗，返回 -1。

		從 |List| 裡刪除專案請用 |remove()|。
		要刪除緩衝區的行用 |:delete|。如果行號是變數可用 |:exe|。

							*did_filetype()*
did_filetype()	如果執行自動命令時，啟用 FileType 事件至少一次，則返回
		|TRUE|。可以用於防止在檢測檔案型別的腳本里再次啟用 FileType 事
		件。|FileType|
		如果用過 ":setf FALLBACK"，返回 |FALSE|。
		如果編輯另外一個檔案，該計數被複位，因而這隻能檢查 FileType 事
		件是否在當前緩衝區裡啟用過。它允許開始編輯另一個緩衝區的自動命
		令設定 'filetype' 並載入語法檔案。

diff_filler({lnum})					*diff_filler()*
		返回第 {lnum} 行之上的填充行的數目。
		這些是在另一個進行比較的窗口裡在此位置插入的行。這些填充行在屏
		幕上顯示，但緩衝區裡並不存在。
		{lnum} 的用法類似於 |getline()|。所以 "." 是當前行，"'m" 是位
		置標記 m，等等。
		如果當前視窗不處於 diff 模式，返回 0。

diff_hlID({lnum}, {col})				*diff_hlID()*
		返回 diff 模式行 {lnum} 和列 {col} (位元組位置) 所在的高亮 ID。
		如果當前行沒有差異，返回零。
		{lnum} 的用法類似於 |getline()|。所以 "." 是當前行，"'m" 是位
		置標記 m，等等。
		最左列的 {col} 為 1，第一行的 {lnum} 為 1。
		高亮 ID 可以用於 |synIDattr()|，以得到高亮對應的語法資訊。

empty({expr})						*empty()*
		如果 {expr} 為空，返回數值 1，否則返回 0。
		- |List| 或 |Dictionary| 沒有專案時為空。
		- 數值或浮點數的值為零時為空。
		- |v:false|、|v:none| 和 |v:null| 為空，|v:true| 不是。
		- 啟動失敗的作業為空。
		- 己關閉的通道為空。

		如果 |List| 很大，這比把長度和零比較要快得多。

escape({string}, {chars})				*escape()*
		在 {string} 裡用反斜槓轉義 {chars} 裡的字元。例如: >
			:echo escape('c:\program files\vim', ' \')
<		返回: >
			c:\\program\ files\\vim
<		另見 |shellescape()|。

							*eval()*
eval({string})	計算 {string} 並返回其結果。這對把 |string()| 的結果轉換為原來
		的值尤其有用。適用於數值、浮點數、字串和兩者的複合型別。也可
		用於指向已有函式的 |Funcref|。

eventhandler()						*eventhandler()*
		如果在事件處理中則返回 1。此時，Vim 在等待使用者輸入一個字元的時
		候被中斷，比如，在 Vim 上拖放了一個檔案。這也意味著此時不能使
		用互動的命令。如果不是，返回零。

executable({expr})					*executable()*
		本函式檢查名字由 {expr} 指定的可執行檔案存在與否。{expr} 必須
		是程式不帶任何引數的名字。
		executable() 使用 $PATH 的值和/或程式的普通的搜尋路徑。
							*PATHEXT*
		MS-DOS 和 MS-Windows 上，可以可選地包含 ".exe"、".bat" 等。為
		此，$PATHEXT 裡的副檔名會被嘗試。這樣，如果 "foo.exe" 不存在，
		可能會找到 "foo.exe.bat"。如果沒有設定 $PATHEXT，使用的是
		".exe;.com;.bat;.cmd"。$PATHEXT 裡可以使用單獨的句號，以嘗試沒
		有副檔名的名字。如果 'shell' 看起來像 Unix 外殼，那麼也嘗試沒
		有副檔名的名字。
		MS-DOS 和 MS-Windows 上，只檢查是否檔案存在且不是目錄，並不檢
		查它是否真的可以執行。
		MS-Windows 上，和 Vim 在同一目錄的可執行檔案總能找到。因為這個
		目錄加到了 $PATH 裡，執行應該也沒有問題 |win32-PATH|。
		返回數值:
			1	存在
			0	不存在
			-1	此係統中沒有實現

execute({command} [, {silent}])					*execute()*
		執行 Ex 命令或命令序列，返回結果為字串。
		{command} 可以是字串或列表。如果是列表，逐行執行命令。
		等價於: >
			redir => var
			{command}
			redir END
<
		可選的 {silent} 引數可取以下的值:
			""		不用 `:silent`
			"silent"	用 `:silent`
			"silent!"	用 `:silent!`
		預設是 "silent"。注意 用 "silent!" 時，和 `:redir` 不同，錯誤
		被忽略。使用外部命令時，螢幕可能會搞亂，可用 `system()` 代替。
							*E930*
		{command} 裡不可用 `:redir`。

		要得到行的列表，在結果上用 |split()|: >
			split(execute('args'), "\n")

<		遞迴呼叫時，內層的輸出結果不包含在外層的結果裡。

exepath({expr})						*exepath()*
		如果 {expr} 是可執行檔案並且是絕對路徑、相對路徑或可在 $PATH
		是找到，返回完整路徑。
		注意 如果 {expr} 以 "./" 開始，使用當前路徑，這對 Vim 可能是個
		問題: >
			echo exepath(v:progpath)
<		如果 {expr} 在 $PATH 裡找不到，或者不可執行，返回空字串。

							*exists()*
exists({expr})	返回數值，如果 {expr} 被定義，返回 |TRUE|，不然返回零。

		要檢查某特性是否支援，用 |has()|。
		要檢查檔案是否存在，用 |filereadable()|。

		{expr} 引數是字串，可以使用以下選擇之一:
			&option-name	Vim 選項 (只檢查是否存在，而不是是否工
					作)
			+option-name	能工作的 Vim 選項。
			$ENVNAME	環境變數 (也可以通過和空字串比較完
					成)
			*funcname	內建函式 (見 |functions|) 或者使用者定義
					的函式 (見 |user-functions|)。也可用於
					指向函式引用的變數。
			varname		內部變數 (見 |internal-variables|)。也
					適用於 |curly-braces-names|、
					|Dictionary| 專案、|List| 專案等等。
					小心計算索引時可能會因為非法的表示式產
					生錯誤資訊。例如: >
					   :let l = [1, 2, 3]
					   :echo exists("l[5]")
<					   0 >
					   :echo exists("l[xx]")
<					   E121: Undefined variable: xx
					   0

			:cmdname	Ex 命令: 內建命令、使用者命令或者命令修
					飾符 |:command|。
					返回:
					1  匹配命令的開始
					2  完整匹配命令
					3  匹配多個使用者命令
					要檢查命令是否支援，檢查返回值是否為
					2。
			:2match		|:2match| 命令。
			:3match		|:3match| 命令。
			#event		符合此事件的自動命令
			#event#pattern	符合此事件和此模式的自動命令 (模式按本
					義出現，和自動命令的模式逐字元比較)
			#group		存在自動命令組
			#group#event	在該組裡定義並符合此事件的自動命令。
			#group#event#pattern
					為該組定義、符合事件和模式的自動命令。
			##event		支援此事件的自動命令。

		例如: >
			exists("&shortname")
			exists("$HOSTNAME")
			exists("*strftime")
			exists("*s:MyFunc")
			exists("bufcount")
			exists(":Make")
			exists("#CursorHold")
			exists("#BufReadPre#*.gz")
			exists("#filetypeindent")
			exists("#filetypeindent#FileType")
			exists("#filetypeindent#FileType#*")
			exists("##ColorScheme")
<		符號 (&/$/*/#) 和名字之間不能有空格。
		名字之後不能有附加字元，雖然現在有一些情況下會忽略這些字元，但
		將來的檢查可能更嚴格。所以不要依賴此行為！
		可以通過的例子: >
			exists(":make")
<		_不_能通過的例子: >
			exists(":make install")

<		注意 引數必須是字串，不是變數的名字本身。例如: >
			exists(bufcount)
<		不檢查 "bufcount" 變數是否存在，而是提取 "bufcount" 的值，並檢
		查其 (根據此處的語法) 是否存在。

exp({expr})						*exp()*
		返回 {expr} 的指數函式值，返回值為 [0, inf] 區間內的浮點數。
		{expr} 的計算結果必須是浮點數或數值。
		示例: >
			:echo exp(2)
<			7.389056 >
			:echo exp(-1)
<			0.367879
		{僅當編譯時加入 |+float| 特性才有效}


expand({expr} [, {nosuf} [, {list}]])				*expand()*
		擴充套件 {expr} 裡的萬用字元和下列特殊關鍵字。
		'wildignorecase' 此處適用。

		如果給出 {list} 且為 |TRUE|，返回列表。否則返回的是字串，且
		如果返回多個匹配，以 <NL> 字元分隔 [備註: 5.0 版本使用空格。但
		是檔名如果也包含空格就會有問題]。

		如果擴充套件失敗，返回空字串。如果 {expr} 以 '%'，'#' 或 '<' 開
		始，不返回不存在的檔名。詳見下。

		如果 {expr} 以 '%'、'#' 或 '<' 開始，以類似於
		|cmdline-special| 變數的方式擴充套件，包括相關的修飾符。這裡是一個
		簡短的小結:

			%		當前檔名
			#		輪換檔名
			#n		輪換檔名 n
			<cfile>		游標所在的檔名
			<afile>		自動命令檔名
			<abuf>		自動命令緩衝區號 (以字串形式出現！)
			<amatch>	自動命令匹配的名字
			<sfile>		載入的指令碼檔案或函式名
			<slnum>		載入指令碼檔案行號
			<cword>		游標所在的單詞
			<cWORD>		游標所在的字串 (WORD)
			<client>	最近收到的訊息的 {clientid}
					|server2client()|
		修飾符:
			:p		擴充套件為完整的路徑
			:h		頭部 (去掉最後一個部分)
			:t		尾部 (只保留最後一個部分)
			:r		根部 (去掉一個副檔名)
			:e		只有副檔名

		例如: >
			:let &tags = expand("%:p:h") . "/tags"
<		注意 擴充套件 '%'、'#' 或者 '<' 開頭的字串的時候，其後的文字被忽
		略。這樣_不_行: >
			:let doesntwork = expand("%:h.bak")
<		應該這樣: >
			:let doeswork = expand("%:h") . ".bak"
<		還要 注意  擴充套件 "<cfile>" 和其它形式只能返回被引用的檔名，而
		不會進一步擴充套件。如果 "<cfile>" 是 "~/.cshrc"，你需要執行另一個
		expand() 把 "~/" 擴充套件為主目錄的路徑: >
			:echo expand(expand("<cfile>"))
<
		變數名和其後的修飾符之間不能有空白。|fnamemodify()| 函式可以用
		來修改普通的檔名。

		使用 '%' 或 '#' 但當前或輪換檔名沒有定義的時候，使用空字元
		串。在無名緩衝區使用 "%:p"  生成當前目錄，後加一個 '/'。

		如果 {expr} 不以 '%'、'#' 或 '<' 開始，它以命令列上的檔名那
		樣被擴充套件。使用 'suffixes' 和 'wildignore'，除非給出可選的
		{nosuf} 引數而且為 |TRUE|。
		這裡可以有不存在的檔案的名字。"**" 專案可以用來在目錄樹裡查詢
		。例如，要尋找當前目錄及其下目錄的所有的 "README": >
			:echo expand("**/README")
<
		expand() 也可用來擴充套件變數和只有外殼知道的環境變數。但這會很
		慢，因為需要使用外殼才能進行擴充套件。見 |expr-env-expand|。
		擴充套件後的變數還是被當作檔名的列表處理。如果不能擴充套件環境變數，
		保留其不變。這樣， ":echo expand('$FOOBAR')" 返回的還是
		"$FOOBAR"。

		|glob()| 說明如何找到存在的檔案。|system()| 說明如何得到外部命
		令的原始輸出。

extend({expr1}, {expr2} [, {expr3}])			*extend()*
		{expr1} 和 {expr2} 必須都是 |List| 或者都是 |Dictionary|。

		如果都是 |List|: 把 {expr2} 附加到 {expr1} 之後。
		如果給出 {expr3}，把 {expr2} 裡的專案加到 {expr1} 的第 {expr3}
		個專案之前。如果 {expr3} 為零，插在第一個專案之前。如果
		{expr3} 等於 len({expr1})，那麼 {expr2} 會附加在最後。
		例如: >
			:echo sort(extend(mylist, [7, 5]))
			:call extend(mylist, [2, 3], 1)
<		如果 {expr1} 和 {expr2} 是同一個列表，複製的專案數等於列表原來
		的長度。例如，如果 {expr} 為 1，則複製列表首值 N 次 (N 是列表
		原來的長度)。
		用 |add()| 把一個專案加入列表。要連線兩個列表成為一個新列表，
		用 + 操作符: >
			:let newlist = [1, 2, 3] + [4, 5]
<
		如果都是 |Dictionary|: 把 {expr2} 裡的所有專案加入 {expr1}。
		如果 {expr1} 和 {expr2} 包含相同的鍵，那麼 {expr3} 決定應該怎
		麼做:
		{expr3} = "keep": 保持 {expr1} 的值
		{expr3} = "force": 使用 {expr2} 的值
		{expr3} = "error": 給出錯誤資訊				*E737*
		如果省略 {expr3}，假設使用 "force"。

		只要 {expr2} 非空，{expr1} 就被改變。如果需要，給 {expr1} 先做
		個備份。
		{expr2} 保持不變。
		如果 {expr1} 被鎖住且 {expr2} 非空，操作失敗。
		返回 {expr1}。


feedkeys({string} [, {mode}])				*feedkeys()*
		將 {string} 裡的字元放在佇列裡等候處理，就像它們來自對映或者用
		戶輸入一樣。
		預設它們加在預輸入 (typeahead) 緩衝區的尾端，所以如果
		仍然在執行對映，這些字元會出現在對映內容之後。用 'i' 標誌位則
		插入位置在其它字元之前，這樣，它們在對映其它字元之前就會執行。
		該函式不會等待 {string} 包含的鍵處理完畢。
		{string} 如果要包含特殊鍵，可以使用雙引號和 "\..." 記法
		|expr-quote|。例如，feedkeys("\<CR>") 會模擬 <Enter> 鍵擊。但
		feedkeys('\<CR>') 卻實際壓入五個字元。
		如果不給出 {mode}，這些鍵會經過重對映。
		{mode} 是字串，包含以下字元標誌位:
		'm'	對鍵重對映。預設。
		'n'	不對鍵重對映。
		't'	像使用者輸入那樣處理鍵；如果不包含，像來自對映一樣處理。
			這會影響撤銷、開啟摺疊等行為。
		'i'	插入字串而不是附加 (見上)。
		'x'	執行命令，直至預輸入為空為止。和 ":normal!" 類似。可以
			不帶 'x' 執行 feedkeys() 數次，然後一次性執行帶 'x' 的
			(可以只帶空 {string}) 來執行所有的輸入。注意 Vim 退出
			插入模式時行為就如同按了 <Esc> 那樣，以避免在指令碼可以
			繼續前等待字元鍵入的阻塞情況。
		'!'	使用 'x' 時不停止插入模式。可用於使定時器稍晚點才退出
			插入狀態的測試環境。對測試 CursorHoldI 有用。

		返回值總為 0。

filereadable({file})					*filereadable()*
		返回數值，如果名為 {file} 的檔案存在且可讀，則為 |TRUE|。如果
		{file} 不存在，或者是一個目錄，返回 |FALSE|。{file} 可以是任何
		返回字串的表示式。
		如果你不關心檔案是否可讀，可用 |glob()|。
							*file_readable()*
		已廢棄的名字: file_readable()。


filewritable({file})					*filewritable()*
		返回數值，如果名為 {file} 的檔案存在且可寫，則為 1。如果
		{file} 不存在，或者不可寫，返回 0。如果 {file} 是一個目錄但是
		可寫，返回 2。


filter({expr1}, {expr2})				*filter()*
		{expr1} 必須是 |List| 或者 |Dictionary|。
		對 {expr1} 裡的每個專案計算 {expr2}，如果結果為零，從該 |List|
		或 |Dictionary| 裡刪除該專案。
		{expr2} 必須是 |string| 或 |Funcref|。

		如果 {expr2} 是 |string|，{expr2} 內的 |v:val| 包含當前專案的
		值。|Dictionary| 中 |v:key| 包含當前專案的鍵。|List| 中
		|v:key| 包含當前專案的索引。
		例如: >
			call filter(mylist, 'v:val !~ "OLD"')
<		刪除所有出現 "OLD" 的專案。 >
			call filter(mydict, 'v:key >= 8')
<		刪除所有鍵小於 8 的值。 >
			call filter(var, 0)
<		刪除所有的值，從而清除該 |List| 或 |Dictionary|。

		如果 {expr2} 是 |Funcref|，它必須接受兩個引數:
			1. 當前專案的鍵或索引。
			2. 當前專案的值。
		如果該專案應保留，此函式必須返回 |TRUE|。
		例如要保留列表中奇數專案: >
			func Odd(idx, val)
			  return a:idx % 2 == 1
			endfunc
			call filter(mylist, function('Odd'))
<		使用 |lambda| 會更短: >
			call filter(myList, {idx, val -> idx * val <= 42})
<		如果不用 "val"，可以不寫: >
			call filter(myList, {idx -> idx % 2 == 1})
<
		該操作是原位操作 (直接在輸入上修改)。要想不更動 |List| 或
		|Dictionary|，先建立備份: >
			:let l = filter(copy(mylist), 'v:val =~ "KEEP"')

<		返回 {expr1}，經過過濾的 |List| 或 |Dictionary|。如果執行
		{expr2} 有錯，不再處理 {expr1} 的其餘專案。{expr2} 是函式引用
		時，忽略函式裡的錯誤，除非該函式用 "abort" 標誌位定義。


finddir({name}[, {path}[, {count}]])				*finddir()*
		在 {path} 裡查詢目錄 {name}。支援向下和向上的遞迴目錄搜尋。
		{path} 的語法參見 |file-searching|。
		返回第一個找到的路徑。如果找到的
		路徑在當前目錄之下，返回相對路徑。否則，返回完整路徑。
		如果省略 {path}，使用 'path'。
		如果給出可選的 {count}，尋找 {path} 裡 {name} 第 {count} 次出
		現，而不是第一次。
		如果 {count} 為負，返回所有的匹配的列表。
		這和 ex 命令 |:find| 非常類似。
		{僅當編譯時加入 |+file_in_path| 特性才有效}

findfile({name}[, {path}[, {count}]])				*findfile()*
		類似於 |finddir()|，不過尋找檔案而不是目錄。
		使用 'suffixesadd'。
		例如: >
			:echo findfile("tags.vim", ".;")
<		從當前檔案所在的目錄開始往上搜索，直到找到檔案 "tags.vim" 為
		止。

float2nr({expr})					*float2nr()*
		返回數值，即 {expr} 省略小數點部分的結果。
		{expr} 的計算結果必須是浮點數或數值。
		如果 {expr} 的值超出 |Number| 的範圍，結果為 0x7fffffff 或
		-0x7fffffff (有 64-位 數值支援時，則為 0x7fffffffffffffff 或
		-0x7fffffffffffffff)。而 NaN 轉換為 -0x80000000 (有64-位數
		值支援時，則為 -0x8000000000000000)。
		示例: >
			echo float2nr(3.95)
<			3  >
			echo float2nr(-23.45)
<			-23  >
			echo float2nr(1.0e100)
<			2147483647  (或 9223372036854775807) >
			echo float2nr(-1.0e150)
<			-2147483647 (或 -9223372036854775807) >
			echo float2nr(1.0e-100)
<			0
		{僅當編譯時加入 |+float| 特性才有效}


floor({expr})							*floor()*
		返回浮點數，即小於等於 {expr} 的最大整數 (向下取整)。
		{expr} 的計算結果必須是浮點數或數值。
		示例: >
			echo floor(1.856)
<			1.0  >
			echo floor(-5.456)
<			-6.0  >
			echo floor(4.0)
<			4.0
		{僅當編譯時加入 |+float| 特性才有效}


fmod({expr1}, {expr2})					*fmod()*
		返回 {expr1} / {expr2} 的餘數，該除法可能實際無法表達出來。選
		擇某整數 i，返回 {expr1} - i * {expr2}，使得如果 {expr2} 非
		零，結果和 {expr1} 同號而絕對值小於 {expr2} 的絕對值。如果
		{expr2} 為零，返回零。返回值為浮點數。
		{expr1} 和 {expr2} 的計算結果必須是浮點數或數值。
		示例: >
			:echo fmod(12.33, 1.22)
<			0.13 >
			:echo fmod(-12.33, 1.22)
<			-0.13
		{僅當編譯時加入 |+float| 特性才有效}


fnameescape({string})					*fnameescape()*
		轉義 {string} 以便用作命令的檔名引數。有特殊意義的字元，如
		'%' 和 '|'，會用反斜槓轉義。
		多數系統上，會轉義的字元是 " \t\n*?[{`$\\%#'\"|!<"。在反斜槓可
		以出現在檔名中的系統上，此字符集取決於 'isfname'。
		也轉義出現在開頭的 '+' 和 '>' 字元 (|:edit| 和 |:write| 之後有
		特殊意義)，還有單個出現的 "-" (|:cd| 之後有特殊意義)。
		示例: >
			:let fname = '+some str%nge|name'
			:exe "edit " . fnameescape(fname)
<		則會執行: >
			edit \+some\ str\%nge\|name

fnamemodify({fname}, {mods})				*fnamemodify()*
		根據 {mods} 修改檔名 {fname}。{mods} 是一個字元序列組成的字
		符串，就像命令列上使用的檔名那樣。見 |filename-modifiers|。
		例如: >
			:echo fnamemodify("main.c", ":p:h")
<		返回: >
			/home/mool/vim/vim/src
<		注意: 環境變數不能用於 {fname}，需要先用 |expand()| 擴充套件。

foldclosed({lnum})					*foldclosed()*
		返回數值，如果行 {lnum} 在關閉的摺疊中，返回該摺疊開始的行號。
		如果行 {lnum} 不在關閉的摺疊中，返回 -1。

foldclosedend({lnum})					*foldclosedend()*
		返回數值，如果行 {lnum} 在關閉的摺疊中，返回該摺疊結束的行號。
		如果行 {lnum} 不在關閉的摺疊中，返回 -1。

foldlevel({lnum})					*foldlevel()*
		返回數值，當前緩衝區第 {lnum} 行的摺疊級別。如果在巢狀的摺疊
		裡，返回最深的那層。如果行 {lnum} 沒有摺疊，返回零。這和摺疊是
		開啟還是關閉無關。在更新摺疊時 (在 'foldexpr' 裡)，如果摺疊還
		在更新而相應的摺疊級別未知，返回 -1。一個特例是前一行的級別通
		常總是知道的。

							*foldtext()*
foldtext()	返回關閉的摺疊所顯示的行。這是 'foldtext' 選項使用的預設函式，
		而且也只應該在計算 'foldtext' 時使用。它使用 |v:foldstart|、
		|v:foldend| 和 |v:folddashes| 變數。
		返回的字串看起來像: >
			+-- 45 lines: abcdef
<		開頭的連字元的數目取決於摺疊級別。"45" 是摺疊的行數。"abcdef"
		是摺疊第一個非空白行的文字。開頭的空白、"//" 和 "/*" 還有
		'foldmarker' 和 'commentstring' 選項的文字都被去除。
		{僅當編譯時加入 |+folding| 特性才有效}

foldtextresult({lnum})					*foldtextresult()*
		返回行 {lnum} 所在的關閉的摺疊顯示的文字。在合適的上下文裡計算
		'foldtext'。
		如果 {lnum} 沒有關閉的摺疊，返回空字串。
		{lnum} 的用法類似於 |getline()|。所以 "." 是當前行，"'m" 是位
		置標記 m，等等。
		可用於輸出摺疊文字，例如，到 HTML 格式。
		{僅當編譯時加入 |+folding| 特性才有效}

							*foreground()*
foreground()	把 Vim 視窗帶到前臺。用於從客戶傳送到 Vim 伺服器的時候。
		|remote_send()|
		在 Win32 系統上，可能不行，作業系統並不總能允許視窗把自己帶到
		前臺。這時應使用 |remote_foreground()|。
		{僅當使用 Win32、Athena、Motif 和 GTK GUI 版本和 Win32 控制檯
		版本時才有效}

						*funcref()*
funcref({name} [, {arglist}] [, {dict}])
		類似於 |function()|，但返回的函式引用通過引用來查詢函式，而不
		是名字。如果函式 {name} 之後被重定義，這很有意義。

		和 |function()| 不同，{name} 必須是已經定義的使用者函式。自動載
		入函式也可以。{name} 不能是內建函式。

					*function()* *E700* *E922* *E923*
function({name} [, {arglist}] [, {dict}])
		返回指向函式 {name} 的 |Funcref| 變數。{name} 可以是使用者定義的
		函式或者內部函式的名字。

		{name} 可以是函式引用或偏函式。如果是偏函式，會使用其儲存的字
		典，而不接受 {dict} 引數。例如: >
			let FuncWithArg = function(dict.Func, [arg])
			let Broken = function(dict.Func, [arg], dict)
<
		使用函式引用時，通過 {name} 查詢函式，即使以後被重定義了亦然。
		要保留相同的函式，用 |funcref()|。

		提供 {arglist} 或 {dict} 則會建立偏函式。這意味著引數列表和/或
		字典會存放在函式引用裡，並在呼叫函式引用時使用。

		引數被傳遞到函式裡，在其它引數之前。例如: >
			func Callback(arg1, arg2, name)
			...
			let Func = function('Callback', ['one', 'two'])
			...
			call Func('name')
<		函式的呼叫就類似於: >
			call Callback('one', 'two', 'name')

<		function() 呼叫可以巢狀，來給函式引用加入更多的引數。額外的參
		數附加於引數列表之後。如: >
			func Callback(arg1, arg2, name)
			...
			let Func = function('Callback', ['one'])
			let Func2 = function(Func, ['two'])
			...
			call Func2('name')
<		函式的呼叫就類似於: >
			call Callback('one', 'two', 'name')

<		字典只對 "dict" 函式的呼叫有用。該情況下，{dict} 作為 "self"
		傳入。例如: >
			function Callback() dict
			   echo "called for " . self.name
			endfunction
			...
			let context = {"name": "example"}
			let Func = function('Callback', context)
			...
			call Func()	" 會回顯: called for example
<		如果不需額外引數，function() 是沒有必要的。這兩者等價: >
			let Func = function('Callback', context)
			let Func = context.Callback

<		可以合併引數列表和字典: >
			function Callback(arg1, count) dict
			...
			let context = {"name": "example"}
			let Func = function('Callback', ['one'], context)
			...
			call Func(500)
<		函式的呼叫就類似於: >
			call context.Callback('one', 500)


garbagecollect([{atexit}])				*garbagecollect()*
		清理不再使用但有迴圈引用的 |List| 、|Dictionary|、|Channel| 和
		|Job|。

		幾乎沒有需要呼叫這個函式，因為 Vim 記憶體不足或者 'updatetime'
		之後等待使用者按鍵時會自動執行此功能。沒有迴圈引用的專案總是在不
		再使用的時候就被立即釋放了。
		可用於刪除很大的 |List| 和/或 |Dictionary| 而且有迴圈引用的時
		候，尤其是在要執行很長時間的腳本里。

		如果可選的 {atexit} 引數為一，並且之前還沒做過的話，Vim 即使在
		退出時也會執行垃圾回收。可用於檢查記憶體洩漏。

		垃圾清理不是立即進行的，它會等待安全的時機，就是等待使用者輸入字
		符的時候。要強制立即進行垃圾清理，可用
		|test_garbagecollect_now()|。

get({list}, {idx} [, {default}])			*get()*
		獲取 |List| {list} 的第 {idx} 個專案。如果不存在此專案，返回
		{default}。如果省略 {default}，返回零。
get({dict}, {key} [, {default}])
		獲取 |Dictionary| {dict} 鍵為 {key} 的專案。如果不存在此專案，
		返回 {default}。如果省略 {default}，返回零。
get({func}, {what})
		獲取 函式引用 {func} 的專案。{what} 的可能值是:
			"name"	函式名
			"func"	函式
			"dict"	字典
			"args"	引數列表

							*getbufinfo()*
getbufinfo([{expr}])
getbufinfo([{dict}])
		獲取字典列表形式的緩衝區資訊。

		不帶引數則返回關於所有緩衝區的資訊。

		只給出字典引數時，返回匹配相關條件的緩衝區。{dict} 中可指定以
		下鍵值:
			buflisted	只包含在列表內的緩衝區。
			bufloaded	只包含已載入的緩衝區。

		否則，{expr} 指定特定的單個緩衝區並返回其資訊。{expr} 的用法見
		上述 |bufname()|。如果找到緩衝區，返回的列表有一個專案。不然
		返回空列表。

		每個返回的列表專案是帶有以下專案的字典:
			bufnr		緩衝區號。
			changed		若緩衝區已修改則為 TRUE。
			changedtick	緩衝區作過的改動次數。
			hidden		若緩衝區隱藏則為 TRUE。
			listed		若緩衝區在列表內，則為 TRUE。
			lnum		緩衝區的當前行號。
			loaded		若緩衝區已載入則為 TRUE。
			name		緩衝區檔案的完整列表。
			signs		緩衝區內放置的標號的列表。
					每個列表專案是以下專案的字典:
					    id	  標號的識別符
					    lnum  行號
					    name  標號名
			variables	緩衝區區域性變數的字典的引用。
			windows		顯示此緩衝區的所有 |window-ID| 的列表

		示例: >
			for buf in getbufinfo()
			    echo buf.name
			endfor
			for buf in getbufinfo({'buflisted':1})
			    if buf.changed
				....
			    endif
			endfor
<
		要獲取緩衝區區域性選項，可用: >
			getbufvar({bufnr}, '&')

<
							*getbufline()*
getbufline({expr}, {lnum} [, {end}])
		返回 {expr} 緩衝區的第 {lnum} 到 {end} (包含) 行的 |List|。如
		果省略 {end}，返回只有一行 {lnum} 的 |List|。

		關於 {expr} 的用法，見上 |bufname()|。

		{lnum} 和 {end} 可以使用 "$" 來表示緩衝區的最後一行。除此以
		外，必須用數值。

		如果 {lnum} 小於 1 或大於緩衝區的行數，返回空 |List|。

		如果 {end} 大於緩衝區的行數，就把它當成緩衝區的行數。如果
		{end} 在 {lnum} 之前，返回空 |List|。

		此函式只能用於已經載入的緩衝區。未載入或不存在的緩衝區總是返回
		空 |List|。

		例如: >
			:let lines = getbufline(bufnr("myfile"), 1, "$")

getbufvar({expr}, {varname} [, {def}])				*getbufvar()*
		返回緩衝區 {expr} 裡的選項或者區域性變數 {varname} 的值。注意 必
		須使用不帶 "b:" 的名字。
		如果 {varname} 為空，返回包含所有緩衝區區域性變數的字典。
		如果 {varname} 為 "&"，返回包含所有緩衝區區域性選項的字典。
		否則，如果 {varname} 以 "&" 開始，返回單個緩衝區區域性選項值。
		也可用於全域性或者區域性於緩衝區的選項，但不能用於全域性或者區域性於窗
		口的變數，還有區域性於視窗的選項。
		關於 {expr} 的使用方式，見上 |bufname()|。
		如果緩衝區或者變數不存在，返回 {def} 或空字串。不會有錯誤消
		息。
		示例: >
			:let bufmodified = getbufvar(1, "&mod")
			:echo "todo myvar = " . getbufvar("todo", "myvar")
<
getchar([expr])						*getchar()*
		從使用者或輸入流中提取單個字元。
		如果忽略 [expr]，等待直到有字元輸入為止。
		如果 [expr] 為 0，只有在有字元可用時才取得字元，否則返回零。
		如果 [expr] 為 1，只檢查是否有字元可用，並不消耗該字元。如果沒
				  有字元，返回零。

		如果沒有 [expr] 或者 [expr] 為零，返回整個字元或者特殊鍵。如果
		是 8 位字元，以數值形式返回。用 nr2char() 把它轉化成字串。否
		則返回經過編碼的字元構成的字串。如果是特殊鍵，返回一串位元組，
		以 0x80 (十進位制: 128) 開始。它和字串 "\<Key>" 等值，例如
		"\<Left>"。如果用帶修飾符 (Shift，Control， Alt) 的字元而字元
		本身不包含該修飾符時，返回值也用字串型別。

		如果 [expr] 為 0 並已鍵入 Esc，會有短暫的延遲，以便 Vim 有機會
		判斷是否是轉義序序列的開始。

		如果 [expr] 為 1，只返回第一個位元組。如果是單位元組字元，返回的就
		是該字元自身的數值形式。用 nr2char() 把它轉化為字串。

		getcharmod() 可用於得到附加的修飾符。

		使用者點選滑鼠時，返回滑鼠事件。所在的位置可以在 |v:mouse_col|、
		|v:mouse_lnum| 、|v:mosue_winid| 和 |v:mouse_win| 裡找到。下例
		用通常的處理方法定位滑鼠: >
			let c = getchar()
		  	if c == "\<LeftMouse>" && v:mouse_win > 0
			  exe v:mouse_win . "wincmd w"
			  exe v:mouse_lnum
			  exe "normal " . v:mouse_col . "|"
			endif
<
		使用括號內貼上模式時，只返回首個字元。貼上文字其餘部分被丟棄。
		|xterm-bracketed-paste|。

		這裡沒有提示，你需要想辦法告訴使用者，需要輸入一個字元。
		字元不通過對映。
		鍵碼被替換。因而，使用者輸入 <Del> 鍵時，你得到 <Del> 的鍵碼，而
		不是原始的字元序列。比如: >
			getchar() == "\<Del>"
			getchar() == "\<S-Left>"
<		下例重新定義 "f"，使它忽略大小寫: >
			:nmap f :call FindChar()<CR>
			:function FindChar()
			:  let c = nr2char(getchar())
			:  while col('.') < col('$') - 1
			:    normal l
			:    if getline('.')[col('.') - 1] ==? c
			:      break
			:    endif
			:  endwhile
			:endfunction
<
		也可能收到模擬字元，例如 |<CursorHold>|。通常你想忽略之跳到下
		個字元: >
			:function GetKey()
			:  let c = getchar()
			:  while c == "\<CursorHold>"
			:    let c = getchar()
			:  endwhile
			:  return c
			:endfunction

getcharmod()						*getcharmod()*
		返回數值，反映最近用 getchar() 或其它方式輸入字元的修飾符狀
		態。這些值可以相加:
			2	Shift
			4	Control
			8	Alt (Meta)
			16	Meta (當和 ALT 不同時)
			32	滑鼠雙擊
			64	滑鼠三擊
			96	滑鼠四擊 (== 32 + 64)
			128	Command (僅限於 Macintosh)
		只有沒有包含字元本身的修飾符被返回。因而，Shift-a 產生沒有修飾
		符的 "A"。

getcharsearch()						*getcharsearch()*
		以 {dict} 形式返回當前字元搜尋資訊，帶有以下專案:

		    char	上次字元搜尋 (|t|、|f|、|T| 或 |F|) 使用的字
		    		符；空字串代表沒有字元搜尋進行過
		    forward	字元搜尋的方向；1 為正向，0 為反向
		    until	字元搜尋的型別；1 為 |t| 為 |T| 字元搜尋，0 為
		    		|f| 或 |F| 字元搜尋

		可用於使 |;| 和 |,| 永遠進行正向/反向搜尋而不管上次字元搜尋的
		方向: >
			:nnoremap <expr> ; getcharsearch().forward ? ';' : ','
			:nnoremap <expr> , getcharsearch().forward ? ',' : ';'
<		另見 |setcharsearch()|。

getcmdline()						*getcmdline()*
		返回當前命令列。只有在編輯命令列時有效，所以必須在
		|c_CTRL-\_e| 或 |c_CTRL-R_=| 裡使用。
		例如: >
			:cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR>
<		另見 |getcmdtype()|、|getcmdpos()| 和 |setcmdpos()|。

getcmdpos()					*getcmdpos()*
		返回命令列的位元組計算的游標位置。第一列為 1。
		只有在編輯命令列時有效，所以必須在 |c_CTRL-\_e| 或
		|c_CTRL-R_=| 或表示式對映裡使用。
		不然，返回 0。
		另見 |getcmdtype()|、|setcmdpos()| 和 |getcmdline()|。

getcmdtype()						*getcmdtype()*
		返回當前命令列型別。可能的返回值是:
		    :	普通 Ex 命令
		    >	除錯模式命令 |debug-mode|
		    /	正向搜尋命令
		    ?	反向搜尋命令
		    @	|input()| 命令
		    -	|:insert| 或 |:append| 命令
		    =	|i_CTRL-R_=|
		只能在編輯命令列時呼叫，因而必須在 |c_CTRL-\_e| 或
		|c_CTRL-R_=| 或表示式對映裡使用。
		否則，返回空字串。
		另見 |getcmdpos()|、|setcmdpos()| 和 |getcmdline()|。

getcmdwintype()						*getcmdwintype()*
		返回當前 |command-line-window| 型別。可能的返回值和
		|getcmdtype()| 相同。如果不在命令列視窗內，返回空字串。

getcompletion({pat}, {type} [, {filtered}])		*getcompletion()*
		返回命令列補全匹配列表。{type} 指定型別。支援以下的匹配型別:

		augroup		自動命令組
		buffer		緩衝區名
		behave		:behave 子選項
		color		色彩方案
		command		Ex 命令 (及引數)
		compiler	編譯器
		cscope		|:cscope| 子選項
		dir		目錄名
		environment	環境變數名
		event		自動命令事件
		expression	Vim 表示式
		file		檔案和目錄名
		file_in_path	|'path'| 中的檔案和目錄名
		filetype	檔案型別名 |'filetype'|
		function	函式名
		help		幫助主題
		highlight	高亮組
		history		:history 子選項
		locale		locale 名 (可見 locale -a 的輸出)
		mapping		對映名
		menu		選單
		messages	|:messages| 子選項
		option		選項
		packadd		可選包 |pack-add| 名
		shellcmd	外殼命令
		sign		|:sign| 子選項
		syntax		語法檔名 |'syntax'|
		syntime		|:syntime| 子選項
		tag		標籤
		tag_listfiles	標籤、檔名
		user		使用者名稱
		var		使用者變數

		如果 {pat} 為空串，返回所有匹配。否則只返回匹配 {pat} 的專案。
		關於 {pat} 中特殊字元的使用，見 |wildcards|。

		如果可選的 {filtered} 標誌位設為 1，應用 'wildignore' 來過濾結
		果。否則返回所有匹配。'wildignorecase' 選項則總是有效。

		如果沒有匹配，返回空列表。如果 {type} 為非法值，報錯。

							*getcurpos()*
getcurpos()	返回游標位置。類似於 getpos('.')，但包含在列表中一個額外的項
		目:
		    [bufnum, lnum, col, off, curswant] ~
		"curswant" 數值是垂直移動游標時的首選列。另見 |getpos()|。

		可用於儲存和恢復游標位置: >
			let save_cursor = getcurpos()
			移動游標
			call setpos('.', save_cursor)
<		注意 這隻適用於同一視窗內的移動。要恢復更多狀態，見
		|winrestview()|。
							*getcwd()*
getcwd([{winnr} [, {tabnr}]])
		返回字串，當前工作目錄的名字。
		無引數時，對應當前視窗。

		有 {winr} 則返回當前標籤頁的該視窗的本地當前目錄。
		有 {winr} 和 {tabnr} 則返回指定標籤頁的該視窗的本地當前目錄。
		{winr} 可以是視窗號或 |window-ID|。
		如果引數非法，返回空串。

getfsize({fname})					*getfsize()*
		返回數值，檔案 {fname} 以位元組數計算的大小。
		如果 {fname} 是目錄，返回 0。
		如果找不到檔案 {fname}，返回 -1。
		如果 {fname} 檔案過大，超出了 Vim 的數值的範圍，返回 -2。

getfontname([{name}])					*getfontname()*
		如果沒有引數，返回使用的正常字型的名字，也就是 Normal 高亮組
		|hl-Normal| 使用的。
		如果帶了引數，檢查 {name} 是否合法的字型名。如果不是，返回空字
		符串。否則，返回實際的字型名，或者如果 GUI 不支援取得真正的名
		字，返回 {name}。
		只有在 GUI 執行的時候才能用，所以不能用於你的 vimrc 和 gvimrc
		檔案。用 |GUIEnter| 自動命令可以在 GUI 剛開始之後使用此函式。
		注意 GTK GUI 接受任何字型名，所以不會檢查名字是否合法。

getfperm({fname})					*getfperm()*
		返回字串，給定檔案 {fname} 的讀、寫、執行許可權。
		如果 {fname} 不存在或者它所在的目錄無法讀取，返回空字串。
		返回值的形式是 "rwxrwxrwx"，其中每組 "rwx" 標誌位分別代表檔案
		所有者、檔案所屬組和其它使用者的許可權。如果使用者沒有某許可權，相應的
		標誌位被字串 "-" 代替。例如: >
			:echo getfperm("/etc/passwd")
			:echo getfperm(expand("~/.vimrc"))
<		希望它會 (從安全形度而言) 顯示字串 "rw-r--r--" 或者甚至
		"rw-------"。

		要設定許可權，可用 |setfperm()|。

getftime({fname})					*getftime()*
		返回數值，給定檔案 {fname} 的最新修改時間。該時間為 1970 年 1
		月 1 日開始計算的秒數，可以傳給 strftime()。
		另見 |localtime()| 和 |strftime()|。
		如果找不到檔案 {fname}，返回 -1。

getftype({fname})					*getftype()*
		返回字串，給定檔案 {fname} 的檔案型別的描述。
		如果 {fname} 不存在，返回空字串。
		下表列出各種不同檔案型別的返回值:
			普通檔案		"file"
			目錄			"dir"
			符號連結		"link"
			塊裝置			"bdev"
			字元裝置		"cdev"
			套接字			"socket"
			FIFO			"fifo"
			其它			"other"
		例如: >
			getftype("/home")
<		注意 只有在能支援的系統上才會返回 "link" 這樣的型別。有的系統
		只支援 "dir" 和 "file"。MS-Windows 上目錄的符號連結返回 "dir"
		而不是 "link"。

							*getline()*
getline({lnum} [, {end}])
		如果沒有 {end}，返回字串，即當前緩衝區第 {lnum} 行文字。
		例如: >
			getline(1)
<		如果 {lnum} 是不以數字開始的字串，呼叫 line() 來把該字串轉
		化成數值。要得到游標所在的行: >
			getline(".")
<		如果 {lnum} 小於 1 或者大於緩衝區的總行數，返回空字串。

		如果給出 {end}，返回 |List|，其中每個專案是當前緩衝區從 {lnum}
		到 {end} (包含) 範圍的一行。
		{end} 的用法同 {lnum}。
		安靜地忽略不存在的行。
		如果 {end} 在 {lnum} 之前，返回空 |List|。
		例如: >
			:let start = line('.')
			:let end = search("^$") - 1
			:let lines = getline(start, end)

<		要獲取其它緩衝區的文字行，見 |getbufline()|。

getloclist({nr}[, {what}])				*getloclist()*
		返回列表，包含視窗 {nr} 的位置列表的所有專案。{nr} 可以是視窗
		號或 |window-ID|。如果 {nr} 為 0，使用當前視窗。

		如果是位置列表視窗，返回其顯示的位置列表。如果視窗號 {nr} 非
		法，返回空列表。其它的情況和 |getqflist()| 相同。

		如果提供了可選的 {what} 字典引數，以字典形式返回 {what} 列出的
		專案。關於 {what} 支援的專案，可參考 |getqflist()|。

getmatches()						*getmatches()*
		返回之前 |matchadd()| 和 |:match| 命令定義的所有匹配組成的列表
		|List|。 |getmatches()| 常和 |setmatches()| 組合使用，因為
		|setmatches()| 可以恢復 |getmatches()| 儲存的匹配列表。
		示例: >
			:echo getmatches()
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
			:let m = getmatches()
			:call clearmatches()
			:echo getmatches()
<			[] >
			:call setmatches(m)
			:echo getmatches()
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
			:unlet m
<
							*getpid()*
getpid()	返回數值，即 Vim 程序的程序號。Unix 和 MS-Windows 上這是個唯一
		的數值，直到 Vim 退出為止。MS-DOS 上該值總為零。

							*getpos()*
getpos({expr})	得到 {expr} 的位置。可用的 {expr} 的值見 |line()|。要得到游標
		位置，見 |getcurpos()|。
		返回 |List|，包含四個數值:
		    [bufnum, lnum, col, off]
		"bufnum" 為零，除非使用了 '0 或 'A 這樣的位置標記，這時它是此
		位置標記所在的緩衝區號。
		"lnum" 和 "col" 是緩衝區裡的位置。第一列為 1。
		除非使用了 'virtualedit'。"off" 值為零，這是從對應字元開始位置
		的以螢幕列計的位移。例如，在製表之中或最後一個字元之後的某個位
		置。
		注意 '< 和 '> 和可視模式有關: "V" (可視行模式) 時 '< 的列為
		零，'> 的列為一大數。
		可以用來儲存和恢復游標位置: >
			let save_a_mark = getpos("'a")
			...
			call setpos("'a", save_a_mark)
<		另見 |getcurpos()| 和 |setpos()|。

getqflist([{what}])					*getqflist()*
		返回列表，包含所有當前 quickfix 錯誤。列表的每個專案是包含以下
		專案的字典:
			bufnr	有此檔名的緩衝區號，bufname() 得到緩衝區名
			lnum	緩衝區裡的行號 (第一行是 1)
			col	列號 (第一列是 1)
			vcol	|TRUE|: "col" 是可視列
				|FALSE|: "col" 是位元組位置
			nr	錯誤號
			pattern	用於定位錯誤的搜尋模式
			text	錯誤描述
			type	錯誤型別，'E'、'1' 等。
			valid	|TRUE|: 能識別該錯誤資訊

		如果沒有錯誤列表或者它為空，返回空列表。quickfix 列表專案如果
		包含不存在的緩衝區號，返回的 "bufnr" 置為零。

		應用: 在多個檔案裡尋找模式的匹配，並對之進行處理: >
			:vimgrep /theword/jg *.c
			:for d in getqflist()
			:   echo bufname(d.bufnr) ':' d.lnum '=' d.text
			:endfor
<
		如果提供了可選的 {what} 字典引數，以字典形式返回 {what} 列出的
		專案。{what} 支援以下字串專案:
			context	獲取 |setqflist()| 儲存的上下文
			items	獲取 quickfix 列表的專案
			nr	獲取關於指定 quickfix 列表的資訊；零代表當前
				quickfix 列表，'$' 代表最後的 quickfix 列表
			title	獲取列表標題
			winid	獲取 |window-ID| (如果開啟)
			all	上述所有的 quickfix 屬性
		忽略 {what} 中非字串專案。
		如果不給出 "nr"，使用當前 quickfix 列表。
		要取得 quickfix 棧的列表數目，在 {what} 中設定 'nr' 為 '$'。返
		回字典中的 'nr' 值會告訴你 quickfix 的棧大小。
		如果 {what} 的處理出錯，返回空字典。

		返回字典包含以下專案:
			context	|setqflist()| 儲存的上下文
			items	quickfix 列表的專案
			nr	quickfix 列表號
			title	quickfix 列表標題文字
			winid	quickfix |window-ID| (如果開啟)

		示例: >
			:echo getqflist({'all': 1})
			:echo getqflist({'nr': 2, 'title': 1})
<

getreg([{regname} [, 1 [, {list}]]])			*getreg()*
		返回字串，暫存器 {regname} 的內容。例如: >
			:let cliptext = getreg('*')
<		如果 {regname} 對應的暫存器沒有設過，返回空串。

		getreg('=') 返回最近一次表示式暫存器計算的返回值 (用於對映)。
		getreg('=', 1) 返回表示式自身，以便用 |setreg()| 恢復。對於其
		它暫存器，這個額外的引數被忽略，所以給出此引數總是無妨。

		如果 {list} 給出且為 |TRUE|，改變返回值為列表。每個列表項是一
		個文字行。如果你在意暫存器內可能存在的零位元組，可以用這種形式:
		不用第三個引數時 NL 和零位元組都用 NL 表示 (見
		|NL-used-for-Nul|) 。
		如果 {regname} 對應的暫存器沒有設過，返回空列表。

		如果沒有指定 {regname}，使用 |v:register|。


getregtype([{regname}])					*getregtype()*
		返回字串，暫存器 {regname} 的型別。
		該值會是以下可能之一:
		    "v"			|characterwise| (面向字元) 的文字
		    "V"			|linewise| (面向行) 的文字
		    "<CTRL-V>{width}"	|blockwise-visual| (面向列塊) 的文字
		    ""			空或者未知的暫存器
		<CTRL-V> 是一個字元，其值為 0x16。
		如果沒有指定 {regname}，使用 |v:register|。

gettabinfo([{arg}])					*gettabinfo()*
		如果沒指定 {arg}，返回列表，包含所有標籤頁的資訊。每個列表項是
		字典。
		否則，{arg} 指定標籤頁號，返回關於該標籤頁的資訊。如果該標誌頁
		不存在，返回空列表。

		每個列表項是包含以下專案的字典:
			tabnr		標籤頁號
			variables	包含標籤頁區域性變數的字典的引用
			windows		標籤頁中的 |window-ID| 列表。

gettabvar({tabnr}, {varname} [, {def}])				*gettabvar()*
		得到標籤頁 {tabnr} 的標籤頁區域性變數 {varname} 的值。|t:var|
		標籤頁的編號從一開始。
		如果 {varname} 為空，返回包含所有標籤頁區域性變數的字典。
		注意 必須使用不帶 "t:" 的名字。
		如果標籤頁或者變數不存在，返回 {def} 或空字串。不會有錯誤消
		息。

gettabwinvar({tabnr}, {winnr}, {varname} [, {def}])		*gettabwinvar()*
		得到標籤頁 {tabnr} 的視窗 {winnr} 的視窗區域性變數 {varname} 的
		值。
		如果 {varname} 為 "&"，返回包含所有視窗區域性選項的字典。
		否則，如果 {varname} 以 "&" 打頭，得到視窗區域性選項的值。
		如果 {varname} 為空，返回一個包含所有視窗區域性變數的字典。
		注意 {varname} 必須為不帶 "w:" 的名字。
		標籤頁的編號從一開始。當前標籤頁可用 |getwinvar()|。
		{winnr} 可以是視窗號或 |window-ID|。
		如果 {winnr} 為零，使用當前視窗。
		也可用於全域性或者區域性於緩衝區或區域性於視窗的選項，但不能用於全域性
		或者區域性於緩衝區的變數。
		如果標籤頁、視窗或者變數不存在，返回 {def} 或空字串。不會有
		錯誤訊息。
		例如: >
			:let list_is_on = gettabwinvar(1, 2, '&list')
			:echo "myvar = " . gettabwinvar(3, 1, 'myvar')
<
							*getwinposx()*
getwinposx()	返回數值，即 GUI Vim 視窗以畫素計從左起算的 X 座標。也適用於
		xterm。
		如果該資訊得不到，返回 -1。
		返回值可用於 ":winpos"。

							*getwinposy()*
getwinposy()	返回數值，即 GUI Vim 視窗以畫素計從頂部起算的 Y 座標。也適用於
		xterm。
		如果該資訊得不到，返回 -1。
		返回值可用於 ":winpos"。

getwininfo([{winid}])					*getwininfo()*
		返回視窗資訊，返回值是字典的列表。

		如果給出 {winid}，返回給定 ID 的視窗的資訊。如果視窗不存在，返
		回空列表。

		如果沒有給出 {winid}，返回所有標籤頁的所有視窗的資訊。

		每個列表項是包含以下專案的字典:
			bufnr		視窗中的緩衝區號
			height		視窗高度
			loclist		1 如果顯示了位置列表
					{僅當加入 |+quickfix| 特性才有效}
			quickfix	1 如果是 quickfix 或位置列表視窗
					{僅當加入 |+quickfix| 特性才有效}
			tabnr		標籤頁號
			variables	包含視窗區域性變數的字典的引用
			width		視窗寬度
			winid		|window-ID|
			winnr		視窗號

		要得到所有視窗區域性變數，可用: >
			gettabwinvar({tabnr}, {winnr}, '&')

getwinvar({winnr}, {varname} [, {def}])				*getwinvar()*
		類似於 |gettabwinvar()|，只用當前標籤頁。
		例如: >
			:let list_is_on = getwinvar(2, '&list')
			:echo "myvar = " . getwinvar(1, 'myvar')
<
glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])		*glob()*
		擴充套件 {expr} 裡的檔案萬用字元。|wildcards| 說明其中特殊字元的使用
		方法。

		除非給出可選的 {nosuf} 引數且為 |TRUE|，應用 'suffixes' 和
		'wildignore' 選項: 跳過匹配任何 'wildignore' 模式的名字，而
		'suffixes' 影響匹配結果的排序。
		'wildignorecase' 則總是適用。

		如果給出 {list} 且為 |TRUE|，返回列表，包含所有匹配的檔案。使
		用列表的優點是可以正確得到包含換行符的檔名。
		否則返回的是字串，且如果返回多個匹配，以 <NL> 字元分隔。

		如果擴充套件失敗，返回空字串或空列表。

		擴充套件結果不包含不存在檔案的名字。僅當符號連結指向已存在檔案時才
		會包含在擴充套件結果內。但若給出了 {alllinks} 引數且為 |TRUE|，則
		包含所有符號連結。

		多數系統上，可以用反引號從外部命令得到檔名。例如: >
			:let tagfiles = glob("`find . -name tags -print`")
			:let &tags = substitute(tagfiles, "\n", ",", "g")
<		反引號包圍的程式的輸出結果必須每個專案一行。專案內部可以使用空
		格。

		特殊 Vim 變數的擴充套件見 |expand()|。|system()| 說明如何得到外部
		命令的原始輸出。

glob2regpat({expr})					 *glob2regpat()*
		轉換 glob() 所用有檔案模式為搜尋模式。結果可用來匹配包含檔名
		的字串。例如 >
			if filename =~ glob2regpat('Make*.mak')
<		等價於: >
			if filename =~ '^Make.*\.mak$'
<		如果 {expr} 為空串，返回值是 "^$"，匹配空串。
		備註 結果與所用系統有關。MS-Windows 上反斜槓通常用作路徑分隔
		符。

								*globpath()*
globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
		在 {path} 的所有目錄下執行 glob() 並連線所有的返回結果。例
		如: >
			:echo globpath(&rtp, "syntax/c.vim")
<
		{path} 是逗號分隔的目錄名的列表。每個目錄名都附加在 {expr} 之
		前，然後如同 |glob()| 那樣被擴充套件。必要的話，插入路徑分隔符。
		要在目錄名字裡加上逗號，可以使用反斜槓轉義。注意 在 MS-Windows
		上目錄的最後可能有一個反斜槓。如果你要在後面加上逗號進行分隔，
		先把反斜槓去掉。
		如果某個目錄下的擴充套件失敗，不會有錯誤資訊。

		除非給出可選的 {nosuf} 引數且為 |TRUE|，應用 'suffixes' 和
		'wildignore' 選項: 跳過匹配任何 'wildignore' 模式的名字，而
		'suffixes' 影響匹配結果的排序。

		如果給出 {list} 且為 |TRUE|，返回匹配檔案的列表。列表的好處是
		會正確處理包含換行符的檔名，否則返回字串，有多個匹配時，以
		<NL> 字元分隔。例如: >
			:echo globpath(&rtp, "syntax/c.vim", 0, 1)
<
		{alllinks} 的用法和 |glob()| 相同。

		可以用 "**" 專案來搜尋目錄樹。例如，尋找在 'runtimepath' 和它
		之下所有目錄裡的 "README.txt" 檔案: >
			:echo globpath(&rtp, "**/README.txt")
<		不支援向上搜尋和 "**" 的深度限制，所以 'path' 的使用不一定總能
		正確工作。

							*has()*
has({feature})	返回數值，如果支援特性 {feature} 則為 1，不然為零。
		{feature} 引數是字串。見下面的 |feature-list|。
		另見 |exists()|。


has_key({dict}, {key})					*has_key()*
		返回數值，如果 |Dictionary| {dict} 有鍵為 {key} 的專案則為 1，
		不然為零。

haslocaldir([{winnr} [, {tabnr}]])			*haslocaldir()*
		返回數值，如果視窗用 |:lcd| 設定過本地路徑則為 1，不然為 0。

		無引數時使用當前視窗。
		有 {winr} 則使用當前標籤頁的該視窗。
		有 {winr} 和 {tabnr} 則使用指定標籤頁的該視窗。
		{winr} 可以是視窗號或 |window-ID|。
		如果引數非法，返回 0。

hasmapto({what} [, {mode} [, {abbr}]])			*hasmapto()*
		返回數值，如果存在某對映，其右邊的表示式 (被對映到的部分) 的某
		處包含 {what}，並且該對映在 {mode} 指定的模式下存在，返回 1。
		如果提供 {abbr} 且為 |TRUE|，使用縮寫而不是對映。不要忘記指定
		插入和/或命令列模式。
		同時檢查全域性對映和區域性於當前緩衝區的對映以尋找匹配。
		如果沒有匹配的對映，返回 0。
		{mode} 識別下列字元:
			n	普通模式
			v	可視模式
			o	操作符等待模式
			i	插入模式
			l	Language-Argument ("r"、 "f"、"t" 等等) 模式
			c	命令列模式
		如果沒有提供 {mode}，使用 "nvo"。

		該函式可用於檢查是否存在對映到 Vim 指令碼的某個函式的對映。例
		如: >
			:if !hasmapto('\ABCdoit')
			:   map <Leader>d \ABCdoit
			:endif
<		這樣，到 "\ABCdoit" 的對映只有在到 "\ABCdoit" 的對映還不存在的
		時候才會進行。

histadd({history}, {item})				*histadd()*
		把字串 {item} 加到歷史 {history} 裡。後者可以是:
							*hist-names*
			"cmd"	 或 ":"	  命令列歷史
			"search" 或 "/"   搜尋模式歷史
			"expr"   或 "="   輸入表示式歷史
			"input"  或 "@"	  輸入行歷史
			"debug"  or ">"   除錯命令歷史
			空		  當前或最後使用的歷史
		{history} 字串無須是完整名字，一個字元就夠了。
		如果 {item} 已經在歷史裡存在，它會被調整位置，從而成為最新的一
		項。
		返回結果為數值: 如果操作成功則為 1，不然返回 0。

		例如: >
			:call histadd("input", strftime("%Y %b %d"))
			:let date=input("Enter date: ")
<		該函式在沙盤裡不可用 |sandbox|。

histdel({history} [, {item}])				*histdel()*
		清除 {history}，換而言之，刪除它所有的專案。|hist-names| 解釋
		{history} 的所有可能值。

		如果 {item} 計算結果為字串，它被看作正規表示式。從歷史裡刪除
		所有匹配該模式的專案 (如果有的話)。
		必須匹配大小寫，除非使用 "\c" |/\c|。
		如果 {item} 的計算結果為數值，它被解釋為索引值，見
		|:history-indexing|。如果該索引存在，刪除相應的專案。

		返回結果為數值: 如果操作成功則為 1，不然返回 0。

		例如:
		清除表示式暫存器歷史: >
			:call histdel("expr")
<
		刪除所有 "*" 開始的搜尋歷史: >
			:call histdel("/", '^\*')
<
		下面三者是等價的: >
			:call histdel("search", histnr("search"))
			:call histdel("search", -1)
			:call histdel("search", '^'.histget("search", -1).'$')
<
		要刪除最後的搜尋模式，並在 "n" 命令和 'hlsearch' 裡使用倒數第
		二個模式: >
			:call histdel("search", -1)
			:let @/ = histget("search", -1)

histget({history} [, {index}])				*histget()*
		返回字串，即 {history} 歷史的第 {index} 項。|hist-names| 解
		釋 {history} 的所有可能值，而 |:history-indexing| 解釋
		{index}。如果沒有這個專案，返回空字串。如果忽略 {index}，返
		回曆史裡最近使用的專案。

		例如:
		重做歷史裡的倒數第二個搜尋 >
			:execute '/' . histget("search", -2)

<		定義 Ex 命令 ":H {num}"，以重新執行 |:history| 輸出的第 {num}
		項。 >
			:command -nargs=1 H execute histget("cmd", 0+<args>)
<
histnr({history})					*histnr()*
		返回當前專案在 {history} 裡的編號。|hist-names| 解釋 {history}
		的所有可能值。
		如果有錯，返回 -1。

		例如: >
			:let inp_index = histnr("expr")
<
hlexists({name})					*hlexists()*
		返回數值。只要名為 {name} 的高亮組用某種方法定義過，返回非零。
		不一定要為該組定義過高亮屬性。一些語法專案可能已經使用該組。
							*highlight_exists()*
		已廢棄的名字: highlight_exists()。

							*hlID()*
hlID({name})	返回數值，即名為 {name} 的高亮組的 ID。如果該高亮組不存在，返
		回零。
		可用於提取高亮組的資訊。比如，要得到 "Comment" 組的背景顏色: >
	:echo synIDattr(synIDtrans(hlID("Comment")), "bg")
<							*highlightID()*
		已廢棄的名字: highlightID()。

hostname()						*hostname()*
		返回字串，即 Vim 執行的機器名字。超過 256 字串長度的機器名
		被截短。

iconv({expr}, {from}, {to})				*iconv()*
		返回字串，即文字 {expr} 從 {from} 編碼轉到 {to} 編碼以後的文
		本。
		如果轉換完全失敗，返回空字串。如果部分字元無法轉換，以 "?"
		代替之。
		編碼名字可以是任何 iconv() 庫函式接受的名字，見
		":!man 3 iconv"。
		大多數轉換需要 Vim 編譯時加入 |+iconv| 特性。不然，只支援
		UTF-8 和 latin1 的相互轉換。
		這可以用來顯示包含特殊字元的訊息。不管 'encoding' 設為何值，總
		可以用 UTF-8 書寫訊息，然後使用: >
			echo iconv(utf8_str, "utf-8", &enc)
<		注意 Vim 使用 UTF-8 進行所有的 Unicode 編碼，從/到 UCS-2 的轉
		換都自動轉為 UTF-8。你不能在字串裡使用 UCS-2，因為那裡有 NUL
		位元組。
		{僅當編譯時加入 |+multi_byte| 特性才有效}

							*indent()*
indent({lnum})	返回數值，第 {lnum} 行的縮排距離。縮排的計算以空格計，因而它和
		'tabstop' 的值是有關係的。{lnum} 的使用方式和 |getline()| 相
		同。
		如果 {lnum} 非法，返回 -1。


index({list}, {expr} [, {start} [, {ic}]])			*index()*
		返回 |List| {list} 裡值等於 {expr} 的最小專案索引。這裡不進行
		自動轉換，字串 "4" 不同於數值 4，數值 4 也不等同於浮點數
		4.0。'ignorecase' 的值此處也不適用，大小寫不忽略。
		如果給出 {start}，從索引為 {start} 的專案開始尋找 (可以為負，
		指定相對於尾部的專案)。
		如果給出 {ic} 且為 |TRUE|，忽略大小寫。否則，必須匹配大小寫。
		如果在 {list} 裡找不到 {expr}，返回 -1。
		示例: >
			:let idx = index(words, "the")
			:if index(numbers, 123) >= 0


input({prompt} [, {text} [, {completion}]])		*input()*
		返回字串，即使用者在命令列上的輸入內容，可以為任何值。引數
		{prompt} 或者是一個提示字串，或者是一個空白字串 (沒有提
		示)。'\n' 可以在提示裡使用，以開始新行。
		該提示使用 |:echohl| 設定的高亮。
		輸入方法和命令列相似，也使用相同的編輯命令和對映。但 input()
		輸入的行使用另外的歷史。
		示例: >
			:if input("咖啡還是啤酒？") == "啤酒"
			:  echo "乾杯！"
			:endif
<
		如果給出可選的 {text} 引數，它被用作預設的回答，就像是使用者輸入
		的那樣。例如: >
			:let color = input("Color? ", "white")

<		可選的 {completion} 引數指定輸入支援的補全型別。如果不給出，不
		使用補全。支援的補全型別和使用者定義命令用 "-complete=" 引數能給
		出的型別相同。詳情見 |:command-completion|。例如: >
			let fname = input("File: ", "", "file")
<
		注意: 在只能運行於 GUI 模式的版本里 (比如 Win32 GUI)，此函式不
		能在啟動檔案裡使用。
		注意: input() 在對映裡呼叫時，它會消耗該對映餘下的字元，因為映
		射的處理就像那些字元被鍵盤輸入一樣。在 input() 前使用
		|inputsave()| 然後在 input() 輸入之後 |inputrestore()| 可以避
		免這一點。另一個方法是避免在對映的後面提供任何字元，比如，使用
		|:execute| 或 |:normal|。

		使用對映的例子: >
			:nmap \x :call GetFoo()<CR>:exe "/" . Foo<CR>
			:function GetFoo()
			:  call inputsave()
			:  let g:Foo = input("enter search pattern: ")
			:  call inputrestore()
			:endfunction

inputdialog({prompt} [, {text} [, {cancelreturn}]])		*inputdialog()*
		類似於 |input()|，但如果執行 GUI 且支援文字對話方塊，彈出一個對
		話框視窗來輸入文字。
		例如: >
		   :let n = inputdialog("value for shiftwidth", shiftwidth())
		   :if n != ""
		   :  let &sw = n
		   :endif
<		如果對話方塊被取消，返回 {cancelreturn}。如果忽略，返回空字元
		串。
		輸入 <Enter> 和按 OK 按鈕相同。按 <Esc> 和按 Cancel 按鈕相同。
		備註: 不支援命令列補全。

inputlist({textlist})					*inputlist()*
		{textlist} 必須是字串的 |List|。顯示此 |List|，每個字串一
		行。使用者得到提示要輸入一個數值，返回此值。
		使用者也可以用滑鼠點選專案來進行選擇。第一個字串返回 0。在第一
		個專案之上點選返回負數。在提示行上點選返回 {textlist} 的長度加
		一。
		確保 {textlist} 不超過 'lines' 個專案，否則無法使用。建議把項
		目編號放在每個字串的開始處，並在第一項上加上提示。例如: >
			let color = inputlist(['Select color:', '1. red',
				\ '2. green', '3. blue'])

inputrestore()						*inputrestore()*
		恢復前一個 |inputsave()| 儲存的預輸入。應該和 |inputsave()| 調
		用的次數相同，不過呼叫更多次也無妨。
		如果沒有可以恢復的，返回 1，不然返回 0。

inputsave()						*inputsave()*
		儲存預輸入 (也包括對映的) 並清除之，使得下一個提示能從使用者得到
		輸入。在提示之後應該跟上配套的 inputrestore()。可以多次使用，
		此時應該有同樣多次的 inputrestore() 呼叫。
		如果記憶體不足，返回 1，不然返回 0。

inputsecret({prompt} [, {text}])			*inputsecret()*
		該函式和 |input()| 函式類似，但有兩個例外:
		a) 使用者的應答顯示為一串星號 ("*")，從而輸入可以保密，還有
		b) 使用者的應答不會記錄在輸入 |history| 棧中。
		返回字串，即使用者在命令列上根據提示輸入的應答。
		備註: 不支援命令列補全。

insert({list}, {item} [, {idx}])			*insert()*
		在 |List| {list} 的開始處插入 {item}。
		如果指定 {idx}，{item} 的插入位置在索引 {idx} 之前。如果
		{idx} 為零，插入在第一個專案之前，和省略 {idx} 效果相同。也可
		用負的 {idx}，見 |list-index|。-1 插入在最後一個專案之前。
		返回新產生的 |List|。例如: >
			:let mylist = insert([2, 3, 5], 1)
			:call insert(mylist, 4, -1)
			:call insert(mylist, 6, len(mylist))
<		用 |add()| 可以更簡單的完成最後一個例子。
		注意 如 {item} 是 |List|，它被作為單個專案來插入。 |extend()|
		用來連線多個 |List|。

invert({expr})						*invert()*
		按位取反。引數須轉換為數值。列表、字典或浮點數引數會報錯。
		示例: >
			:let bits = invert(bits)


isdirectory({directory})				*isdirectory()*
		返回數值，如果名為 {directory} 的目錄存在，返回 |TRUE|。如果
		{directory} 不存在或者不是目錄，返回 |FALSE|。{directory} 可以
		是任何表示式，最終用作字串。

islocked({expr})					*islocked()* *E786*
		返回數值，如果 {expr} 是某個加鎖的變數名，返回 |TRUE|。
		{expr} 必須是變數名、|List| 專案，或 |Dictionary| 專案，不是變
		量本身！例如: >
			:let alist = [0, ['a', 'b'], 2, 3]
			:lockvar 1 alist
			:echo islocked('alist')		" 1
			:echo islocked('alist[1]')	" 0

<		如果 {expr} 是不存在的變數，得到錯誤資訊。用 |exists()| 可以檢
		查它是否存在。

isnan({expr})						*isnan()*
		如果 {expr} 是值為 NaN 的浮點數，返回 |TRUE|。 >
			echo isnan(0.0 / 0.0)
<			1 ~

		{僅當編譯時加入 |+float| 特性才有效}

items({dict})						*items()*
		返回 |List|，{dict} 的所有鍵-值組對。每個 |List| 專案是兩個項
		目的列表: {dict} 專案的鍵和此專案的值。|List| 專案的順序不定。

job_getchannel({job})					 *job_getchannel()*
		獲取 {job} 使用的通道控制代碼。
		要確認作業沒有通道: >
			if string(job_getchannel()) == 'channel fail'
<
		{僅當編譯時加入 |+job| 特性才有效}

job_info({job})						*job_info()*
		返回關於 {job} 資訊的字典:
		   "status"	|job_status()| 返回值
		   "channel"	|job_getchannel()| 返回值
		   "exitval"	"status" 為 "dead" 時才有效
		   "exit_cb"	退出時呼叫的函式
		   "stoponexit"	|job-stoponexit|

job_setoptions({job}, {options})			*job_setoptions()*
		改變 {job} 的選項。目前支援:
		   "stoponexit"	|job-stoponexit|
		   "exit_cb"	|job-exit_cb|

job_start({command} [, {options}])			*job_start()*
		啟動作業，返回 Job 物件。不同於 |system()| 和 |:!cmd|，不等待
		作業完成。

		{command} 可以是字串。對 MS-Windows 最佳。Unix 上先切為空白
		分隔的部分，然後傳給 execvp()。而雙引號內的引數可能包含空格。

		{command} 可以是列表，首項是可執行檔案，後面諸項為引數。所有項
		目轉換為字串。這對 Unix 最佳。

		MS-Windows 上，job_start() 啟動隱藏的 GUI 應用。要使之可見，用
		|:!start| 代替。

		命令直接執行，不通過外殼，不使用 'shell' 選項。要使用外殼: >
	let job = job_start(["/bin/sh", "-c", "echo hello"])
<		或: >
	let job = job_start('/bin/sh -c "echo hello"')
<		注意 這樣會啟動兩個過程，外殼及其啟動的命令。如果不希望如此，
		可用 "exec" 外殼命令。

		Unix 上僅當命令本身不包含斜槓時，才用 $PATH 來搜尋可執行檔案。

		作業使用和 Vim 相同的終端。如果從 stdin 讀入，該作業和 Vim 會
		競爭輸入，這樣不行。要避免此問題，重定向 stdin 和 stdout: >
	let job = job_start(['sh', '-c', "myserver </dev/null >/dev/null"])
<
		返回的 Job 物件可用以通過 |job_status()| 獲取狀態，和通過
		|job_stop()| 停止作業。

		{options} 必須是字典。可包含許多可選專案，見 |job-options|。

		{僅當編譯時加入 |+job| 特性才有效}

job_status({job})					*job_status()* *E916*
		返回字串，返回 {job} 的狀態:
			"run"	作業執行中
			"fail"	作業無法啟動
			"dead"	作業啟動後結束或被終止

		Unix 上不存在的命令會報告 "dead" 而不是 "fail"，因為在檢測到問
		題之前，fork 操作已經發生。

		如果用 "exit_cb" 選項設定了退出回撥，而作業已檢測到處於 "dead"
		狀態，呼叫該回調。

		更多詳情可見 |job_info()|。

		{僅當編譯時加入 |+job| 特性才有效}

job_stop({job} [, {how}])					*job_stop()*
		停止 {job}。也用於給作業民傳送訊號。

		如果 {how} 省略或是 "term"，作業被終止。Unix 上傳送 SIGTERM。
		MS-Windows 上強制終止該作業 (沒有所謂 "溫柔的" 方式)。
		應用在整個程序組上，因而子程序也受影響。

		Unix 上的效果:
			"term"	 SIGTERM (預設)
			"hup"	 SIGHUP
			"quit"	 SIGQUIT
			"int"	 SIGINT
			"kill"	 SIGKILL (最強的停止方式)
			數值	 該數值對應的訊號

		MS-Windows 上的效果:
			"term"	 強制終止程序 (預設)
			"hup"	 CTRL_BREAK
			"quit"	 CTRL_BREAK
			"int"	 CTRL_C
			"kill"	 強制終止程序
			Others	 CTRL_BREAK

		Unix 上傳送訊號到程序組。這意味著如果作業是 "sh -c command"，
		外殼和命令同時受影響。

		返回數值: 如果操作可執行返回 1，如果系統不支援 "how"，返回 0。
		注意 即使已執行了操作，作業停止與否需用 |job_status()| 檢查。

		如果作業的狀態是 "dead"，不傳送訊號。這是為了避免給錯誤的作業
		傳送訊號 (尤其在 Unix 上，程序號是迴圈利用的)。

		使用 "kill" 後，Vim 假定作業會終止，因而將通道關閉。

		{僅當編譯時加入 |+job| 特性才有效}

join({list} [, {sep}])					*join()*
		連線所有 {list} 專案成為字串。
		如果指定 {sep}，該分隔符出現在專案之間。如果省略 {sep}，用單個
		空格。
		注意 尾部不加 {sep}。如果你堅持要加入: >
			let lines = join(mylist, "\n") . "\n"
<		字串專案照原樣使用。用類似 |string()| 的方式把 |List| 和
		|Dictionary| 轉化為字串。
		逆函式是 |split()|。

js_decode({string})					*js_decode()*
		和 |json_decode()| 類似，但有以下區別:
		- 物件鍵名不需用引號括起。
		- 字串可以用單引號括起。
		- 接受陣列的空專案 (兩個逗句之間)，返回 v:none 專案。

js_encode({expr})					*js_encode()*
		和 |json_encode()| 類似，但有以下區別:
		- 物件鍵名不用引號括起。
		- 數組裡的 v:none 專案生成逗號之間的空專案。
		例如，Vim 物件:
			[1,v:none,{"one":1},v:none] ~
		會被編碼為:
			[1,,{one:1},,] ~
		而 json_encode() 會生成:
			[1,null,{"one":1},null] ~
		對 Javscript，這種編碼也是合法的。但比 JSON 更高效，尤其是使用
		有可選專案的陣列時。


json_decode({string})					*json_decode()*
		解析 JSON 格式的字串，返回等價的 Vim 值。見 |json_encode()|
		瞭解 JSON 和 Vim 值的關係。
		解碼是容錯的:
		- 忽略陣列和物件拖尾的逗號，例如 "[1, 2, ]" 等同 "[1, 2]"。
		- 識別更多浮點數，例如 "1." 相當於 "1.0"，而 "001.2" 相當於
		  "1.2"。接受特殊浮點值 "Infinity" 和 "NaN" (大小寫無關)。
		- 忽略整數值前導零，例如 "012" 相當於 "12"，而 "-012" 相當於
		  "-12"。
		- 按本義名 null、true 或 false 的大小寫無關，例如 "NULL" 相當
		  於 "null"，"True" 相當於 "true"。
		- 接受字串中不轉義的控制字元 U+0000 到 U+001F，例如 "	"
		  (字串中的製表符) 相當於 "\t"。
		- 忽略非法的兩字元轉義序列中的反斜槓，例如 "\a" 解碼為 "a"。
		- JSON 字串中正確的代理對正常應是 12 字元的序列，如
		  "\uD834\uDD1E"，但 json_decode() 安靜地接受截斷的代理對，例
		  如 "\uD834" 或 "\uD834\u"。
								*E938*
		物件裡的重複鍵值，雖然在 rfc7159 中合法，便不被 json_decode()
		接受，因為轉換結果必須是合法的 Vim 型別，例如，這樣不行:
		{"a":"b", "a":"c"}


json_encode({expr})					*json_encode()*
		對 {expr} 進行 JSON 編碼，返回字串。
		編碼格式在此指定:
		https://tools.ietf.org/html/rfc7159.html
		Vim 值的轉換如下:
		   Number		十進位制數
		   Float		浮點數
		   Float nan		"NaN"
		   Float inf		"Infinity"
		   String		雙引號括起 (可為 null)
		   Funcref		不接受，報錯
		   List			作為陣列 (可為 null)；若遞迴使用: []
		   Dict			作為物件 (可為 null)；若遞迴使用: {}
		   v:false		"false"
		   v:true		"true"
		   v:none		"null"
		   v:null		"null"
		備註 NaN 和 Infinity 作為值傳遞。這在 JSON 標準裡沒有提到，但
		若干實現支援。如果不支援，可能會報錯。

keys({dict})						*keys()*
		返回 |List|，{dict} 的所有鍵。|List| 專案的順序不定。

							*len()* *E701*
len({expr})	返回數值，引數的長度。
		如果 {expr} 為字串或數值，返回它使用的位元組數，和 |strlen()|
		相同。
		如果 {expr} 為 |List|，返回 |List| 的專案數量。
		如果 {expr} 為 |Dictionary|，返回 |Dictionary| 的專案數量。
		否則給出錯誤。

						*libcall()* *E364* *E368*
libcall({libname}, {funcname}, {argument})
		在執行庫 {libname} 裡呼叫函式 {funcname} 並給出單個引數
		{argument}。
		這可以用於呼叫庫裡的函式，尤其是 Vim 裡用到的那些。因為只能使
		用單個引數，所以可以呼叫的標準庫函式相當有限。
		結果是函式返回的字串。如果函式返回 NULL，在 Vim 裡會以空字元
		串 "" 出現。
		如果函式返回數值，請使用 |libcallnr()|！
		如果 {argument} 是數值，它以 int 型別傳給函式；如果 {argument}
		是字串，它以 null 結尾的字串型別傳入。
		在 |restricted-mode| 裡，該函式不能執行。

		libcall() 允許你寫自己的 Vim '外掛' 擴充套件，而無須重新編譯程式。
		它並_不_是用來呼叫系統函式的一個方法！如果你試圖這麼做，Vim 很
		有可能會崩潰。

		Win32 上，你寫的函式必須在 DLL 裡提供，而且必須使用普通的 C 調
		用慣例 (_不是_ Windows 系統 DLL 使用的 Pascal 慣例)。函式必須
		只能接受單個引數，或者是字元指標，或者是長整數，而且必須返回字
		符指標或者 NULL。返回的字元指標必須指向在函式返回之後仍然指向
		合法的記憶體 (比如 DLL 的靜態區域)。如果指向分配的區域，那麼記憶體
		會發生洩漏。在函式裡使用靜態緩衝區應該可以，在 DLL 解除安裝時會被
		釋放。

		警 告: 如果函式返回不合法的指標，Vim 會崩潰！如果函式返回數值
		也會發生同樣的問題，因為 Vim 把它當作指標看待。
		Win32 系統上，{libname} 必須是不帶 ".DLL" 字尾的 DLL 檔名。
		只有 DLL 不在常見的位置的時候，才需要指定完整的路徑名。
		Unix 上: 如果編譯你自己的外掛，記住目的碼必須生成位置無關代
		碼 ('PIC')。
		{僅當使用 Win32 和一些 Unix 版本且帶有 |+libcall| 特性時才有
		效}
		例如: >
			:echo libcall("libc.so", "getenv", "HOME")
<
							*libcallnr()*
libcallnr({libname}, {funcname}, {argument})
		和 |libcall()| 類似，但函式返回 int，而不是字串。
		{僅當使用 Win32 和一些 Unix 版本且帶有 |+libcall| 特性時才有
		效}
		例如: >
			:echo libcallnr("/usr/lib/libc.so", "getpid", "")
			:call libcallnr("libc.so", "printf", "Hello World!\n")
			:call libcallnr("libc.so", "sleep", 10)
<
							*line()*
line({expr})	返回數值，即 {expr} 給定的檔案位置的行號。可接受的位置是:
		    .	    游標位置
		    $	    緩衝區的最後一行
		    'x	    位置標記 x 的位置 (如果該位置標記沒有設定，返回 0)
		    w0	    當前視窗可見部分的首行 (如果顯示不重新整理，如安靜 Ex
		    	    模式下，則為一)
		    w$	    當前視窗可見部分的末行 (如果無行可見，返回比 w0 小
			    一的值)
		    v       可視模式下: 可視區域的開始行 (游標是結束位置)。
			    如果不在可視模式下，返回當前游標位置。和 |'<| 不同
			    的是，會被立即更新。
		注意 可以使用其它檔案的位置標記。此時行號應用於那個緩衝區。
		要得到列號用 |col()|。兩者都要可用 |getpos()|。
		例如: >
			line(".")		游標所在的行號
			line("'t")		位置標記 t 的行號
			line("'" . marker)	名為 marker 的位置標記的行號
<							*last-position-jump*
		如果設定了 '" 位置標記的話，下面的自動命令在開啟檔案後跳轉到最
		後已知的檔案位置: >
     :au BufReadPost *
	 \ if line("'\"") > 1 && line("'\"") <= line("$") && &ft !~# 'commit'
	 \ |   exe "normal! g`\""
	 \ | endif
<
line2byte({lnum})					*line2byte()*
		返回當前緩衝區第 {lnum} 行從緩衝區開始計算的位元組數。這裡包括換
		行符，但它具體的值取決於當前緩衝區的 'fileformat' 選項，第一行
		返回 1。這和 'encoding' 有關但忽略 'fileencoding'。
		這也可以用來得到最後一行之後的 "那行" 的位元組計數: >
			line2byte(line("$") + 1)
<		這就等於緩衝區大小加 1。如果 'fileencoding' 為空則等於檔案大小
		加 1。
		如果 {lnum} 非法或者編譯時關閉了 |+byte_offset| 特性，返回
		-1。另見 |byte2line()|、|go| 和 |:goto|。

lispindent({lnum})					*lispindent()*
		得到第 {lnum} 行根據 lisp 縮排規則應有的縮排距離，見 'lisp'。
		縮排的計算以空格計，因而和 'tabstop' 的值是有關係的。
		{lnum} 的使用方式和 |getline()| 相同。
		如果 {lnum} 非法或者 Vim 編譯時不帶 |+lispindent| 特性，返回
		-1。

localtime()						*localtime()*
		返回當前時間，以 1970 年 1 月 1 日開始的秒數計算。另見
		|strftime()| 和 |getftime()|。

log({expr})						*log()*
		返回浮點數，即浮點數 {expr} 的自然對數 (即以 e 為底)。
		{expr} 計算結果必須為 (0, inf] 區間內的浮點數或數值。
		示例: >
			:echo log(10)
<			2.302585 >
			:echo log(exp(5))
<			5.0
		{僅當編譯時加入 |+float| 特性才有效}

log10({expr})						*log10()*
		返回浮點數，即浮點數 {expr} 以 10 為底的對數。
		{expr} 計算結果必須為浮點數或數值。
		示例: >
			:echo log10(1000)
<			3.0 >
			:echo log10(0.01)
<			-2.0
		{僅當編譯時加入 |+float| 特性才有效}

luaeval({expr}[, {expr}])					*luaeval()*
		執行 Lua 表示式 {expr} 並把結果轉換為 Vim 資料結構。第二個
		{expr} 指定在第一個 {expr} 裡可以使用的額外引數，可以 _A 形式
		訪問。
		字串原樣返回。
		布林值物件轉換為數值。
		vim 編譯時帶 |+float| 特性時，數值轉換為 |Float|，否則作為數值
		型返回。
		vim.eval() 得到的字典和列表以原樣返回。
		|lua-luaeval| 有更多詳情。
		{僅當編譯時加入 |+lua| 特性才有效}

map({expr1}, {expr2})					*map()*
		{expr1} 必須是 |List| 或 |Dictionary|。
		{expr1} 裡的每個專案被 {expr2} 的計算結果替代。{expr2} 必須是
		|string| 或 |Funcref|。

		如果 {expr2} 是 |string|，{expr2} 內的 |v:val| 包含當前專案的
		值。|Dictionary| 中 |v:key| 包含當前專案的鍵。|List| 中
		|v:key| 包含當前專案的索引。
		例如: >
			:call map(mylist, '"> " . v:val . " <"')
<		"mylist" 裡的每個專案之前放上 "> "，而之後放上 " <"。

		注意 {string} 是表示式的計算結果，而它本身又用作表示式。通常，
		最好用 |literal-string| 來避免反斜槓加倍。當然，你仍然需要加倍
		' 引號。

		如果 {expr2} 是 |Funcref|，它必須接受兩個引數:
			1. 當前專案的鍵或索引。
			2. 當前專案的值。
		函式必須返回專案的新值。例如要改變每個值為 "鍵-值": >
			func KeyValue(key, val)
			  return a:key . '-' . a:val
			endfunc
			call map(myDict, function('KeyValue'))
<		使用 |lambda| 會更短: >
			call map(myDict, {key, val -> key . '-' . val})
<		如果不用 "val"，可以不寫: >
			call map(myDict, {key -> 'item: ' . key})
<
		本操作是原位操作 (直接在輸入上修改)。要想不更動 |List| 或
		|Dictionary|，先建立備份: >
			:let tlist = map(copy(mylist), ' v:val . "\t"')

<		返回 {expr1}，經過過濾的 |List| 或 |Dictionary|。如果執行
		{expr2} 有錯，不再處理 {expr1} 的其餘專案。{expr2} 是函式引用
		時，忽略函式裡的錯誤，除非該函式用 "abort" 標誌位定義。


maparg({name}[, {mode} [, {abbr} [, {dict}]]])			*maparg()*
		當 {dict} 省略或為零，返回模式 {mode} 名為 {name} 的對映的右手
		邊 (rhs)。返回字串中的特殊字元用和 ":map" 命令輸出的同樣方式
		進行翻譯。

		如果沒有名為 {name} 的對映，返回空字串。

		{name} 可包含特殊鍵名，一如 ":map" 命令。

		{mode} 可以使用下列字串之一:
			"n"	普通模式
			"v"	可視模式 (包括選擇)
			"o"	操作符等待模式
			"i"	插入模式
			"c"	命令列模式
			"s"	選擇模式
			"x"	可視模式
 			"l"	語言對映 |language-mapping|
			""	普通、可視和操作符等待模式。
		如果沒有提供 {mode}，使用 "" 指定的模式。

		如果提供 {abbr} 且為 |TRUE|，使用縮寫而不是對映。

		如果提供 {dict} 且為 |TRUE|，返回字典，包含關於對映的所有信
		息。有如下專案:
		  "lhs"	     對映的 {lhs}。
		  "rhs"	     對映的 {rhs}，保持輸入原樣。
		  "silent"   1 若是 |:map-silent| 對映，否則為 0。
		  "noremap"  1 若是對映的 {rhs} 不能再對映。
		  "expr"     1 若是表示式對映 (|:map-<expr>|)。
		  "buffer"   1 若是緩衝區本地對映 (|:map-local|)。
		  "mode"     對映定義使用的模式。除了以上提到的模式以外，還會
			     使用:
			     " "     普通、可視和操作符等待模式
			     "!"     插入和命令列模式
				     (|mapmode-ic|)
		  "sid"	     指令碼區域性 ID，用於 <sid> 對映 (|<SID>|)。
		  "nowait"   不等待其它更長的對映。(|:map-<nowait>|)。

		先檢查區域性於當前緩衝區的對映，然後再檢查全域性對映。
		此函式可以用來給鍵對映。如果已經對映過，還可以使用原來對映的內
		容。大意: >
			exe 'nnoremap <Tab> ==' . maparg('<Tab>', 'n')


mapcheck({name}[, {mode} [, {abbr}]])			*mapcheck()*
		檢查是否有模式 {mode} 下匹配 {name} 的對映。|maparg()| 說明
		{mode} 和 {name} 裡的特殊鍵名。
		如果提供 {abbr} 且為 |TRUE|，使用縮寫而不是對映。
		匹配在對映名以 {name} 開始或者對映名等於 {name} 的開始部分時候
		發生。

			匹配對映	"a"     "ab"    "abc" ~
		   mapcheck("a")	是	是	 是
		   mapcheck("abc")	是	是	 是
		   mapcheck("ax")	是	否	 否
		   mapcheck("b")	否	否	 否

		和 maparg() 的差別是，mapcheck() 查詢匹配 {name} 的對映，而
		maparg() 只查詢名字完全符合 {name} 的對映。
		如果沒有 {name} 開始的對映，返回空字串。如果有一個，返回該映
		射的右邊。如果有多個，返回其中某一個的右邊。
		    先檢查區域性於當前緩衝區的對映，然後再檢查全域性對映。
		該函式用於檢查是否可以無二義性地新增對映。例如: >
	:if mapcheck("_vv") == ""
	:   map _vv :set guifont=7x13<CR>
	:endif
<		就避免了在已有 "_v" 或者 "_vvv" 對映的時候新增 "_vv" 對映。

match({expr}, {pat}[, {start}[, {count}]])			*match()*
		如果 {expr} 是 |List|，返回匹配 {pat} 的第一個專案的索引。每個
		專案用作字串，|List| 和 |Dictionary| 使用回顯的形式。
		否則，{expr} 用作字串。返回數值，給出 {expr} 裡 {pat} 匹配的
		(位元組計算的偏移量) 位置。
		在第一個字元或 |List| 專案上的匹配返回零。若無匹配，返回 -1。
		要得到子匹配，見 |matchlist()|。
		例如: >
			:echo match("testing", "ing")	" 返回 4
			:echo match([1, 'x'], '\a')	" 返回 1
<		|string-match| 說明如何使用 {pat}。
								*strpbrk()*
		Vim 沒有 strpbrk() 函式。但你可以這麼做: >
			:let sepidx = match(line, '[.,;: \t]')
<								*strcasestr()*
		Vim 沒有 strcasestr() 函式。但你可以在模式里加入 "\c" 以忽略大
		小寫: >
			:let idx = match(haystack, '\cneedle')
<
		如果給出 {start}，搜尋從字串的位元組位置 {start} 或 |List| 索
		引為 {start} 的專案開始。
		不過，結果仍然從第一個字元/專案開始算起。比如: >
			:echo match("testing", "ing", 2)
<		返回結果是 "4"。 >
			:echo match("testing", "ing", 4)
<		返回結果還是 "4"。 >
			:echo match("testing", "t", 2)
<		返回 "3"。
		對字串而言，如果 {start} > 0，其行為就像該字串在 {start}
		個位元組後開始，因而 "^" 會從 {start} 開始匹配。如果給出 {count}
		時則不是如此，此時忽略 {start} 位元組前的匹配 (有一點複雜，這是
		為了後向相容)。
		對字串而言，如果 {start} < 0，它被置為 0。對列表而言，此索引
		從尾部起算。
		如果 {start} 越界 (字串 {start} > strlen({expr})，而 |List|
		{start} > len({expr}))，返回 -1。

		如果給出 {count}，使用第 {count} 個匹配。如果字串裡找到一個
		匹配，下一匹配從此匹配之後一個字元開始尋找。所以下例返回 1: >
			echo match("testing", "..", 0, 2)
<		|List| 裡，搜尋從下一個專案開始。
		注意 如果加入 {count}，{start} 使用的方式有所改變。見上。

		|pattern| 說明可以接受的模式。
		'ignorecase' 選項用來設定模式是否忽略大小寫。_不_使用
		'smartcase'。匹配總是假定置位了 'magic' 而 'cpoptions' 為空。

					*matchadd()* *E798* *E799* *E801*
matchadd({group}, {pattern}[, {priority}[, {id}[, {dict}]]])
		定義模式 (一個 "匹配")， 在當前視窗用高亮組 {group} 高亮。返回
		標識號 (ID)，|matchdelete()| 可用該 ID 來刪除匹配。
		匹配是大小寫敏感和帶魔術的，但大小寫敏感性和魔術性在 {pattern}
		裡可被顯式關閉。不使用 'magic'、'smartcase' 和
		'ignorecase' 選項。
		"Conceal" 值是特別的，它使匹配被隱藏。

		可選的 {priority} 引數指定匹配的優先順序。高優先順序的匹配的高亮會
		否決低優先順序匹配的高亮。優先順序用整數指定 (負整數也無不可)。如
		果未指定 {priority} 引數，預設優先順序為 10。'hlsearch' 的優先順序
		為零，這樣所有正優先順序的匹配都可以否決它。語法高亮 (見
		'syntax') 採用不同的機制，無論選擇的優先順序如何，匹配總會否決語
		法的高亮。

		可選的 {id} 引數請求特定的匹配 ID。如果指定的 ID 已用，報錯，
		並不加入該匹配。ID 用正整數指定 (不含零)。ID 1、2 和 3 分別為
		|:match|、|:2match| 和 |:3match| 命令保留。如果 {id} 未指定或
		為 -1，|matchadd()| 自動選擇一個可用的 ID。

		可選的 {dict} 引數允許更多定製。目前，可用來指定特定於匹配的隱
		藏字元，使用 |hl-Conceal| 高亮匹配來顯示。該字典有以下成員:

			conceal	    顯示的特殊字元，而非匹配 (只用於
				    |hl-Conceal| 高亮匹配，見 |:syn-cchar|)

		匹配的數目不限，|:match| 諸命令則有此侷限。

		示例: >
			:highlight MyGroup ctermbg=green guibg=green
			:let m = matchadd("MyGroup", "TODO")
<		要刪除該模式: >
			:call matchdelete(m)

<		用 |getmatches()| 可以得到 |matchadd()| 和 |:match| 定義的匹配
		列表。|clearmatches()| 可一次刪除所有的匹配。

							*matchaddpos()*
matchaddpos({group}, {pos}[, {priority}[, {id}[, {dict}]]])
		和 |matchadd()| 相同，但需要位置列表 {pos} 而非匹配模式。比
		|matchadd()| 更快，因為無需處理正規表示式並設定緩衝區行邊界以
		重畫螢幕。主要用於需要快速增加或刪除匹配的場合，如匹配括號的高
		亮。

		{pos} 列表包含以下專案之一:
		- 數值。該行整行被高亮。首行的行號為 1。
		- 單個數值的列表。如 [23]。該行整行被高亮。
		- 包含兩個數值的列表，如 [23, 11]。前面的數是行號，後面的是列
		  號 (首列為 1，必須對應 |col()| 返回的位元組索引)。此位置的字元
		  被高亮。
		- 包含三個數值的列表，如 [23, 11, 3]。同上，但第三個數給出高亮
		  位元組計的長度。

		最多可有 8 個位置。

		示例: >
			:highlight MyGroup ctermbg=green guibg=green
			:let m = matchaddpos("MyGroup", [[23, 24], 34])
<		模式的刪除: >
			:call matchdelete(m)

<		|matchaddpos()| 加入的匹配在 |getmatches()| 返回時帶有專案
		"pos1"、"pos2"，等等，其值為 {pos} 專案提供的列表。
		這些匹配不能用 |setmatches()| 設定，但可用 |clearmatches()| 刪
		除。

matcharg({nr})							*matcharg()*
		選擇 {nr} 號匹配的專案，它們分別用 |:match|、|:2match| 或
		|:3match| 命令設定。
		返回兩個專案的 |List|:
			使用的高亮組名
			使用的模式。
		如果 {nr} 不是 1、2 或 3，返回空 |List|。
		如果沒有匹配的專案，返回 ['', '']。
		這用來儲存和恢復 |:match|。
		用 |:match| 命令高亮的匹配限於三個。|matchadd()| 無此限制。

matchdelete({id})			       *matchdelete()* *E802* *E803*
		刪除之前用 |matchadd()| 或 |:match| 諸命令定義的 ID 為 {id} 的
		匹配。如果成功，返回 0，不然返回 -1。示例見 |matchadd()|。
		|clearmatches()| 可一次刪除所有的匹配。

matchend({expr}, {pat}[, {start}[, {count}]])			*matchend()*
		和 |match()| 相同，但返回匹配之後的第一個字元的位置。比如: >
			:echo matchend("testing", "ing")
<		返回 "7"。
							*strspn()* *strcspn()*
		Vim 沒有 strspn() 或 strcspn() 函式，但可用 matchend() 實現: >
			:let span = matchend(line, '[a-zA-Z]')
			:let span = matchend(line, '[^a-zA-Z]')
<		不過沒有匹配時，它返回 -1。

		如果給出 {start}，和 |match()| 裡的用法相同。 >
			:echo matchend("testing", "ing", 2)
<		返回 "7"。 >
			:echo matchend("testing", "ing", 5)
<		返回 "-1"。
		如果 {expr} 是 |List|，結果和 |match()| 相同。

matchlist({expr}, {pat}[, {start}[, {count}]])			*matchlist()*
		和 |match()| 相同，但返回 |List|。列表第一項是匹配的字串，和
		|matchstr()| 返回值相同。其後的專案是子匹配，類似
		|:substitute| 的 "\1"、"\2" 等。如果某個可選的子匹配不匹配，用
		空字串代替。例如: >
			echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')
<		返回: ['acd', 'a', '', 'c', 'd', '', '', '', '', '']
		如果沒有匹配，返回空列表。

matchstr({expr}, {pat}[, {start}[, {count}]])			*matchstr()*
		和 |match()| 相同，但返回匹配的字串。例如: >
			:echo matchstr("testing", "ing")
<		返回 "ing"。
		如果沒有匹配，返回 ""。
		如果給出 {start}，它和 |match()| 裡的用法相同。 >
			:echo matchstr("testing", "ing", 2)
<		返回 "ing"。 >
			:echo matchstr("testing", "ing", 5)
<		返回 ""。
		如果 {expr} 是 |List|，返回匹配的專案。其型別不改變，因而不一
		定是字串。

matchstrpos({expr}, {pat}[, {start}[, {count}]])		*matchstrpos()*
		和 |matchstr()| 相同，但返回匹配的字串和匹配的始末位置。例
		如: >
			:echo matchstrpos("testing", "ing")
<		返回 ["ing", 4, 7]。
		如果沒有匹配，返回 ["", -1, -1]。
		如果給出 {start}，它和 |match()| 裡的用法相同。 >
			:echo matchstrpos("testing", "ing", 2)
<		返回 ["ing", 4, 7]。 >
			:echo matchstrpos("testing", "ing", 5)
<		返回 ["", -1, -1]。
		如果 {expr} 是 |List|，返回匹配專案，{pat} 匹配的首個專案的索
		引，匹配的開始位置和結束位置。 >
			:echo matchstrpos([1, '__x'], '\a')
<		返回 ["x", 1, 2, 3]。
		不改變型別，不必然是字串。

							*max()*
max({expr})	返回 {expr} 所有專案的最大值。
		{expr} 可以是列表或字典。如果是字典，返回字典中所有值的最大
		值。
		如果 {expr} 不是列表或字典，或者其中某個專案不能用作數值，出
		錯。空 |List| 或 |Dictionary| 返回零。

							*min()*
min({expr})	返回 {expr} 所有專案的最小值。
		{expr} 可以是列表或字典。如果是字典，返回字典中所有值的最小
		值。
		如果 {expr} 不是列表或字典，或者其中某個專案不能用作數值，出
		錯。空 |List| 或 |Dictionary| 返回零。

							*mkdir()* *E739*
mkdir({name} [, {path} [, {prot}]])
		建立目錄 {name}。
		如果 {path} 為 "p"，必要時建立中間的目錄。否則它必須是 ""。
		如果給出 {prot}，它用於設定新目錄的許可權。預設為 0755
		(rwxr-xr-x: 使用者自己可讀寫，其它人可讀)。用 0700 使其它人不可
		讀。這隻用於 {name} 的最後部分。所以，如果建立 /tmp/foo/bar，
		/tmp/foo 建立時的許可權是 0755。
		示例: >
			:call mkdir($HOME . "/tmp/foo/bar", "p", 0700)
<		該函式在沙盤裡不可用 |sandbox|。
		不一定在所有系統上都可用。要檢查這一點，使用: >
			:if exists("*mkdir")
<
							*mode()*
mode([expr])	返回指示當前模式的字串。
		如果指定 [expr] 並且其值為非零的數值或非空的字串
		(|non-zero-arg|)，返回完整模式，不然，返回第一個字母。

			n	普通模式
			no	操作符等待模式
			v	面向字元的可視模式
			V	面向行的可視模式
			CTRL-V	面向列塊的可視模式
			s	面向字元的選擇模式
			S	面向行的選擇模式
			CTRL-S	面向列塊的選擇模式
			i	插入模式
			ic	插入模式補全 |compl-generic|
			ix	插入模式 |i_CTRL-X| 補全
			R	替換模式 |R|
			Rc	替換模式補全 |compl-generic|
			Rv	虛擬替換模式 |gR|
			Rx	替換模式 |i_CTRL-X| 補全
			c	命令列編輯模式
			cv	Vim Ex 模式 |gQ|
			ce	普通 Ex 模式 |Q|
			r	輸入回車的提示
			rm	-- more -- 提示
			r?	|:confirm| 等等的詢問
			!	執行外殼或外部命令時
		可用於 'statusline' 選項或 |remote_expr()|。在其它的多數地方，
		它總是返回 "c" 或 "n"。
		另見 |visualmode()|。

mzeval({expr})							*mzeval()*
		計算 MzScheme 表示式 {expr} 並返回計算結果，轉換為 Vim 本身的
		資料結構。
		數值和字串返回本身。
		組對 (pair) (包含列表 (list) 和非常規列表 (improper list)) 和
		向量 (vector) 以 Vim |List| 形式返回。
		雜湊表 (hash table) 以 Vim |Dictionary| 形式返回，其鍵轉換成字
		符串。
		所有其它型別依 display 函式呼叫的結果轉換為字串。
		示例: >
		    :mz (define l (list 1 2 3))
		    :mz (define h (make-hash)) (hash-set! h "list" l)
		    :echo mzeval("l")
		    :echo mzeval("h")
<
		{僅當編譯時帶 |+mzscheme| 特性才有效}

nextnonblank({lnum})					*nextnonblank()*
		返回第一個從 {lnum} 開始的非空白行的行號。例如: >
			if getline(nextnonblank(1)) =~ "Java"
<		如果 {lnum} 非法或者在從該行開始都沒有非空白行，返回零。
		另見 |prevnonblank()|。

nr2char({expr}[, {utf8}])				*nr2char()*
		返回單個字元組成的字串，該字元的數值為 {expr}。例如: >
			nr2char(64)		返回 "@"
			nr2char(32)		返回 " "
<		如果 {utf8} 省略或為零，使用當前的 'encoding'。比如對 "utf-8"
		來說: >
			nr2char(300)		返回帶有弓形的 I
<		如果 {utf8} 為 1，則總返回 utf-8 字元。
		注意 檔案裡的 NUL 字元須用 nr2char(10) 指定。因為 Vim 用換行符
		來表示 NUL。真正的 NUL 是 nr2char(0)，而它會終結字串，因而返
		回空串。


or({expr}, {expr})					*or()*
		對兩個引數進行按位或。引數須轉換為數值。列表、字典或浮點數引數
		會報錯。
		示例: >
			:let bits = or(bits, 0x80)


pathshorten({expr})					*pathshorten()*
		縮短路徑 {expr} 裡的目錄名，返回其結果。路徑的尾部，即檔名，
		保持不變。路徑的其餘部分被縮短為單個字元。保持每個部分引導的
		'~' 和 '.' 字元不變。例如: >
			:echo pathshorten('~/.vim/autoload/myfile.vim')
<			~/.v/a/myfile.vim ~
		該路徑實際存在與否並不相干。

perleval({expr})					*perleval()*
		在標量上下文計算 Perl 表示式 {expr}，返回結果轉換為 Vim 資料結
		構。如果其值不能轉換，返回 Perl 表示的字串形式。
		備註: 如果要陣列或雜湊表，{expr} 必須返回它們的引用。
		例如: >
			:echo perleval('[1 .. 4]')
<			[1, 2, 3, 4]
		{僅當編譯時加入 |+perl| 特性才有效}

pow({x}, {y})						*pow()*
		返回浮點數，即 {x} 的 {y} 次方。
		{x} 和 {y} 的計算結果必須是浮點數或數值。
		示例: >
			:echo pow(3, 3)
<			27.0 >
			:echo pow(2, 16)
<			65536.0 >
			:echo pow(32, 0.20)
<			2.0
		{僅當編譯時加入 |+float| 特性才有效}

prevnonblank({lnum})					*prevnonblank()*
		返回第一個 {lnum} 所在或之上的非空白行的行號。例如: >
			let ind = indent(prevnonblank(v:lnum - 1))
<		如果 {lnum} 非法或者在該行和它之前都沒有非空白行，返回零。
		另見 |nextnonblank()|。


printf({fmt}, {expr1} ...)				*printf()*
		返回 {fmt} 指定的字串，其中每個 "%" 專案被它們對應的引數排版
		後的形式取代。例如: >
			printf("%4d: E%d %.30s", lnum, errno, msg)
<		可能的返回結果:
			"  99: E42 asdfasdfasdfasdfasdfasdfasdfas" ~

		常用的專案有:
		  %s	字串
		  %6S	右對齊到 6 個顯示單元的字串
		  %6s	右對齊到 6 個位元組的字串
		  %.9s  截短到 9 個位元組的字串
		  %c    單個位元組
		  %d    十進位制數
		  %5d   十進位制數，用空格補足到 5 個字元
		  %x    十六進位制數
		  %04x  十六進位制數，用 0 補足到 4 個字元
		  %X    十六進位制數，用大寫字母的十六進位制字母
		  %o    八進位制數
		  %08b	二進位制數，用 0 補足到 8 個字元
		  %f	浮點數，形如 12.23、inf、-inf 或 nan
		  %F	浮點數，形如 12.23、INF、-INF 或 NAN
		  %e	浮點數，形如 1.23e3、inf、-inf 或 nan
		  %E	浮點數，形如 1.23E3、INF、-INF 或 NAN
		  %g    浮點數，根據不同的值，使用合適的 %f 或 %e
		  %G    浮點數，根據不同的值，使用合適的 %F 或 %E
		  %%    % 字元本身

		轉換規格說明以 '%' 開始，以轉換型別結束。所有其它的字元按原樣
		複製到結果中。

		"%" 開始轉換規格說明。其後的引數依序如下:

			%  [flags]  [field-width]  [.precision]  type

		flags
			零或多個下面的標誌位:

		    #	      轉換值為 "替換形式"。對 c、d 和 s 轉換，此選項無
		              效。對 o 轉換，增加數值的精度，使得輸出字串的
			      第一個字元總是 0 (除非列印零值，且顯式地使用精度
			      0)。
			      對 b 和 B 轉換，非零值在前面加上字串 "0b" (B
			      轉換用 "0B")。
			      對 x 和 X 轉換，非零值在前面加上字串 "0x" (X
			      轉換用 "0X")。

		    0 (零)    以 0 填充。對所有的轉換，左側用 0 而非空格填充。
			      如果對數值的轉換給出精度 (d、b、B、o、x 和 X)，
			      忽略 0 標誌位。

		    -	      負域寬度標誌位；轉換後的值被左對齊到域邊界上。該
			      值右側用空格填充，而不是在左側用空格或 0 填充。
			      如果兩個標誌位同時給出，- 否決 0。

		    ' ' (空格)  帶符號轉換 (d) 產生的正數左側加上空格。

		    +	      帶符號轉換產生的數值之前總加上符號。如果兩個標誌
		              位同時給出，+ 否決空格。

		field-width
			可選的十進位制數位字串，指定最小的欄位寬度。如果轉換後
			的值的位元組數小於欄位寬度，在左側 (或右側，如果給定左對
			齊標誌位的話) 用空格填充到欄位寬度。

		.precision
			可選的精度，形式為句號 '.' 後跟一個可選的數位字串。
			如果省略了數位字串，假設精度為零。
			它給出 d、o、x 和 X 轉換顯示的最小數位數量，或 s 轉換
			顯示的字串的位元組的最大數量。
			對浮點數而言，指定小數點後的數位個數。

		type
			指定要進行的轉換型別的單個字元，見下。

		欄位寬度、精度 (兩者都有亦可) 可以用星號 '*' 代替數位字串。
		此情形下，一個數值引數指定欄位寬度或精度。負的欄位寬度被理解為
		帶左對齊的標誌位後跟一個正數字段寬度；負的精度被理解為就像不存
		在一樣。例如: >
			:echo printf("%d: %.*s", nr, width, line)
<		限制 "line" 文字的長度為 "width" 個位元組。

		轉換識別符號和它們的含義如下:

				*printf-d* *printf-b* *printf-B* *printf-o*
				*printf-x* *printf-X*
		dbBoxX	數值引數被轉換為帶符號十進位制 (d)，無符號二進位制 (b 和
			B)、無符號八進位制 (o) 或無符號十六進位制 (x 和 X) 記法。x
			轉換用字母 "abcdef"；X 轉換用 "ABCDEF" 字母。
			如果提供了精度，它給出必須出現的數位的最少數目；如果轉
			換後的值需要更少的數位，左側用 0 填充。
			任何情況下數值欄位都不會被不存在或者更小的欄位寬度所截
			短；如果轉換的結果寬於欄位寬度，欄位被擴充套件，以包含轉換
			後的結果。
			'h' 修飾符指示引數為 16 位。
			'l' 修飾符指示引數為 32 位。
			'L' 修飾符指示引數為 64 位。
			通常這些修飾符不怎麼有用。如果型別可從引數推知，修飾符
			被忽略。

		i	d 的別名
		D	ld 的別名
		U	lu 的別名
		O	lo 的別名

							*printf-c*
		c	數值引數被轉換為位元組，寫入產生的字元。

							*printf-s*
		s	使用字串引數的文字。如果指定精度，使用不多於給定數目
		        的位元組數。
			如果引數不是字串型，使用 ":echo" 相同的格式自動轉換
			到文字。
							*printf-S*
		S	使用字串引數的文字。如果指定精度，使用不多於給定數目
			的顯示單元數。編譯時如無 |+multi_byte| 特性，等同於
			's'。

							*printf-f* *E807*
                f F	浮點數引數被轉換為形如 123.456 的字串。精度指定小數
			點後面的位數。如果精度為零，則省略小數點本身。如果未指
			定精度，預設為 6。那個很大很大的數 (超出返回或除以零的
			結果) 用 %f 顯示 "inf" 或 "-inf" (%F 則顯示 INF 或
			-INF)。
			"0.0 / 0.0" 用 %f 顯示 "nan" (%F 顯示 NAN)。
			示例: >
				echo printf("%.2f", 12.115)
<				12.12
			注意 截斷方式取決於系統庫。如不確定，使用 |round()|。

							*printf-e* *printf-E*
		e E	浮點數引數被轉換為形如 1.234e+03 或用 'E' 的話
			1.234E+03 的字串。精度指定小數點後面的位數，和 'f'
			一樣。

							*printf-g* *printf-G*
		g G	如果浮點數引數在 0.001 (含) 和 10000000.0 (不含) 之
			間，則其轉換同 'f'，不然，'g' 同 'e' 而 'G' 同 'E'。如
			果未指定精度，除了小數點之後的那個零以外，不顯示多餘的
			零和 '+' 負號。因而，10000000.0 顯示為 1.0e7。

							*printf-%*
		%	寫入 '%'。不轉換引數。這裡完整的轉換規格說明是 "%%"。

		如果期待數值引數，字串引數也被接受並自動轉換。
		如果期待浮點數或字串引數，數值引數也被接受並自動轉換。
		其它引數型別產生錯誤資訊。

							*E766* *E767*
		{exprN} 引數的數量必須和 "%" 專案的數量完全匹配。不論引數不足
		還是過多，都會給出錯誤。至多可用 18 個引數。


pumvisible()						*pumvisible()*
		如果彈出選單可見，返回非零，不然返回零。見
		|ins-completion-menu|。
		可以用來避免一些會刪除彈出選單的動作。

py3eval({expr})						*py3eval()*
		計算 Python 表示式 {expr} 並返回計算結果，轉換為 Vim 本身的數
		據結構。
		數值和字串返回本身 (字串經過複製，Unicode 字串還須額外用
		'encoding' 轉換)。
		列表返回 Vim |List| 型別。
		字典返回 Vim |Dictionary| 型別，鍵值轉換為字串。
		{僅當編譯時加入 |+python3| 特性才有效}

							*E858* *E859*
pyeval({expr})						*pyeval()*
		計算 Python 表示式 {expr} 並返回計算結果，轉換為 Vim 本身的數
		據結構。
		數值和字串返回本身 (字串經過複製)。
		列表返回 Vim |List| 型別。
		字典返回 Vim |Dictionary| 型別，出現非字串的鍵值報錯。
		{僅當編譯時加入 |+python| 特性才有效}

pyxeval({expr})						*pyxeval()*
		計算 Python 表示式 {expr} 並返回計算結果，轉換為 Vim 本身的數
		據結構。
		使用 Python 2 或 3，見 |python_x| 和 'pyxversion'。
		另見: |pyeval()|、|py3eval()|
		{僅當編譯時加入 |+python| 或 |+python3| 特性才有效}

							*E726* *E727*
range({expr} [, {max} [, {stride}]])				*range()*
		返回數值的 |List|:
		- 如果只有指定 {expr}: [0, 1, ..., {expr} - 1]
		- 如果指定了 {max}: [{expr}, {expr} + 1, ..., {max}]
		- 如果指定了 {stride}: [{expr}, {expr} + {stride}, ...,
		  {max}] (每次給 {expr} 遞增 {stride}，但不會產生超過 {max} 的
		  值)。
		如果最大值比開始值小一，返回空列表。如果更小，報錯。
		例如: >
			range(4)		" [0, 1, 2, 3]
			range(2, 4)		" [2, 3, 4]
			range(2, 9, 3)		" [2, 5, 8]
			range(2, -2, -1)	" [2, 1, 0, -1, -2]
			range(0)		" []
			range(2, 0)		" 出錯！
<
							*readfile()*
readfile({fname} [, {binary} [, {max}]])
		讀入檔案 {fname} 並返回 |List|。，檔案每行一項。在 NL 字元處斷
		開行。以 CR 分隔的 Macintosh 檔案會返回單個長行 (除非某處出現
		了 NL)。
		所有的 NUL 字元被 NL 字元替代。
		如果 {binary} 包含 "b"，使用二進位制模式:
		- 如果末行以 NL 結尾，附加額外的一個空列表項。
		- 不刪除 CR 字元。
		否則:
		- NL 之前的 CR 字元被刪除。
		- 末行是否以 NL 結尾沒有影響。
		- 'encoding' 如是 Unicode 編碼，刪除文字可能有的 UTF-8 位元組順
		  序標識。
		如果給出 {max}，指定讀入的最大行數。可用於只想檢查檔案開始十行
		這樣的場合: >
			:for line in readfile(fname, '', 10)
			:  if line =~ 'Date' | echo line | endif
			:endfor
<		如果 {max} 為負，返回從檔案尾部起算 -{max} 行，有多少算多少。
		如果 {max} 為零，返回空列表。
		注意 如果沒有 {max}，把整個檔案讀到記憶體。
		也要 注意 這裡不識別編碼。如果需要，把檔案讀到緩衝區裡。
		如果檔案不能開啟，給出錯誤資訊，並返回空列表。
		另見 |writefile()|。

reltime([{start} [, {end}]])				*reltime()*
		返回代表時間值的專案。專案的格式取決於不同的系統。可以把它傳遞
		給 |reltimestr()| 來轉換為字串，或 |reltimefloat()| 來轉換為
		浮點數。
		沒有引數，返回當前時間。
		帶一個引數，返回引數指定的時間以來的時間。
		帶兩個引數，返回 {start} 和 {end} 之間跨越的時間。
		{start} 和 {end} 引數必須是 reltime() 返回的值。
		{僅當編譯時加入 |+reltime| 特性才有效}

reltimefloat({time})				*reltimefloat()*
		返回代表 {time} 的時間值的浮點數。
		示例: >
			let start = reltime()
			call MyFunction()
			let seconds = reltimefloat(reltime(start))
<		參見 reltimestr() 關於開銷的註釋。
		另見 |profiling|。
		{僅當編譯時加入 |+reltime| 特性才有效}

reltimestr({time})				*reltimestr()*
		返回字串，代表 {time} 的時間值。
		形式是秒數、句號和毫秒數。例如: >
			let start = reltime()
			call MyFunction()
			echo reltimestr(reltime(start))
<		注意 命令本身額外的開銷也計算在時間裡。時間的準確度取決於系
		統。
		返回結果包含引導的空格，使字串能很好地對齊。如果你不需要，用
		split() 可以刪掉。 >
			echo split(reltimestr(reltime(start)))[0]
<		另見 |profiling|。
		{僅當編譯時加入 |+reltime| 特性才有效}

							*remote_expr()* *E449*
remote_expr({server}, {string} [, {idvar} [, {timeout}]])
		傳送 {string} 到 {server}。該傳送的字串是一個表示式，而返回
		的是遠端執行的結果。這個結果必然是字串或 |List|。|List| 被轉
		換成字串，轉換方法是把專案用換行符連線起來 (末項之後沒有)，
		就像用 join(expr, "\n") 那樣。
		如果給出 {idvar} 且非空，將 {serverid} 儲存在以它命令的變數
		裡，此後的 remote_read() 需要使用此值。
		如果給出 {timeout}，在給定的秒數後讀取超時。否則，使用 600 秒
		超時。
		另見 |clientserver| |RemoteReply|。
		該函式在沙盤裡不可用 |sandbox|。
		{僅當編譯時加入 |+clientserver| 特性才有效}
		注意: 任何錯誤會在本地產生錯誤資訊，但返回的結果只是一個空字元
		串。
		例如: >
			:echo remote_expr("gvim", "2+2")
			:echo remote_expr("gvim1", "b:current_syntax")
<

remote_foreground({server})				*remote_foreground()*
		把名為 {server} 的 Vim 伺服器帶到前臺。
		這類似於: >
			remote_expr({server}, "foreground()")
<		Win32 系統除外。那裡，客戶端完成實際的工作。因為作業系統不
		總能允許伺服器把自己帶到前臺。
		注意: 如果視窗最小化，並不恢復之，foreground() 會這麼做。
		該函式在沙盤裡不可用 |sandbox|。
		{僅可用在 Win32、Athena、Motif 和 GTK 的 GUI 版本和 Win32 的控
		制臺版本}


remote_peek({serverid} [, {retvar}])		*remote_peek()*
		如果 {serverid} 有可用的字串，返回正數。如果指定了
		{retvar}，複製任何應答字串到 {retvar} 指定的變數。{retvar}
		必須是一個用來指定變數名的字串。
		如果沒有可用的應答，返回 0。
		如果出錯，返回 -1。
		另見 |clientserver|。
		該函式在沙盤裡不可用 |sandbox|。
		{僅當編譯時加入 |+clientserver| 特性才有效}
		示例: >
			:let repl = ""
			:echo "PEEK: ".remote_peek(id, "repl").": ".repl

remote_read({serverid}, [{timeout}])			*remote_read()*
		返回從 {serverid} 傳送的存在時間最長的應答，並刪除之。除非給出
		以秒計的 {timeout}，該呼叫會等待直到有應答為止。
		另見 |clientserver|。
		該函式在沙盤裡不可用 |sandbox|。
		{僅當編譯時加入 |+clientserver| 特性才有效}
		例如: >
			:echo remote_read(id)
<
							*remote_send()* *E241*
remote_send({server}, {string} [, {idvar}])
		傳送 {string} 到 {server}。傳送的字串是輸入鍵的序列。函式立
		即返回。Vim 的伺服器端不對鍵進行對映 |:map|。
		如果給出 {idvar}，將 {serverid} 儲存在以它命令的變數裡，此後的
		remote_read() 需要使用此值。
		另見 |clientserver| |RemoteReply|。
		該函式在沙盤裡不可用 |sandbox|。
		{僅當編譯時加入 |+clientserver| 特性才有效}

		注意: 任何錯誤會在伺服器端報告，從而影響那裡的顯示。
		例如: >
		:echo remote_send("gvim", ":DropAndReply ".file, "serverid").
		 \ remote_read(serverid)

		:autocmd NONE RemoteReply *
		 \ echo remote_read(expand("<amatch>"))
		:echo remote_send("gvim", ":sleep 10 | echo ".
		 \ 'server2client(expand("<client>"), "HELLO")<CR>')
<
					*remote_startserver()* *E941* *E942*
remote_startserver({name})
		成為伺服器 {name}。如果已作為伺服器執行，也即 |v:servername|
		不為空時此操作失敗。
		{僅當編譯時加入 |+clientserver| 特性才有效}

remove({list}, {idx} [, {end}])				*remove()*
		沒有 {end}: 刪除 |List| {list} 裡索引為 {idx} 的專案並返回之。
		有 {end}: 刪除從 {idx} 到 {end} (包含) 的專案，並返回這些專案
		的列表。如果 {idx} 指向和 {end} 相同的專案，返回單個專案的列
		表。如果 {end} 指向 {idx} 之前的專案，報錯。
		|list-index| 說明 {idx} 和 {end} 可能的取值。
		例如: >
			:echo "last item: " . remove(mylist, -1)
			:call remove(mylist, 0, 9)
remove({dict}, {key})
		刪除 {dict} 裡鍵為 {key} 的專案。例如: >
			:echo "removed " . remove(dict, "one")
<		如果 {dict} 裡沒有鍵 {key}，報錯。

		|delete()| 用來刪除檔案。

rename({from}, {to})					*rename()*
		把檔名 {from} 換成 {to}。這也可用來在檔案系統間移動檔案。返
		回數值，如果檔案成功換名，返回零，如果換名失敗，返回非零。
		注意 如果 {to} 已存在，它被覆蓋且沒有提示。
		該函式在沙盤裡不可用 |sandbox|。

repeat({expr}, {count})					*repeat()*
		重複 {expr} {count} 次，並返回連線後的結果。例如: >
			:let separator = repeat('-', 80)
<		如果 {count} 為零或負，返回空。
		如果 {expr} 是 |List| 型別，返回連線 {expr} {count} 次的結果。
		例如: >
			:let longlist = repeat(['a', 'b'], 3)
<		返回 ['a', 'b', 'a', 'b', 'a', 'b']。


resolve({filename})					*resolve()* *E655*
		在 MS-Windows 上，如果 {filename} 是一個快捷方式 (.lnk 檔案)，
		返回簡化的快捷方式指向的路徑。
		在 Unix 上，反覆分析 {filename} 的所有路徑部分的符號連結的真正
		路徑，直到返回最簡化的結果為止。為了處理迴圈連結的問題，符號鏈
		接的分析在 100 次疊代之後停止。
		在其它系統上，返回簡化了的 {filename}。
		簡化的工作通過 |simplify()| 完成。
		resolve() 保留指向當前目錄的首個路徑部分 (保證結果仍然是相對路
		徑名)，也保留出現在尾部的路徑分隔符。

							*reverse()*
reverse({list})	反轉 {list} 專案的順序，直接對 {list} 進行原位修改。返回
		{list}。如果你不想修改列表，先構建一個備份: >
			:let revlist = reverse(copy(mylist))

round({expr})							*round()*
		返回浮點數，即最接近於 {expr} 的整數。如果 {expr} 在兩個整數的
		正中間，使用 (譯者注: 絕對值) 較大 (遠離零的) 那個。
		{expr} 的計算結果必須是浮點數或數值。
		示例: >
			echo round(0.456)
<			0.0  >
			echo round(4.5)
<			5.0 >
			echo round(-4.5)
<			-5.0
		{僅當編譯時加入 |+float| 特性才有效}

screenattr(row, col)						*screenattr()*
		類似於 |screenchar()|，但返回屬性。是個相當任意的值，只可用於
		和其他位置的屬性進行比較。

screenchar(row, col)						*screenchar()*
		返回數值，即螢幕 [row, col] 位置的字元。可用於任何可能的螢幕
		位置，包括狀態行，視窗分隔符和命令列。左上位置的行列號都為一。
		返回字元不包括合成用字元。雙位元組編碼可能只返回第一個位元組。
		主要用於除錯。
		行號或列號越界時返回 -1。

screencol()							*screencol()*
		返回數值，即當前游標的螢幕列號。最左列的列號為 1。
		主要用於除錯。

		注意: 總是返回當前螢幕列，所以直接用於命令 (例如 ":echo
		screencol()") 時會返回命令列內的列號，其在命令執行時永遠為 1。
		要得到檔案中的游標位置，可用下面這些對映: >
			nnoremap <expr> GG ":echom ".screencol()."\n"
			nnoremap <silent> GG :echom screencol()<CR>
<
screenrow()							*screenrow()*
		返回數值，即當前游標的螢幕行號。最頂行的行號為 1。
		主要用於除錯。
		代為替代，也可用 |winline()|。

		注意: 和 |screencol()| 的限制相同。

search({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*search()*
		搜尋正規表示式模式 {pattern}。搜尋從游標位置 (用 |cursor()| 可
		以得到) 開始。

		如果找到了匹配，返回其所在的行號。
		如果找不到匹配，返回 0 並且游標位置不改變。不會給出錯誤資訊。

		{flags} 是字串，可以包含以下字元標誌位:
		'b'	反向 (Backward) 搜尋，而不是正向搜尋
		'c'     接受游標 (Cursor) 位置上的匹配
		'e'	移到匹配的尾部 (End)
		'n'	不 (Not) 移動游標
		'p'	返回匹配的子模式 (Pattern) 號 (見下)
		's'	在游標上次的位置上設定 (Set) ' 位置標記
		'w'	在檔案尾部處迴繞 (Wrap) 到檔案開始處
		'W'	不在檔案尾部處迴繞 (Wrap)
		'z'	從游標列開始搜尋而不是第零 (Zero) 列
		如果 'w' 和 'W' 都沒有給出，根據 'wrapscan' 選項決定。

		如果提供 's' 標誌位，只有在游標移動的時候才設定 ' 位置標記。
		's' 標誌位不能和 'n' 標誌位一起使用。

		適用 'ignorecase'、'smartcase' 和 'magic' 標誌位。

		如果沒給出 'z' 標誌位，搜尋總是從第零列開始，然後跳過游標之前
		的匹配。如果 'cpo' 中有 'c' 標誌位，下次搜尋從匹配之後的位置開
		始。沒有 'c' 標誌位則下次搜尋從游標之後一列開始。

		如果給出 {stopline} 引數，搜尋在搜尋完該行後結束。可用於限制搜
		索在給出的行範圍內。例如: >
			let match = search('(', 'b', line("w0"))
			let end = search('END', '', line("w$"))
<		如果使用了 {stopline} 且非零，隱含意味著搜尋不會在檔案尾迴繞。
		零就相當於沒給出該引數。

		如果給出 {timeout} 引數，搜尋在超過給出的毫秒數後中止。這樣，
		如果 {timeout} 為 500，搜尋在半秒鐘後中止。該值不能為負。
		零就相當於沒給出該引數。
		{僅當在編譯時加入 |+reltime| 特性才有效}

							*search()-sub-match*
		如果有 'p' 標誌位，返回值比第一個匹配的 \(\) 裡的子模式的編號
		多一。如果所有子模式都不匹配但整個模式匹配，返回一。
		要得到列號，使用 |searchpos()|。

		游標定位在匹配的文字上，除非使用了 'n' 標誌位。

		示例 (遍歷引數列表裡的所有檔案): >
		    :let n = 1
		    :while n <= argc()	    " 迴圈遍歷引數列表的每個檔案
		    :  exe "argument " . n
		    :  " 從檔案最後一個字元開始並回繞，這樣第一個搜尋可以找到
		    :  " 檔案開始的匹配
		    :  normal G$
		    :  let flags = "w"
		    :  while search("foo", flags) > 0
		    :    s/foo/bar/g
		    :	 let flags = "W"
		    :  endwhile
		    :  update		    " 如果修改過，寫入檔案
		    :  let n = n + 1
		    :endwhile
<

searchdecl({name} [, {global} [, {thisblock}]])			*searchdecl()*
		搜尋 {name} 的宣告。

		如果 {global} 引數非零，使用 |gD| 的工作方式，尋找檔案的第一個
		匹配。否則使用 |gd| 的工作方式，尋找函式裡的第一個匹配。

		如果 {thisblock} 引數非零，忽略游標位置前結束的 {} 塊裡的匹
		配。可以避免只有在別的作用域裡才有效的變數宣告。

		移動游標到找到的匹配上。
		返回零代表成功，非零代表失敗。
		例如: >
			if searchdecl('myvar') == 0
			   echo getline('.')
			endif
<
							*searchpair()*
searchpair({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		搜尋巢狀的 start-end 組對的匹配。這可以用來查詢匹配 "if" 的
		"endif"。在這裡面的其它的 if/endif 組對被忽略。搜尋從游標開
		始。預設正向搜尋，在 {flags} 裡包含 'b' 的時候反向搜尋。
		如果找到一個匹配，游標移動到那裡並返回行號。如果沒有匹配，
		返回 0 或者 -1，游標不移動。不會給出錯誤資訊。

		{start}、{middle} 和 {end} 都是模式，見 |pattern|。它們不能包
		含 \( \) 對，但可以使用 \%( \)。如果 {middle} 非空，在相應的方
		向試圖尋找它 (如果找到，停留在哪裡)，但在巢狀的 start-end 組對
		裡面的不算。一個典型的應用是: >
			searchpair('\<if\>', '\<else\>', '\<endif\>')
<		如果 {middle} 為空，跳過 "else"。

		{flags} 'b'、'c'、'n'、's'、'w' 和 'W' 的使用方式和 |search()|
		類似。此外，還可用:
		'r'	重複 (Repeat) 直到沒有更多匹配位置；會找到最外層的組
		        對。隱含 'W' 標誌位。
		'm'	返回匹配 (Match) 的數目而不是匹配的行號；使用 'r' 時會
			> 1。
		備註: 最好使用 'W' 標誌位，避免在檔案尾迴繞。

		如果找到 {start}、{middle} 或 {end} 的匹配，計算 {skip} 表達
		式，此時假定游標定位在匹配的開始處。如果返回零，該匹配被跳過。
		比如，可能是出現在註釋裡的匹配。
		如果 {skip} 不提供或者為空，接受每一個匹配。如果計算 {skip} 時
		出現錯誤，搜尋被中止，並返回 -1。

		{stopline} 和 {timeout} 見 |search()|。

		使用 'ignorecase' 的值。忽略 'magic'，使用模式時假設它總是置位
		的。

		搜尋從準確的游標處開始。根據搜尋方向，尋找從下一個字元開始的
		{start}、{middle} 或 {end}。比如: >
			if 1
			  if 2
			  endif 2
			endif 1
<		如果從 "if 2" 開始且游標在 "i" 上並正向搜尋，找到的是
		"endif 2"。如果剛好在 "if 2" 之前開始，找到的是 "endif 1"。因
		為先找到的了 "if 2"，而它被認為是巢狀的 if/endif，以 "if 2"
		開始，以 "endif 2" 結束。
		如果反向搜尋且 {end} 多於一個字元，在模式的最後加上 "\zs" 可能
		有用，這樣游標在 end 匹配的中間某位置的時候，仍然可以找到匹配
		的 start 匹配。

		例如，要找到 Vim 腳本里的 "endif" 命令: >

	:echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
			\ 'getline(".") =~ "^\\s*\""')

<		游標必須在要尋找匹配的 "if" 之上或之後。注意 單引號字串的使
		用，它避免了反斜槓的麻煩。skip 表示式只用來發現行首的註釋，命
		令之後的不行。另外，一行中間的單詞 "en" 或 "if" 也被認為是匹
		配。
		另一個例子，搜尋匹配 "}" 的 "{": >

	:echo searchpair('{', '', '}', 'bW')

<		只需要游標在需要匹配的 "}" 之上或之前就可以了。要拒絕語法高亮
		識別為字串的匹配: >

	:echo searchpair('{', '', '}', 'bW',
	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
<
							*searchpairpos()*
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		和 |searchpair()| 相同，但返回 |List|，包含匹配的行號和列號。
		|List| 的第一個元素是行號，而第二個元素是匹配所在的列位置的字
		節位置。如果沒有匹配，返回 [0, 0]。 >

			:let [lnum,col] = searchpairpos('{', '', '}', 'n')
<
		|match-parens| 提供一個更復雜更有用的例子。

searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*searchpos()*
		和 |search()| 相同，但返回 |List|，包含匹配的行號和列號。
		|List| 的第一個元素是行號，而第二個元素是匹配所在的列位置的字
		節位置。如果沒有匹配，返回 [0, 0]。
		例如: >
	:let [lnum, col] = searchpos('mypattern', 'n')

<		如果給出 'p' 標誌位，返回值裡有一個附加專案，包含匹配的子模式
		號 |search()-sub-match|。例如: >
	:let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
<		此例中如果找到小寫字母 |/\l| "submatch" 為 2，如果找到大寫字母
		|/\u| 則為 3。

server2client({clientid}, {string})			*server2client()*
		傳送應答字串到 {clientid}。最近剛傳送過字串的 {clientid}
		可以通過 expand("<client>") 得到。
		{僅當在編譯時加入 |+clientserver| 特性才有效}
		備註:
		該 id 應在接受下一個命令前儲存。也就是，在接收命令返回之前 (譯
		者注: 似應為 "之後") 和任何等待輸入的命令之前。
		另見 |clientserver|。
		示例: >
			:echo server2client(expand("<client>"), "HELLO")
<
serverlist()					*serverlist()*
		返回可用的伺服器名字列表，每行一個。如果沒有伺服器或者該資訊
		無法得到，返回空字串。另見 |clientserver|。
		{僅當編譯時加入 |+clientserver| 特性才有效}
		示例: >
			:echo serverlist()
<
setbufvar({expr}, {varname}, {val})			*setbufvar()*
		設定緩衝區 {expr} 的選項或區域性變數 {varname} 的值為 {val}。
		也可用於全域性或者區域性於視窗的選項，但不能用於全域性或者區域性於視窗
		的變數。
		如果設定區域性於視窗的選項，全域性值不會改變。
		{expr} 的使用方式見上 |bufname()|。
		注意必須使用不帶 "b:" 的變數名。
		示例: >
			:call setbufvar(1, "&mod", 1)
			:call setbufvar("todo", "myvar", "foobar")
<		該命令在沙盤裡不可用 |sandbox|。

setcharsearch({dict})					*setcharsearch()*
		用 {dict} 設定當前字元搜尋資訊，帶有以下專案:

		    char	下次 |,| 或 |;| 命令使用的字元；空字串清除字
		    		符搜尋
		    forward	字元搜尋的方向；1 為正向，0 為反向
		    until	字元搜尋的型別；1 為 |t| 為 |T| 字元搜尋，0 為
		    		|f| 或 |F| 字元搜尋

		可用於在指令碼中儲存/恢復使用者的字元搜尋: >
			:let prevsearch = getcharsearch()
			:" 執行改寫使用者搜尋的命令
			:call setcharsearch(prevsearch)
<		另見 |getcharsearch()|。

setcmdpos({pos})					*setcmdpos()*
		設定命令列的游標位置到位元組位置 {pos}。第一個位置為 1。
		用 |getcmdpos()| 得到當前的位置。
		只有在編輯命令列時有效，所以必須在 |c_CTRL-\_e|、|c_CTRL-R_=|
		或帶 '=' 的 |c_CTRL-R_CTRL-R| 裡使用。對於 |c_CTRL-\_e| 和帶
		'=' 的 |c_CTRL-R_CTRL-R|，在命令列設為表示式的內容之後才設定位
		置。對於 |c_CTRL-R_=|，在計算表示式之後但在插入返回的文字之前
		設定位置。
		如果數值太大，游標放在行尾。如果小於 1，結果沒有定義。
		如果成功，返回 0，如果不在編輯命令列，返回 1。

setfperm({fname}, {mode})				*setfperm()* *chmod*
		設定 {fname} 的檔案許可權為 {mode}。
		{mode} 必須是 9 個字元的字串。形如 "rwxrwxrwx"，每組 "rwx"
		標誌位代表著，按次序，檔案擁有者、檔案所屬組和其他使用者的許可權。
		'-' 字元代表關閉許可權，其他字元代表開啟。不支援多位元組字元。

		例如 "rw-r-----" 意味著使用者可讀寫，組只讀，其他不可訪問。
		"xx-x-----" 作用相同。

		返回非零代表成功，零代表失敗。

		要讀取許可權可見 |getfperm()|。


setline({lnum}, {text})					*setline()*
		設定當前緩衝區第 {lnum} 行的內容為 {text}。要插入新行，用
		|append()|。
		{lnum} 的用法同 |getline()|。
		如果 {lnum} 剛剛在末行之下，{text} 用來增加新行。
		如果成功，返回 0。如果失敗 (多數是因為 {lnum} 不合法) 返回 1。
		例如: >
			:call setline(5, strftime("%c"))
<		如果 {text} 為 |List|，那麼第 {lnum} 行和其後的行被設為列表裡
		的專案。例如: >
			:call setline(5, ['aaa', 'bbb', 'ccc'])
<		等價於: >
			:for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]
			:  call setline(n, l)
			:endfor
<		注意: 這裡不會設定 '[ 和 '] 位置標記。

setloclist({nr}, {list}[, {action}[, {what}]])		*setloclist()*
		建立或替代或加入到視窗 {nr} 的位置列表。
		{nr} 可以是視窗號或 |window-ID|。
		如果 {nr} 為零，使用當前視窗。

		如果是位置列表視窗，修改所顯示的位置列表。如果視窗號 {nr} 非
		法，返回 -1。
		其它同 |setqflist()|。
		另見 |location-list|。

		如果給出可選的 {what} 字典引數，只設置 {what} 中列出的專案。
		關於 {what} 支援的鍵值的列表，參見 |setqflist()|。

setmatches({list})					*setmatches()*
		恢復 |getmatches()| 儲存的匹配列表。如果成功，返回 0，否則返回
		-1。原有的所有匹配都被清除。示例見 |getmatches()|。

							*setpos()*
setpos({expr}, {list})
		設定 {expr} 的位置。可能的值:
			.	游標
			'x	位置標記 x

		{list} 必須是帶四個或五個數值的 |List|:
		    [bufnum, lnum, col, off]
		    [bufnum, lnum, col, off, curswant]

		"bufnum" 是緩衝區號。零代表當前緩衝區。如果設定大寫位置標記，
		"bufnum" 是位置標記位置的一部分。對其它的位置標記，它用於指定
		設定位置標記的緩衝區。可以用 |bufnr()| 函式把檔名轉化為緩衝
		區號。
		設定游標和 ' 位置標記時忽略 "bufnum"，因為它們和視窗相關，而不
		是緩衝區相關。
		不修改跳轉表。

		"lnum" 和 "col" 是緩衝區裡的位置。第一列為 1。"lnum" 為零則刪
		除位置標記。"col" 如小於 1，則以 1 代替。

		除非使用了 'virtualedit'，不用 "off" 值。這是從對應字元開始位
		置以螢幕列計的位移。例如，在製表之中或最後一個字元之後的某個位
		置。

		"curswant" 值只用於設定游標位置。它指定垂直移動游標時的首選
		列。如果沒有 "curswants" 值，不設定首選列。如果有但用於設定位
		置標記時，也沒有效果。

		注意對 '< 和 '> 而言，改變行號可能會使兩者在實際中被調換，以保
		證 '< 總是在 '> 之前。

		如果位置可以設定，返回 0，否則返回 -1。如果 {expr} 不合法，報
		錯。

		另見 |getpos()| 和 |getcurpos()|。

		這並不能恢復垂直移動使用的列；如果用它設定了游標位置，|j| 和
		|k| 動作會跳轉到上次的列上！|cursor()| 也可設定首選列。另見
		|winrestview()| 的 "curswant" 鍵。

setqflist({list} [, {action}[, {what}]])		*setqflist()*
		用 {list} 的專案來建立或替代或加入到 quickfix 表。每個 {list}
		專案是一個字典。
		{list} 裡非字典的專案被忽略。每個字典專案可以包含以下的專案:

		    bufnr	緩衝區號；必須為某個合法緩衝區的編號
		    filename	檔名；僅當 "bufnr" 不存在或者不合法時才使用
		    lnum	緩衝區裡的行號
		    pattern	用於定位錯誤的模式
		    col		列號
		    vcol	非零: "col" 是可視列
				零: "col" 是位元組位置
		    nr		錯誤號
		    text	錯誤描述
		    type	錯誤型別，'E'、'W' 等。
		    valid	經過識別的錯誤資訊

		"col"、"vcol"、"nr"、"type" 和 "text" 專案是可選的。"lnum" 或
		"pattern" 專案用來定位匹配的錯誤行。
		如果 "filename" 和 "bufnr" 專案都不存在或者 "lnum" 和
		"pattern" 專案都不存在，那麼此專案不被當作錯誤行處理。
		如果 "pattern" 和 "lnum" 都存在，使用 "pattern"。
		如果不提供 "valid" 專案，則在 "bufnr" 為合法的緩衝區或
		"filename" 存在時，置位 valid 標誌位。
		如果 {list} 為空，quickfix 列表被清除。
		注意 此列表和 |getqflist()| 返回之值不盡相同。

		{action} 值:					*E927*
		'a'	把 {list} 專案加入已有的 quickfix 列表。如果該列表尚不
			存在，建立新表。

		'r'	{list} 專案替換當前 quickfix 列表專案。也可用於清除列
			表: >
				:call setqflist([], 'r')
<
		'f'	釋放 quickfix 堆疊上的所有 quickfix 列表。

		如果 {action} 不存在或者設為 ' '，那麼建立新表。

		如果提供了可選的 {what} 字典引數，只設置 {what} 列出的專案，忽
		略首個引數 {list}。{what} 支援以下專案:
			context	任何 Vim 型別都可作為上下文存放
			items	quickfix 專案的列表，同 {list} 引數。
			nr	quickfix 堆疊中的列表號；零代表當前
				quickfix 列表，'$' 代表最後的 quickfix 列表
			title	quickfix 列表標題
		忽略 {what} 中不支援的專案。
		如果不給出 "nr"，修改當前 quickfix 列表。要建立新的 quickfix
		列表，"nr" 可設為比 quickfix 棧大小大一的值。

		示例: >
			:call setqflist([], 'r', {'title': 'My search'})
			:call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})
<
		返回零代表成功，-1 代表失敗。

		該函式用來獨立於 'errorformat' 的設定建立 quickfix 列表。
		`:cc 1` 這樣的命令可以跳轉到第一個位置上。


							*setreg()*
setreg({regname}, {value} [, {options}])
		設定暫存器 {regname} 的值為 {value}。
		{value} 可以是 |getreg()| 返回的任何型別，包括 |List|。
		如果 {options} 包含 "a" 或者 {regname} 為大寫，該值被附加於現
		有值之後。
		{options} 還可以指定暫存器新型別的規格:
		    "c" 或 "v"	      |characterwise| (面向字元) 模式
		    "l" 或 "V"	      |linewise| (面向行) 模式
		    "b" 或 "<CTRL-V>" |blockwise-visual| (面向列塊) 模式
		如果 "b" 或 "<CTRL-V>" 之後緊跟數值，那麼該數值用作選擇的寬度
		- 如果沒有指定，那麼列塊的寬度設為最長的行字元數 (把 <Tab>
		看作一個字元)。

		如果 {options} 沒有暫存器設定，那麼字串值 {value} 預設使用面
		向字元模式，除非 {value} 以 <NL> 結尾，列表值的 {value} 預設使
		用面向行模式。不會自動選擇面向列塊模式。
		返回零代表成功，非零代表失敗。

							*E883*
		備註: 設定搜尋和表示式暫存器時，不可使用多於一個專案的
		      |List|。無專案的列表相當於空串。

		示例: >
			:call setreg(v:register, @*)
			:call setreg('*', @%, 'ac')
			:call setreg('a', "1\n2\n3", 'b5')

<		本例說明如何使用函式來儲存和恢復暫存器 (注意: 如果不提供
		|getreg()| 的第三個引數，就不能可靠地恢復暫存器值，因為此時，
		換行符和 Nul 位元組都用換行符表示，見 |NL-used-for-Nul|)。 >
			:let var_a = getreg('a'， 1)
			:let var_amode = getregtype('a')
			    ....
			:call setreg('a', var_a, var_amode)

<		你可以通過附加空串來改變暫存器的型別: >
			:call setreg('a', '', 'al')

settabvar({tabnr}, {varname}, {val})			*settabvar()*
		設定標籤頁 {tabnr} 的標籤頁區域性變數 {varname} 的值為 {val}。
		注意 必須使用不帶 "t:" 的名字。
		標籤頁的編號從一開始。
		該命令在沙盤裡不可用 |sandbox|。

settabwinvar({tabnr}, {winnr}, {varname}, {val})	*settabwinvar()*
		設定視窗 {nr} 的選項或區域性變數 {varname} 的值為 {val}。
		標籤頁的編號從一開始。|setwinvar()| 總是使用當前標籤頁。
		{winnr} 可以是視窗號或 |window-ID|。
		如果 {winnr} 為零，使用當前視窗。
		也可用於全域性或者區域性於緩衝區的選項，但不能用於全域性或者區域性於緩
		衝區的變數。
		如果設定區域性於緩衝區的選項，全域性值不會改變。
		注意 必須使用不帶 "w:" 的變數名。
		示例: >
			:call settabwinvar(1, 1, "&list", 0)
			:call settabwinvar(3, 2, "myvar", "foobar")
<		該命令在沙盤裡不可用 |sandbox|。

setwinvar({nr}, {varname}, {val})			*setwinvar()*
		類似於 |settabwinvar()|，只用當前標籤頁。
		示例: >
			:call setwinvar(1, "&list", 0)
			:call setwinvar(2, "myvar", "foobar")

sha256({string})						*sha256()*
		返回 64 位十六進位制字串，即 {string} 的 SHA256 校驗碼。
		{僅當編譯時加入 |+cryptv| 特性才有效}

shellescape({string} [, {special}])			*shellescape()*
		轉義 {string} 以便用作外殼命令的引數。
		在 MS-Windows 和 MS-DOS 上，如果未設定 'shellslash'，用雙引號
		包圍 {string}，並給 {string} 內的雙引號加倍。
		否則，用單引號包圍，並把所有的 "'" 替換為 "'\''"。

		如果給出 {special} 引數且它是非零的數值或非空的字串
		(|non-zero-arg|)，則特殊專案如 "!"、"%"、"#" 和 "<cword>" 等會
		在前面加上反斜槓。|:!| 命令會再把反斜槓刪除。

		如果 'shell' 以 "csh" 結尾，"!" 字元會被轉義 (仍是當 {special}
		為 |non-zero-arg| 時)。這是因為 csh 和 tcsh 即使在單引號內仍然
		使用 "!" 用於歷史替換。

		如果 {special} 為 |non-zero-arg|，<NL> 也被轉義。'shell' 以
		"csh" 結尾時，轉義兩次。

		|:!| 命令的示例: >
		    :exe '!dir ' . shellescape(expand('<cfile>'), 1)
<		返回游標所在檔案給出的目錄列表。|system()| 的示例: >
		    :call system("chmod +w -- " . shellescape(expand("%")))
<		另見 |::S|。


shiftwidth()						*shiftwidth()*
		返回 'shiftwidth' 的有效值。即 'shiftwidth' 值，除非其為零時則
		返回 'tabstop' 的值。此函式是 2012 年 7.3.694 補丁版本引入的，
		現在應該大家都有了。


simplify({filename})					*simplify()*
		在不改變含義的前提下，儘可能簡化檔名。快捷方式 (MS-Windows
		上) 或者符號連結 (Unix 上) 不會被解析。如果 {filename} 第一個
		路徑部分指定了當前目錄，結果也會是如此。而結尾的路徑分隔符也不
		會被刪除。
		示例: >
			simplify("./dir/.././/file/") == "./file/"
<		注意: 組合 "dir/.." 只有在 "dir" 是可以遍歷的或者不存在的目錄
		才會被刪掉。Unix 上，如果 "dir" 是同一目錄下的符號連結，也會刪
		除該組合。為了在簡化路徑名之前解析所有牽涉到的符號連結，使用
		|resolve()|。


sin({expr})						*sin()*
		返回浮點數，即以弧度測量的 {expr} 的正弦值。
		{expr} 的計算結果必須是浮點數或數值。
		示例: >
			:echo sin(100)
<			-0.506366 >
			:echo sin(-4.01)
<			0.763301
		{僅當編譯時加入 |+float| 特性才有效}


sinh({expr})						*sinh()*
		返回 {expr} 的雙曲正弦值，返回值為 [-inf, inf] 區間內的浮點
		數。
		{expr} 的計算結果必須是浮點數或數值。
		示例: >
			:echo sinh(0.5)
<			0.521095 >
			:echo sinh(-0.9)
<			-1.026517
		{僅當編譯時加入 |+float| 特性才有效}


sort({list} [, {func} [, {dict}]])			*sort()* *E702*
		給 {list} 專案排序，原地直接修改列表。返回 {list}。

		如果你不想修改列表，先構建一個備份: >
			:let sortedlist = sort(copy(mylist))

<		如果 {func} 省略、為空或為零，則 sort() 對每個專案使用字串表
		示形式進行排序。數值排在字串之後，|List| 排在數值之後。要給
		當前緩衝區的文字排序，用 |:sort|。

		如果給出 {func} 且為 '1' 或 'i'，忽略大小寫。

		如果給出 {func} 且為 'n'，按數值順序排序 (實現細節: 用
		strtod() 函式來解析數值，字串、列表、字典和函式引用均視作
		0)。

		如果給出 {func} 且為 'N'，按數值順序排序。和 'n' 類似，但包含
		數位的字串會被當作數值。

		如果給出 {func} 且為 'f'，按數值順序排序。所有值的型別必須是數
		值或浮點數。

		如果 {func} 為 |Funcref| 或函式名，呼叫該函式來比較專案。函式
		呼叫時使用兩個專案作為引數，函式返回時，0 代表相等，1 或更高代
		表第一個排在第二個之後，-1 或更小代表第一個排在第二個之前。

		{dict} 用於帶 "dict“ 屬性的函式，並設為區域性變數 "self"。
		|Dictionary-function|

		排序是穩定的，相同值 (數值或字串) 的專案保持原有的順序不變。
		例如，按數值順序排序時，文字字串會緊挨在一起，按原先的順序出
		現。

		另見 |uniq()|。

		例如: >
			func MyCompare(i1, i2)
			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
			endfunc
			let sortedlist = sort(mylist, "MyCompare")
<		對這個簡單的例子，有更簡短的一個比較版本，不考慮溢位情況: >
			func MyCompare(i1, i2)
			   return a:i1 - a:i2
			endfunc
<

							*soundfold()*
soundfold({word})
		返回 {word} 按發音摺疊的等價形式。使用當前視窗的 'spelllang'
		中第一個支援按發音摺疊的語言。 'spell' 必須置位。如果不能按發
		音摺疊，按原樣返回 {word}。
		可用來提供拼寫建議。注意 此方法可能很慢。

							*spellbadword()*
spellbadword([{sentence}])
		沒有引數: 返回游標所在或之後的拼寫錯誤的單詞。游標移動到這個壞
		詞的開始處。如果游標行上沒有壞詞，返回空字串，不移動游標。

		有引數: 返回 {sentence} 裡第一個拼寫錯誤的單詞。如果沒有拼寫錯
		誤，返回空字串。

		返回值是兩個專案的列表:
		- 錯誤拼寫的單詞，或空字串。
		- 拼寫錯誤的型別:
			"bad"		拼寫錯誤
			"rare"		偏僻詞
			"local"		只在其它區域裡合法的單詞
			"caps"		單詞應該大寫開頭
		例如: >
			echo spellbadword("the quik brown fox")
<			['quik', 'bad'] ~

		使用當前視窗的拼寫資訊。'spell' 選項必須置位，也用到
		'spelllang' 的值。

							*spellsuggest()*
spellsuggest({word} [, {max} [, {capital}]])
		返回 |List|，包含替代 {word} 的拼寫建議。
		如果給出 {max}，返回的建議不超過此數目。否則，返回不超過 25 個
		建議。

		如果給出 {capital} 引數且非零，只給出大寫開頭的拼寫建議。
		'spellcapcheck' 匹配後再使用此功能。

		{word} 可以是後跟其它文字的錯誤拼寫單詞。這樣可以對兩個被分開
		的單詞進行連線。建議裡也包含附加文字，以便你替換整行。

		{word} 也可以是個好詞。返回和它類似的單詞。建議裡不包含 {word}
		自身，但可能會出現其大寫開頭的形式。

		使用當前視窗的拼寫資訊。'spell' 選項必須置位，也用到
		'spelllang' 和 'spellsuggest' 的值。


split({expr} [, {pattern} [, {keepempty}]])			*split()*
		從 {expr} 構造 |List|。
		如果 {pattern} 省略或為空，用每個空白分隔的字元序列構造一個項
		目。否則，在匹配 {pattern} 的地方分割字串，刪除匹配部分的字
		符。'ignorecase' 此處不適用，要忽略大小寫，加上 \c。|/\c|
		如果列表的首末專案為空，省略它們，除非 {keepempty} 引數給出且
		非零。其它空專案在 {pattern} 匹配至少一個字元或者 {keepempty}
		非零的時候被保留。
		例如: >
			:let words = split(getline('.'), '\W\+')
<		要把字串分割到每個字元: >
			:for c in split(mystring, '\zs')
<		如果你想保留分隔符，可以在模式尾部用 '\zs': >
			:echo split('abc:def:ghi', ':\zs')
<			['abc:', 'def:', 'ghi'] ~
		分割首項可能為空的表格: >
			:let items = split(line, ':', 1)
<		逆函式是 |join()|。


sqrt({expr})						*sqrt()*
		返回浮點數，即 {expr} 的非負平方根。
		{expr} 的計算結果必須是浮點數或數值。如果 {expr} 為負，返回
		NaN (Not a Number，非數)。
		示例: >
			:echo sqrt(100)
<			10.0 >
			:echo sqrt(-4.01)
<			nan
		"nan" 可能不同，取決於系統庫。
		{僅當編譯時加入 |+float| 特性才有效}


str2float({expr})					*str2float()*
		把字串 {expr} 轉換為浮點數。這和使用浮點數的工作方式一樣，見
		|floating-point-format|，但稍稍寬鬆一點。例如，接受 "1e40"，而
		表示式中你必須書寫 "1.0e40"。
		安靜地忽略數值之後的文字。
		小數點必須是 '.'，和當前的 locale 無關。逗號會使數值轉換結束:
		"12,345.67" 轉換為 12.0。用 |substitute()| 可以拿掉千分位分
		隔符: >
			let f = str2float(substitute(text, ',', '', 'g'))
<		{僅當編譯時加入 |+float| 特性才有效}


str2nr({expr} [, {base}])				*str2nr()*
		把字串 {expr} 轉化為數值。
		{base} 是轉換的基底，可以為 2、8、10 或 16。
		如果省略 {base}，使用基底 10。這也意味著開頭的零不會導致八進位制
		的轉換，預設的字串到數值的轉化並非如此。
		如果 {base} 為 16，忽略開頭的 "0x" 或 "0X"。如果使用別的基底，
		返回零。類似的，如果 {base} 為 8，忽略開頭的 "0"，如果 {base}
		為 2，忽略開頭的 "0b" 或 "0B"。
		安靜地忽略數值之後的文字。


strchars({expr} [, {skipcc}])					*strchars()*
		返回數值，給出字串 {expr} 中的字元數。
		{skipcc} 省略或為零時，組合用字元也算一個字元。
		{skipcc} 設為 1 時，計算時忽略組合用字元。
		另見 |strlen()|、|strdisplaywidth()| 和 |strwidth()|。

		{skipcc} 只在 7.4.755 之後才出現。為了後向相容，可以這樣定義
		包裝函式: >
		    if has("patch-7.4.755")
		      function s:strchars(str, skipcc)
			return strchars(a:str, a:skipcc)
		      endfunction
		    else
		      function s:strchars(str, skipcc)
			if a:skipcc
			  return strlen(substitute(a:str, ".", "x", "g"))
			else
			  return strchars(a:str)
			endif
		      endfunction
		    endif
<
strcharpart({src}, {start}[, {len}])			*strcharpart()*
		和 |strpart()| 類似，但用字元索引和長度而不是位元組索引和長度。
		使用字元索引時如果字元不存在，假定有一個字元存在。例如: >
			strcharpart('abc', -1, 2)
<		返回 'a'。

strdisplaywidth({expr}[, {col}])			*strdisplaywidth()*
		返回數值，給出字串 {expr} 在 {col} 開始時在螢幕上佔據的顯示
		單元的數目。
		如果省略 {col}，假定為零。否則給出開始計算的螢幕列號。該值對包
		含製表符的計算有影響。
		使用當前視窗的選項設定。其中影響顯示的選項也對返回值有影響，如
		'tabstop' 和 'display'。
		{expr} 如包含東亞二義性寬度字元類，'ambiwidth' 也會影響返回結
		果。
		另見 |strlen()|、|strwidth()| 和 |strchars()|。

strftime({format} [, {time}])				*strftime()*
		返回字串，即經過 {format} 字串的格式轉換的日期和時間。使用
		給定的 {time}，如果沒有給出時間，使用當前時間。可以接受的
		{format} 取決於你的系統。這意味著該函式不是可移植的！
		可用的格式參見 C 函式 strftime() 的參考手冊。返回結果的最大長
		度是 80 個字元。另見 |localtime()| 和 |getftime()|。
		可以用 |:language| 命令改變語言。
		示例: >
		  :echo strftime("%c")		   Sun Apr 27 11:49:23 1997
		  :echo strftime("%Y %b %d %X")	   1997 Apr 27 11:53:25
		  :echo strftime("%y%m%d %T")	   970427 11:53:55
		  :echo strftime("%H:%M")	   11:55
		  :echo strftime("%c", getftime("file.c"))
						   顯示 file.c 的修改時間。
<		並非所有系統都可以用。要檢查這一點，用: >
			:if exists("*strftime")

strgetchar({str}, {index})				*strgetchar()*
		獲取 {str} 中的第 {index} 個字元。使用字元索引而不是位元組索引。
		這裡，組合用字元當作單獨的字元。
		另見 |strcharpart()| 和 |strchars()|。

stridx({haystack}, {needle} [, {start}])		*stridx()*
		返回數值，給出字串 {haystack} 裡第一個字串 {needle} 出現的
		位元組位置。
		如果給出 {start}，搜尋從 {start} 位置開始。可用來尋找第二個匹
		配: >
			:let colon1 = stridx(line, ":")
			:let colon2 = stridx(line, ":", colon1 + 1)
<		搜尋對大小寫敏感。
		模式搜尋可用 |match()|。
		如果 {needle} 不出現在 {haystack} 裡，返回 -1。
		另見 |strridx()|。示例: >
		  :echo stridx("An Example", "Example")	     3
		  :echo stridx("Starting point", "Start")    0
		  :echo stridx("Starting point", "start")   -1
<						*strstr()* *strchr()*
		stridx() 和 C 函式 strstr() 類似。如果使用單個字元，和
		strchr() 類似。

							*string()*
string({expr})	返回 {expr} 轉換後的字串。如果 {expr} 為數值、浮點數、字串
		或它們的複合形式，那麼用 |eval()| 可以把結果轉回去。
			{expr} 型別	返回值 ~
			字串		'string' (單引號加倍)
			數值		123
			浮點數		123.123456 或 1.23456e8
			函式引用	function('name')
			列表		[item, item]
			字典		{key: value, key: value}

		列表或字典中如有遞迴引用，被替換為 "[...]" 或 "{...}"。在此結
		果上執行 eval() 會出錯。

		另見 |strtrans()|。

							*strlen()*
strlen({expr})	返回數值，即字串 {expr} 的位元組長度。
		如果引數為數值，先把它轉化為字串。其它型別報錯。
		要計算多位元組字元的數目，可用 |strchars()|。
		另見 |len()|、|strdisplaywidth()| 和 |strwidth()|。

strpart({src}, {start}[, {len}])			*strpart()*
		返回字串，{src} 從第 {start} 個位元組開始位元組長度為 {len} 的子
		串。
		要以字元而不是位元組計算，用 |strcharpart()|。

		如果選擇不存在的位元組，不會產生錯誤。只是那些位元組被忽略而已。
		如果沒有提供 {len}，子串從 {start} 開始直到 {src} 的結尾。 >
			strpart("abcdefg", 3, 2)    == "de"
			strpart("abcdefg", -2, 4)   == "ab"
			strpart("abcdefg", 5, 4)    == "fg"
			strpart("abcdefg", 3)       == "defg"

<		注意: 要得到第一個字元，{start} 必須是零。比如，要得到游標開始
		的三個位元組: >
			strpart(getline("."), col(".") - 1, 3)
<
strridx({haystack}, {needle} [, {start}])			*strridx()*
		返回數值，給出字串 {haystack} 裡最後一個字串 {needle} 出現
		的位元組位置。
		如果給出 {start}，此位置之外的匹配被忽略。可用來尋找上次匹配之
		前的匹配: >
			:let lastcomma = strridx(line, ",")
			:let comma2 = strridx(line, ",", lastcomma - 1)
<		搜尋對大小寫敏感。
		模式搜尋可用 |match()|。
		如果 {needle} 不出現在 {haystack} 裡，返回 -1。
		如果 {needle} 為空，返回 {haystack} 的長度。
		另見 |stridx()|。示例: >
		  :echo strridx("an angry armadillo", "an")	     3
<							*strrchr()*
		如果使用單個字元，和 C 函式 strrchr() 類似。

strtrans({expr})					*strtrans()*
		返回等於 {expr} 的字串，但所有的不可顯示字元被翻譯成可顯示的
		字元序列 |'isprint'|，類似於窗口裡顯示的形式。例如: >
			echo strtrans(@a)
<		會顯示暫存器裡的換行符為 "^@" 而不是開啟新行。

strwidth({expr})					*strwidth()*
		返回數值，給出字串 {expr} 在螢幕上佔據的顯示單元的數目。製表
		符算作一個單元。如果不想這樣，可用 |strdisplaywidth()|。
		{expr} 如包含東亞二義性寬度字元類，'ambiwidth' 也會影響返回結
		果。
		另見 |strlen()|、|strdisplaywidth()| 和 |strchars()|。

submatch({nr}[, {list}])			*submatch()* *E935*
		只用於 |:substitute| 命令或 substitute() 函式中的表示式內。
		返回匹配文字的第 {nr} 個子匹配。{nr} 為 0 則返回整個匹配的文
		本。
		注意 字串中的 NL 既可以代表多行匹配的行尾，也可以是檔案中的
		NUL 字元。
		另見 |sub-replace-expression|。

		如果給出 {list} 且非零，submatch() 返回字串的列表，和帶兩個
		引數的 |getline()| 類似。文字中的 NL 代表檔案中的 NUL 字元。
		只在 |:substitute| 中可能返回多於一個專案，|substitute()| 中此
		列表總是包含一個或零個專案，因為沒有真正的行尾。

		遞迴使用 substitute() 時，只能得到當前 (最深的) 呼叫的子匹配。

		例如: >
			:s/\d\+/\=submatch(0) + 1/
<		找到行內第一個數值並加 1。
		使用 <NL> 可以包含換行符。

substitute({expr}, {pat}, {sub}, {flags})		*substitute()*
		返回相當於 {expr} 的字串，但其中 {pat} 的首個匹配被替代成
		{sub}。
		如果 {flags} 為 "g"，替換 {expr} 裡的所有 {pat} 匹配。否則，
		{flags} 應該為 ""。

		和 ":substitute" 命令 (不帶任何標誌位) 類似。但此處 {pat} 的匹
		配總假定 'magic' 選項已置位且 'cpoptions' 為空 (為了指令碼的可移
		植性)。
		'ignorecase' 仍然適用，|/\c| 或 |/\C| 可用來直接指定是否忽略或
		匹配大小寫並忽略 'ignorecase' 的設定。
		'smartcase' 此處不適用。
		|string-match| 說明如何使用 {pat}。

		{sub} 裡的 '~' 不會被換成前一個 {sub}。
		注意 {sub} 裡的一些程式碼有特殊含義 |sub-replace-special|。比
		如，要替換若干文字為 "\n" (兩個字元)，要用 "\\\\n" 或 '\\n'。

		如果 {pat} 在 {expr} 裡不能匹配，返回沒有修改的 {expr}。

		示例: >
		   :let &path = substitute(&path, ",\\=[^,]*$", "", "")
<		刪除 'path' 選項的最後一部分。 >
		   :echo substitute("testing", ".*", "\\U\\0", "")
<		返回 "TESTING"。

		{sub} 引數以 \= 開始時，其餘部分視為一個表示式，見
		|sub-replace-expression|。示例: >
		   :echo substitute(s, '%\(\x\x\)',
			   \ '\=nr2char("0x" . submatch(1))', 'g')

<		{sub} 若是函式引用，呼叫該函式，帶一個可選引數。示例: >
		   :echo substitute(s, '%\(\x\x\)', SubNr, 'g')
<		可選引數是包含完整匹配及多達九個子匹配的列表，就象
		|submatch()| 的返回值那樣。示例: >
		   :echo substitute(s, '%\(\x\x\)', {m -> '0x' . m[1]}, 'g')

synID({lnum}, {col}, {trans})				*synID()*
		返回數值，即當前視窗 {lnum} 行 {col} 列所在的語法 ID。
		語法 ID  可以用在 |synIDattr()| 和 |synIDtrans()|，以得到文字
		的語法資訊。

		最左列的 {col} 為 1。第一行的 {lnum} 為 1。適用 'synmaxcol' 的
		值，如果行比它更長，就返回零。
		注意 位置在最後一個字元之後是插入模式下可能的游標位置。此時，
		synID() 返回零。

		如果 {trans} 為 |TRUE|，透明的專案被簡約為它們實際顯露的專案。
		這可以用於你想知道實際使用的顏色的情形。如果 {trans} 為
		|FALSE|，返回透明的專案本身。這可用於想知道實際有效的語法專案
		的情形 (比如，在括號內部)。
		警告: 本函式可能很慢。最佳速度可以通過正向遍歷檔案獲得。

		例如 (回顯游標所在的語法專案的名字): >
			:echo synIDattr(synID(line("."), col("."), 1), "name")
<

synIDattr({synID}, {what} [, {mode}])			*synIDattr()*
		返回字串，syntax ID {synID} 的 {what} 屬性。可用於得到語法項
		目的相關資訊。
		{mode} 可以是 "gui"、"cterm" 或 "term"，從而得到的是該模式下的
		屬性。如果忽略 {mode} 或者指定了非法的值，使用當前啟用的高亮方
		式的屬性 (GUI、cterm 或 term)。
		使用 synIDtrans() 來跟隨連結的高亮組。
		{what}		結果 ~
		"name"		語法專案的名字
		"fg"		前景色 (GUI: 用於設定顏色的色彩名，cterm: 色彩
				號，以字串形式出現，term: 空字串)
		"bg"		背景色 (細節同 "fg")
		"font"		字型名 (只適用於 GUI) |highlight-font|
		"sp"		特殊顏色 (細節同 "fg") |highlight-guisp|
		"fg#"		類似於 "fg"，但只適用於 GUI，而且 GUI 使用的名
				字形如 "#RRGGBB"。
		"bg#"		"bg"，細節同 "fg#"
		"sp#"		"sp"，細節同 "fg#"
		"bold"		"1" 如果粗體
		"italic"	"1" 如果斜體
		"reverse"	"1" 如果反顯
		"inverse"	"1" 如果反顯 (= reverse)
		"standout"	"1" 如果突出
		"underline"	"1" 如果下劃線
		"undercurl"	"1" 如果下曲線

		示例 (回顯游標所在的語法專案的顏色): >
	:echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")
<
synIDtrans({synID})					*synIDtrans()*
		返回數值，即 {synID} 經過翻譯的語法 ID。這是用於高亮字元的語法
		組的 ID。":highlight link" 給出的高亮組被跟隨，以找到實際使用
		的組。

synconcealed({lnum}, {col})				*synconcealed()*
		返回列表，目前包含三個值:
		1. 如果 {lnum} 和 {col} 所在位置的字元不在可隱藏區域，列表的第
		   一個專案為 0，否則為 1。
		2. 列表的第二個專案為字串。如果第一個值為 1，第二個值包含代
		   替被隱藏文字實際顯示的文字，視乎 'conceallevel' 和
		   'listchars' 的當前值而定。
		3. 列表的第三個，也即最後一個專案是代表匹配的特定語法區域的唯
		   一的數值。這用於在有兩個連續的使用相同替代字元的區域時，檢
		   測此處是否是一個新的可隱藏區域的開始。例如，如果文字是
		   "123456"，"23" 和 "45" 都被隱藏，而替代字元是 "X"，則:
			call			returns ~
		   	synconcealed(lnum, 1)   [0, '', 0]
		   	synconcealed(lnum, 2)   [1, 'X', 1]
		   	synconcealed(lnum, 3)   [1, 'X', 1]
		   	synconcealed(lnum, 4)   [1, 'X', 2]
		   	synconcealed(lnum, 5)   [1, 'X', 2]
		   	synconcealed(lnum, 6)   [0, '', 0]


synstack({lnum}, {col})					*synstack()*
		返回 |List|，即當前視窗在 {lnum} 行 {col} 列語法專案的堆疊。列
		表的每個專案是像 |synID()| 返回那樣的 ID。
		列表的第一個專案是最外層區域，其後依次是包含在內的專案。末項即
		|synID()| 返回的專案，除非不是整個專案都被高亮，或者它是一個透
		明專案。
		此函式可用於除錯語法檔案。
		顯示游標所在的語法專案棧的示例: >
			for id in synstack(line("."), col("."))
			   echo synIDattr(id, "name")
			endfor
<		如果 {lnum} 和 {col} 指定的位置非法，不返回任何值。行末字元之
		後的位置以及空行的第一個位置是合法的位置。

system({expr} [, {input}])				*system()* *E677*
		得到外殼命令 {expr} 字串形式的輸出結果。要得到列表形式的輸出
		結果，見 |systemlist()|。

		如果給出 {input} 且為字串，該字串被寫到檔案裡，並傳給外殼
		命令作為標準輸入。字串照原樣寫入，你需要自己注意使用合適的換
		行符。
		如果給出 {input} 且為 |List|，它被寫到檔案裡，就象
		|writefile()| 帶 {binary} 設為 "b" 的工作方式那樣 (即，列表項
		目間寫入換行符，列表專案內部的換行符改寫為 NUL)。
		如果給出 {input} 且為數值，代表已存在的緩衝區的合法緩衝區號，
		逐行將該緩衝區的內容寫入檔案，每行以 NL 結尾，文字內的 NL 以
		NUL 字元代替。

		不使用管道，也不使用 'shelltemp' 選項。

		如果加上字首 |:silent|，終端不設為加工 (cooked) 模式。這用於不
		需要使用者輸入的命令，以避免螢幕上顯示多餘的字元而需要用
		|CTRL-L| 來清除。 >
			:silent let f = system('ls *.vim')
<
		注意: |shellescape()| 或 |expand()| 的 |::S| 或
		|fnamemodify()| 可以轉義命令引數裡的特殊字元。{expr} 裡的換行
		可能會使命令失敗。'shellquote' 和 'shellxquote' 裡的字元也可能
		會引起麻煩。
		這不是用來執行互動命令的。

		返回字串。示例: >
		    :let files = system("ls " .  shellescape(expand('%:h')))
		    :let files = system('ls ' . expand('%:h:S'))

<		要使結果更獨立於所用的系統，外殼輸出的結果被過濾，Macintosh 的
		<CR> 被換成 <NL>，而 DOS 系列的系統上 <CR><NL> 也被換成 <NL>。
		為了避免字串在 NUL 處被截斷，所有的 NUL 的字元被替換為 SOH
		(0x01)。

		使用若干選項，以下面的方法構造要執行的命令:
	'shell' 'shellcmdflag' 'shellxquote' {expr} 'shellredir' {tmp} 'shellxquote'
		({tmp} 是自動生成的一個檔名)。
		Unix 和 OS/2 上，{expr} 用大括號包圍，以便支援連線的多條命令。

		以加工 ("cooked") 模式執行命令，這樣 CTRL-C 可以用來中止命令
		(至少在 Unix 上是如此)。

		返回的錯誤程式碼可以在 |v:shell_error| 裡找到。
		該函式不能運行於 |restricted-mode|。

		注意 上面提到的選項值如有錯誤，該函式就會失敗。使用若干安全代
		理應用時也有報告說它會失敗。
		不同於 ":!cmd"，沒有自動對改變過的檔案的檢查。使用
		|:checktime| 來強制這種檢查。


systemlist({expr} [, {input}])				*systemlist()*
		和 |system()| 相同，但返回由行組成的 |List| (以 NL 分隔的輸出
		各部分)，NUL 轉換為 NL。輸出的工作方式和 |readfile()| 帶
		{binary} 引數設為 "b" 相同。注意 MS-Windows 上可能會有拖尾的
		CR 字元。

		有錯時，返回空串。


tabpagebuflist([{arg}])					*tabpagebuflist()*
		返回 |List|，每個專案是當前標籤頁裡每個視窗相關聯的緩衝區的編
		號。
		{arg} 指定使用的標籤頁的編號。如果省略，使用當前標籤頁。
		如果 {arg} 非法，返回數值零。
		要得到所有標籤頁裡的所有緩衝區的列表，這樣用: >
			let buflist = []
			for i in range(tabpagenr('$'))
			   call extend(buflist, tabpagebuflist(i + 1))
			endfor
<		注意 緩衝區可能出現於多於一個窗口裡。


tabpagenr([{arg}])					*tabpagenr()*
		返回數值，當前標籤頁號。第一個標籤頁的編號為 1。
		如果可選引數為 "$"，返回最後一個標籤頁的編號 (即標籤頁總數)。
		該數值可用於 |:tab| 命令。


tabpagewinnr({tabarg} [, {arg}])			*tabpagewinnr()*
		類似於 |winnr()|，但使用標籤頁 {tabarg}。
		{tabarg} 指定要使用的標籤頁號。
		{arg} 的用法類似於 |winnr()|:
		- 如果省略，返回當前視窗號，也就是轉到該標籤頁時會使用的視窗。
		- 如果是 "$"，返回視窗的總數。
		- 如果是 "#"，返回上次的視窗編號。
		用於的例子: >
		    tabpagewinnr(1)	    " 標籤頁 1 的當前視窗
		    tabpagewinnr(4, '$')    " 標籤頁 4 的視窗總數
<		如果 {tabarg} 非法，返回零。

							*tagfiles()*
tagfiles()	返回 |List|，當前緩衝區用於搜尋的標籤檔名。這是 'tags' 選項
		擴充套件後的內容。


taglist({expr}[, {filename}])				*taglist()*
		返回匹配正規表示式 {expr} 的標籤列表。

		如果傳入 {filename}，用於象 |:tselect| 那樣給結果排序。見
		|tag-priority|。{filename} 必須是檔案的完整路徑。

		每個列表專案是一個至少包含以下專案的字典:
			name		標籤名。
			filename	標籤定義的檔名。它或者相對於當前目
					錄，或者包含完整路徑。
			cmd		用於在檔案裡定位標籤的 Ex 命令。
			kind		標籤型別。該專案的值取決於特定於語言的
					型別值。只在 Exuberant ctags 或 hdrtag
					生成的標籤檔案裡存在。
			static		特定於檔案的標籤。詳見 |static-tag|。
		可能還有一些其它專案，取決於標籤檔案的內容: access、
		implementation、inherits 和 signature。這些欄位的資訊參見
		ctags 文件。C 程式碼裡可能出現欄位 "struct"、"class" 和 "enum"，
		它們給出標籤所在的實體的名字。

		ex 命令 "cmd" 可以是 ex 搜尋模式、行號或者行號後跟位元組位置。

		如果沒有匹配的標籤，返回空列表。

		要得到標籤的準確匹配，{expr} 裡必須使用 '^' 和 '$'。這也可加快
		函式的工作速度。
		關於標籤搜尋正規表示式模式的詳情見 |tag-regexp|。

		|'tags'| 提供 Vim 如何定位標籤檔案的資訊。|tags-file-format|
		說明不同的 ctags 工具生成的標籤檔案的格式。

tan({expr})						*tan()*
		返回以弧度測量的 {expr} 的正切值。返回值是 [-inf, inf] 區間內
		的浮點數。
		{expr} 的計算結果必須是浮點數或數值。
		示例: >
			:echo tan(10)
<			0.648361 >
			:echo tan(-4.01)
<			-1.181502
		{僅當編譯時加入 |+float| 特性才有效}

tanh({expr})						*tanh()*
		返回 {expr} 的雙曲正切值，返回值為 [-1, 1] 區間內的浮點數。
		{expr} 的計算結果必須是浮點數或數值。
		示例: >
			:echo tanh(0.5)
<			0.462117 >
			:echo tanh(-1)
<			-0.761594
		{僅當編譯時加入 |+float| 特性才有效}

tempname()					*tempname()* *temp-file-name*
		返回字串，它是一個不存在的檔名。可以用作臨時檔案。該檔案在
		至少 26 個接連的呼叫內不會重複。例如: >
			:let tmpfile = tempname()
			:exe "redir > " . tmpfile
<		Unix 上，檔案會在使用者個人的目錄中 |tempfile|。
		MS-Windows 上，如果置位了 'shellslash' 選項或者 'shellcmdflag'
		以 '-' 開始的時候，使用正斜槓。

test_alloc_fail({id}, {countdown}, {repeat})		*test_alloc_fail()*
		用於測試: 如果呼叫了 {id} 指定的記憶體分配，{countdown} 減一，到
		零時，讓記憶體分配失敗 {repeat} 次。如果 {repeat} 小於一，失敗一
		次。

test_autochdir()					*test_autochdir()*
		設定標誌位，在 Vim 啟動過程結束之前，開啟 'autochdir' 的效果。

test_garbagecollect_now()			 *test_garbagecollect_now()*
		類似於 garbagecollect()，但立即執行。只能通過直接呼叫，以避免
		內部儲存任何結構，而呼叫任何函式前，|v:testing| 必須置位。

test_ignore_error({expr})			 *test_ignore_error()*
		忽略包含 {expr} 的任何錯誤。顯示正常的訊息來替代。
		只用於測試，因為那裡 try/catch 不能用於捕捉錯誤 (因為跳過了下
		面的程式碼)。
		{expr} 按本義使用，不用作模式。
		目前沒有方法可以反轉此行為。

test_null_channel()					*test_null_channel()*
		返回 null 通道。僅用於測試。
		{僅當編譯時加入 |+channel| 特性才有效}

test_null_dict()					*test_null_dict()*
		返回 null 字典。僅用於測試。

test_null_job()						*test_null_job()*
		返回 null 作業。僅用於測試。
		{僅當編譯時加入 |+job| 特性才有效}

test_null_list()					*test_null_list()*
		返回 null 列表。僅用於測試。

test_null_partial()					*test_null_partial()*
		返回 null 偏函式。僅用於測試。

test_null_string()					*test_null_string()*
		返回 null 字串。僅用於測試。

test_override({name}, {val})				*test_override()*
		覆蓋 Vim 內部處理的部分行為，用於執行測試。只能用於 Vim 測試！
		如果 {val} 非零，開啟覆蓋行為，{val} 為零時，關閉覆蓋行為。
		目前支援的名字是:

		名字	     {val} 非零的效果 ~
		redraw       遮蔽 redrawing() 函式
		char_avail   遮蔽 char_avail() 函式
		starting     復位 "starting" 變數，見下
		ALL	     復位所有覆蓋 (不使用 {val})

		"starting" 用於假定初始化已經完成的測試。因為測試的執行是通過
		執行一個 "starting" 變數為非零的指令碼進行的。這通常有好處 (測試
		更快)，但有時會改變行為，使測試不能正常工作。
		以下操作: >
			call test_override('starting', 1)
< 		儲存 "starting" 的值。以下操作恢復這: >
			call test_override('starting', 0)

test_settime({expr})					*test_settime()*
		設定 Vim 內部使用的時間。目前只用於歷史中的時間戳，用於
		viminfo 和撤銷。
		值為 1 使 Vim 在警告或資訊後不睡眠。
		{expr} 計算結果必須為數值。值為零時恢復正常行為。

							*timer_info()*
timer_info([{id}])
		返回定時器資訊的列表。
		給出 {id} 時只返回此定時器的資訊。如果定時器 {id} 不存在，返回
		空列表。
		省略 {id} 時，返回所有定時器的資訊。

		每個定時器的資訊以字典形式儲存，有以下專案:
		    "id"	    定時器號
		    "time"	    定時器開始時間
		    "remaining"	    定時器剩餘時間
		    "repeat"	    定時器啟用的次數；-1 代表永遠
		    "callback"	    回撥
		    "paused"	    如果定時器暫停為 1，否則為 0

		{僅當編譯時加入 |+timers| 特性才有效}

timer_pause({timer}, {paused})				*timer_pause()*
		暫停或恢復定時器。暫停的定時器在到期是不呼叫回撥。如果經過足夠
		時間，恢復定時器會使回撥幾乎被立即呼叫。

		暫停定時器可用於短期停止回撥的呼叫。

		如果 {paused} 計算為非零的數值或非空的字串，暫停定時器，否則
		恢復定時器。
		見 |non-zero-arg|。

		{僅當編譯時加入 |+timers| 特性才有效}

						*timer_start()* *timer* *timers*
timer_start({time}, {callback} [, {options}])
		新建定時器並返回定時器號。

		{time} 是毫秒計的等待時間。只是呼叫回回調的最短時間。系統如果
		繁忙或 Vim 不在等待輸入時，時間會更長。

		{callback} 是要呼叫的函式。可以是函式名或 |Funcref|。呼叫時接
		受一個引數，即定時器號。只有在 Vim 等待輸入時才會呼叫回撥。

		{options} 是字典。支援的專案:
		   "repeat"	重複呼叫回撥的次數。-1 代表永遠。無定義時，調
		   		用回撥一次。

		示例: >
			func MyHandler(timer)
			  echo 'Handler called'
			endfunc
			let timer = timer_start(500, 'MyHandler',
				\ {'repeat': 3})
<		這會以 500 毫秒間隔呼叫 MyHandle() 三次。

		{僅當編譯時加入 |+timers| 特性才有效}

timer_stop({timer})					*timer_stop()*
		停止定時器。不再呼叫定時器回撥。
		{timer} 是 timer_start() 返回的定時器號，所以必須是數值。如果
		{timer} 不存在，不報錯。

		{僅當編譯時加入 |+timers| 特性才有效}

timer_stopall()						*timer_stopall()*
		停止所有定時器。不再呼叫定時器回撥。用於部分定時器工作不正常的
		場合。如果沒有任何定時器，不報錯。

		{僅當編譯時加入 |+timers| 特性才有效}

tolower({expr})						*tolower()*
		返回給出字串的備份，但所有的大寫字元變為小寫 (就如同在字串
		上應用了 |gu| 一樣)。

toupper({expr})						*toupper()*
		返回給出字串的備份，但所有的小寫字元變為大寫 (就如同在字串
		上應用了 |gU| 一樣)。

tr({src}, {fromstr}, {tostr})				*tr()*
		返回 {src} 字串的備份，其中 {fromstr} 裡的每個字元被 {tostr}
		字串裡同樣的位置的字元替代。也就是，{fromstr} 的第一個字元被
		翻譯成 {tostr} 的第一個字元，依此類推。和 unix 命令 "tr" 完全
		相同。
		能正確處理多位元組字元。

		例如: >
			echo tr("hello there", "ht", "HT")
<		返回 "Hello THere" >
			echo tr("<blob>", "<>", "{}")
<		返回 "{blob}"

trunc({expr})							*trunc()*
		返回浮點數，即絕對值小於等於 {expr} 的最大整數 (向零取整)。
		{expr} 的計算結果必須是浮點數或數值。
		示例: >
			echo trunc(1.456)
<			1.0  >
			echo trunc(-5.456)
<			-5.0  >
			echo trunc(4.0)
<			4.0
		{僅當編譯時加入 |+float| 特性才有效}

							*type()*
type({expr})	返回數值，代表 {expr} 的型別。
		不要直接使用此值，最好用含有此值的 v:t_ 變數:
			數值:	    0  |v:t_number|
			字串:	    1  |v:t_string|
			函式引用:   2  |v:t_func|
			列表:	    3  |v:t_list|
			字典:	    4  |v:t_dict|
			浮點數:	    5  |v:t_float|
			布林值:	    6  |v:t_bool| (v:false 和 v:true)
			None	    7  |v:t_none| (v:null 和 v:none)
			作業	    8  |v:t_job|
			通道	    9  |v:t_channel|
		為了後向相容，可以這樣用此函式: >
			:if type(myvar) == type(0)
			:if type(myvar) == type("")
			:if type(myvar) == type(function("tr"))
			:if type(myvar) == type([])
			:if type(myvar) == type({})
			:if type(myvar) == type(0.0)
			:if type(myvar) == type(v:false)
			:if type(myvar) == type(v:none)
<		要檢查 v:t_ 這些變數是否存在，可用: >
			:if exists('v:t_number')

undofile({name})					*undofile()*
		返回用於名為 {name} 的檔案的撤銷檔名。使用 'undodir' 選項並
		尋找實際存在的目錄。並不檢查該撤銷檔案是否存在。
		{name} 總是擴充套件為完整路徑，因為內部是這麼使用的。
		{name} 為空時 undofile() 也返回空字串，因為無名緩衝區不寫入
		任何撤銷檔案。
		可用於 |:wundo| 和 |:rundo|。
		如果編譯時沒有 +persistent_undo 選項，總是返回空字串。

undotree()						*undotree()*
		返回撤銷樹的當前狀態。返回值是包含以下專案的字典:
		  "seq_last"	最大使用的撤銷序列號。
		  "seq_cur"	撤銷樹中當前位置的序列號。如果有撤銷過的改變，
				和 "seq_last" 會有不同。
		  "time_cur"	最近用於 |:earlier| 和相關命令的時間。
				可用 |strftime()| 轉換成可讀的格式。
		  "save_last"	最後的檔案寫入編號。如果沒有寫入，返回零。
		  "save_cur"	撤銷樹當前位置的編號。
		  "synced"	如果最後的撤銷塊已經同步，返回非零值。等待使用者
				輸入時會發生。見 |undo-blocks|。
		  "entries"	關於撤銷塊的資訊的字典的列表。

		"entries" 列表的第一個值是最老的撤銷專案。每個列表專案是一個包
		含以下專案的字典:
		  "seq"		撤銷序列號。和 |:undolist| 顯示的相同。
		  "time"	改變發生的時間。可用 |strftime()| 轉換成可讀的
				格式。
		  "newhead"	只出現在最後加入的專案。標識最後的改變，並指示
		  		將來的改變加入所在的位置。
		  "curhead"	只出現在最後撤銷的專案。表示撤銷樹當前的位置，
		  		該塊可用於 redo 命令。如果最後改變之後沒有撤銷
				動作，此專案不出現。
		  "save"	只出現在檔案寫入前最後的塊。該值為寫入計數。首
		  		次寫入的編號為 1，最後一次是上面提及的
				"save_last"。
		  "alt"		替代項。這又是一個撤銷塊的列表。每個專案又可以
		  		有 "alt" 專案。

uniq({list} [, {func} [, {dict}]])			*uniq()* *E882*
		原地刪除重複相鄰的 {list} 專案的第二個及之後的版本。返回
		{list} 。如果不想對列表進行修改，先建立一個備份: >
			:let newlist = uniq(copy(mylist))
<		預設比較函式使用每個專案的字串表示形式。關於 {func} 和
		{dict} 的使用可見 |sort()|。

values({dict})						*values()*
		返回 |List|，{dict} 的所有值。|List| 專案的順序不定。


virtcol({expr})						*virtcol()*
		要得到螢幕列的位置，用 |virtcol()|。
		注意 只能使用當前檔案的位置標記。

		返回數值，即 {expr} 給定的檔案位置的螢幕列號。也就是，該位置的
		字元佔據的最後一個螢幕位置，這裡假設螢幕有無限的寬度。如果該位
		置是一個 <Tab>，返回的數值是 <Tab> 佔據的最後一列。比如，如果
		<Tab> 在第 1 列，而 'ts' 設為 8 的話，返回 8。忽略 |conceal()|
		因素。
		關於位元組位置，見 |col()|。
		{expr} 用法見 |col()|。
		如果使用 'virtualedit'，{expr} 可以用 [lnum, col, off]，其中
		"off" 是字元位置開始計算的螢幕列。例如，製表中或最後一個字元之
		後的某個位置。"off" 若省略，則假定為零。
		如果在當前模式下使用了虛擬編輯，也可能返回行尾之後的位置。
		|'virtualedit'|
		可接受的位置是:
		    .	    游標位置
		    $	    游標行的行尾 (返回游標行顯示的字元數加 1)
		    'x	    位置標記 x 的位置 (如果該位置標記沒有設定，返回 0)
		    v       可視模式下: 可視區域的開始位置 (游標是結束位置)。
			    如果不在可視模式下，返回當前游標位置。和 |'<| 不同
			    的是，會被立即更新。
		注意 只能使用當前檔案的位置標記。
		示例: >
  virtcol(".")	   文字 "foo^Lbar"，游標在 "^L" 上，返回 5
  virtcol("$")	   文字 "foo^Lbar"，返回 9
  virtcol("'t")    文字 "    there"，'t 在 'h' 上，返回 6
<		第一列為 1。返回 0 代表錯誤。
		一個更高階的示例，顯示所有行的最大長度: >
		    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))


visualmode([expr])						*visualmode()*
		返回字串，它描述當前緩衝區最近使用的可視模式。一開始，它返回
		空字串，一旦使用了可視模式，返回 "v"、"V" 或 "<CTRL-V>" (單
		個 CTRL-V 字元)，分別代表面向字元、面向行、和麵向列塊的可視模
		式。
		例如: >
			:exe "normal " . visualmode()
<		進入和上次相同的可視模式。也可以用於在腳本里根據最近的可視模式
		採取不同的行動。
		如果當前正處於可視模式中，|mode()| 可得到具體的可視模式 (例如
		在 |:vmap| 中可用)。
		如果提供 [expr] 並且計算結果是非零數值或者是非空字串，那麼將
		清除可視模式，並返回舊的值。見 |non-zero-arg|。

wildmenumode()					*wildmenumode()*
		如果 wildmenu 開啟，返回 |TRUE|，否則返回 |FALSE|。參見
		'wildmenu' 和 'wildmode'。
		可用於在對映中方便地處理 'wildcharm' 選項。(只對 |mapmode-c|
		對映有意義)。

		例如要使 <c-j> 在 wildmode 中等價於 <down>，可用: >
    :cnoremap <expr> <C-j> wildmenumode() ? "\<Down>\<Tab>" : "\<c-j>"
<
		(備註，這需要 'wildcharm' 合適的設定配合)。


win_findbuf({bufnr})					*win_findbuf()*
		返回包含緩衝區 {bufnr} 的視窗的所有 |window-ID| 的列表。如果
		沒有這樣的視窗，返回空列表。

win_getid([{win} [, {tab}]])				*win_getid()*
		返回指定視窗的 |window-ID|。
		忽略 {win} 則使用當前視窗。
		給定 {win} 時，這是視窗號。頂部視窗的視窗號為 1。
		忽略 {tab} 則使用當前標籤頁，否則使用標籤頁 {tab}。首個標籤頁
		的標籤頁號為一。
		如果找不到這樣的視窗，返回零。

win_gotoid({expr})					*win_gotoid()*
		轉到 ID 為 {expr} 的視窗。可能會改變當前標籤頁。
		如果成功返回 1，如果找不到這樣的視窗，返回零。

win_id2tabwin({expr})					*win_id2tabwin()*
		返回包含 ID 為 {expr} 的視窗的標籤頁號和視窗號的列表: [tabnr,
		winnr]。
		如果找不到這樣的視窗，返回 [0, 0]。

win_id2win({expr})					*win_id2win()*
		返回 ID 為 {expr} 的視窗號。
		如果在當前標籤頁下找不到這樣的視窗，返回零。

							*winbufnr()*
winbufnr({nr})	返回數值，即視窗 {nr} 相關聯的緩衝區號。{nr} 可以是視窗號或
		|window-ID|。
		如果 {nr} 為零，返回當前視窗的緩衝區號。
		如果視窗 {nr} 不存在，返回 -1。
		示例: >
  :echo "當前視窗的檔案是 " . bufname(winbufnr(0))
<
							*wincol()*
wincol()	返回數值，視窗游標的虛擬列。亦即從視窗左側起算的螢幕列數。最左
		列為第一列。

winheight({nr})						*winheight()*
		返回數值，視窗 {nr} 的高度。
		{nr} 可以是視窗號或 |window-ID|。
		如果 {nr} 為零，返回當前視窗的高度。如果視窗 {nr} 不存在，返回
		-1。
		存在的視窗的高度至少為零。
		示例: >
  :echo "當前視窗有 " . winheight(0) . " 行。"
<
							*winline()*
winline()	返回數值，視窗游標所在的螢幕行，亦即，從視窗頂部起算的螢幕行
		數。第一行返回 1。
		如果游標移動，檔案的檢視會先更新，這可能會導致滾動。

							*winnr()*
winnr([{arg}])	返回數值，當前視窗的編號。最上面的視窗的編號為 1。
		如果可選的引數為 "$"，返回最後一個視窗的編號 (即視窗的總
		數)。 >
			let window_count = winnr('$')
<		如果可選的引數為 "#"，返回最近訪問的視窗號 (|CTRL-W_p| 到的地
		方)。如果沒有上次視窗或它在另一個標籤頁中，返回 0。
		該數值可以用於 |CTRL-W_w| 和 ":wincmd w" |:wincmd|。
		另見 |tabpagewinnr()| 和 |win_getid()|。

							*winrestcmd()*
winrestcmd()	返回 |:resize| 命令序列，該序列應該能夠恢復當前視窗的大小。只
		有在沒有視窗被開啟或關閉且當前視窗和標籤頁都沒有改變的時候才能
		正確工作。
		示例: >
			:let cmd = winrestcmd()
			:call MessWithWindowSizes()
			:exe cmd
<
							*winrestview()*
winrestview({dict})
		使用 |winsaveview()| 返回的 |Dictionary| 來恢復當前視窗的視
		圖。
		注意 {dict} 不需要包含所有的 |winsaveview()| 返回的值。如果不
		提供某值，則不恢復相應的設定。所以可以用: >
		    :call winrestview({'curswant': 4})
<
		它只會設定游標的 curswant 值 (垂直移動的游標想移動到的列) 到第
		5 列 (是的，第 5 列)，而其它設定保持不變。這可用於手動設定游標
		位置。

		如果你改變了其中的值，結果無法預測。如果視窗大小改變了，結果不
		會完全一樣。

							*winsaveview()*
winsaveview()	返回 |Dictionary|，包含當前視窗的資訊，這些資訊可用來恢復視
		圖。
		|winrestview()| 進行檢視的恢復。
		可用於定義在緩衝區裡跳轉後想恢復的原來檢視的對映。
		這裡不保存摺疊的資訊。用 'foldenable' 選項來暫時關閉摺疊功能，
		這樣在移動時摺疊就不會開啟。這可能有副作用。
		返回值包括:
			lnum		游標行號
			col		游標列號 (注意: 首列為零，和 getpos()
					不同)
			coladd		'virtualedit' 使用的游標列偏移
			curswant	垂直移動使用的列
			topline		視窗的第一行
			topfill		填充行，只用於 diff 模式
			leftcol		顯示的第一列
			skipcol		跳過的列數
		注意 這裡不儲存任何選項值。


winwidth({nr})						*winwidth()*
		返回數值，視窗 {nr} 的寬度。
		{nr} 可以是視窗號或 |window-ID|。
		如果 {nr} 為零，返回當前視窗的寬度。如果視窗 {nr} 不存在，返回
		-1。
		存在的視窗的寬度至少為零。
		示例: >
  :echo "當前視窗有 " . winwidth(0) . " 列。"
  :if winwidth(0) <= 50
  :  exe "normal 50\<C-W>|"
  :endif
<		要得到終端或螢幕大小，可見 'columns' 選項。


wordcount()						*wordcount()*
		返回字典，包含當前緩衝區的位元組/字元/單詞的統計。和 |g_CTRL-G|
		包含的資訊相同。
		返回值包括:
			bytes		緩衝區的位元組數
			chars		緩衝區的字元數
			words		緩衝區的單詞數
			cursor_bytes    游標前的位元組數 (不在可視模式下)
			cursor_chars    游標前的字元數 (不在可視模式下)
			cursor_words    游標前的單詞數 (不在可視模式下)
			visual_bytes    可視選擇的位元組數 (只在可視模式下)
			visual_chars    可視選擇的字元數 (只在可視模式下)
			visual_words    可視選擇的單詞數 (只在可視模式下)


							*writefile()*
writefile({list}, {fname} [, {flags}])
		把 |List| {list} 寫到檔案 {fname} 裡。列表的專案間以 NL 分隔。
		每個列表項必須是字串或數值。
		如果 {flags} 包含 "b"，使用二進位制模式: 最後一個列表專案之後沒
		有 NL，最後的空專案使得檔案的末行以 NL 結尾。

		如果 {flags} 包含 "a"，使用附加模式，寫入行附加到檔案之後: >
			:call writefile(["foo"], "event.log", "a")
			:call writefile(["bar"], "event.log", "a")
>
<		所有的 NL 字元被 NUL 字元代替。
		CR 字元的插入需要在把 {list} 傳遞給 writefile() 之前先做好。
		如果可能，覆蓋已有的檔案。
		如果寫入失敗，返回 -1，否則返回 0。如果檔案不能建立或者寫入失
		敗，會有錯誤資訊。
		另見 |readfile()|。
		要按位元組複製檔案: >
			:let fl = readfile("foo", "b")
			:call writefile(fl, "foocopy", "b")


xor({expr}, {expr})					*xor()*
		對兩個引數進行按位異或。引數須轉換為數值。列表、字典或浮點數參
		數會報錯。
		示例: >
			:let bits = xor(bits, 0x80)
<


							*feature-list*
有四種類型的特性:
1.  只有在 Vim 編譯時加入才會支援的特性 |+feature-list|。例如: >
	:if has("cindent")
2.  只有特定條件滿足才會支援的特性。例如: >
	:if has("gui_running")
<							*has-patch*
3.  包含的補丁。形如 "patch123" 的特性意味著包含了補丁 123 。注意此形式不檢查
    Vim 的版本，為此需要先檢查 |v:version| 確定。
    例如 (確定是 version 6.2.148 或更新的版本): >
	:if v:version > 602 || v:version == 602 && has("patch148")
<   注意 包含了補丁 148 但不包含補丁 147 是可能的。

4.  特定版本之後或在特定版本上幷包含了特定補丁。"patch-7.4.237" 特性意味著 Vim
    版本是 7.5 或之後，或 7.4 幷包含了補丁 237。
    注意 只可用於 7.4.237 補丁或之後版本，之前的版本必須用上面例子來檢查
    v:version。例如: >
	:if has("patch-7.4.248")
<   注意 包含了補丁 148 但不包含補丁 147 是可能的。

揭示: 要知道 Vim 是否支援檔名中的反斜槓 (MS-Windows)，
用: `if exists('+shellslash')`


acl			編譯時加入了 |ACL| 支援。
all_builtin_terms	編譯時打開了所有的內建終端。
amiga			Vim 的 Amiga 版本。
arabic			編譯時加入了阿拉伯語的支援。|Arabic|。
arp			編譯時加入了 ARP 的支援。(Amiga)。
autocmd			編譯時加入了自動命令的支援。|autocommand|
balloon_eval		編譯時加入了 |balloon-eval| 的支援。
balloon_multiline	GUI 支援多行氣泡。
beos			Vim 的 BeOS 版本。
browse			編譯時加入了 |:browse| 的支援。使 browse() 可以工作。
browsefilter		編譯時加入了 |browsefilter| 的支援。
builtin_terms		編譯時打開了一些內建終端。
byte_offset		編譯時加入了 'statusline' 中對 'o' 的支援。
cindent			編譯時加入了 'cindent' 的支援。
clientserver		編譯時加入了遠端呼叫的支援。|clientserver|。
clipboard		編譯時加入了 'clipboard' 的支援。
cmdline_compl		編譯時加入了 |cmdline-completion| 的支援。
cmdline_hist		編譯時加入了 |cmdline-history| 的支援。
cmdline_info		編譯時加入了 'showcmd' 和 'ruler' 的支援。
comments		編譯時加入了 |'comments'| 的支援。
compatible		編譯時確保和 Vi 非常相容。
cryptv			編譯時加入了加密的支援。|encryption|。
cscope			編譯時加入了 |cscope| 的支援。
debug			編譯時定義了 "DEBUG"。
dialog_con		編譯時加入了控制檯對話方塊的支援。
dialog_gui		編譯時加入了 GUI 對話方塊的支援。
diff			編譯時加入了 |vimdiff| 和 'diff' 的支援。
digraphs		編譯時加入了二合字母的支援。
directx			編譯時加入了 DirectX 和 'renderoptions' 的支援。
dnd			編譯時加入了 "~ 暫存器的支援 |quote_~|。
ebcdic			在使用 ebcdic 字符集的機器上編譯。
emacs_tags		編譯時加入了 Emcac 標籤的支援。
eval			編譯時加入了表示式計算的支援。當然總要開啟啦！
ex_extra		|+ex_extra|，現在總是為真。
extra_search		編譯時加入了 |'incsearch'| 和 |'hlsearch'| 的支援。
farsi			編譯時加入了波斯語的支援。|farsi|。
file_in_path		編譯時加入了 |gf| 和 |<cfile>| 的支援。
filterpipe		'shelltemp' 關閉時，外殼讀/寫/過濾命令使用管道
find_in_path		編譯時加入了標頭檔案搜尋 |+find_in_path| 的支援。
float			編譯時加入了 |Float| 的支援。
fname_case		檔名大小寫敏感 (在 Amiga、MS-DOS 和 Windows 本特性不
			存在)。
folding			編譯時加入了 |folding| 的支援。
footer			編譯時加入了 GUI 資訊頁尾的支援。|gui-footer|
fork			編譯時決定使用 fork()/exec() 而不是 system()。
gettext			編譯時加入了資訊翻譯 |multi-lang|。
gui			編譯時加入了 GUI 的支援。
gui_athena		編譯時加入了 Athena GUI。
gui_gnome		編譯時加入了 Gnome 支援 (同時也定義了 gui_gtk)。
gui_gtk			編譯時加入了 GTK+ GUI (任何版本)。
gui_gtk2		編譯時加入了 GTK+ 2 GUI (同時也定義了 gui_gtk)。
gui_gtk3		編譯時加入了 GTK+ 3 GUI (同時也定義了 gui_gtk)。
gui_mac			編譯時加入了 Macintosh GUI。
gui_motif		編譯時加入了 Motif GUI。
gui_photon		編譯時加入了 Photon GUI。
gui_running		Vim 在 GUI 上執行，或者 GUI 將很快啟動。
gui_win32		編譯時加入了 MS Windows Win32 GUI。
gui_win32s		同上，使用了 Win32s 系統 (Windows 3.1)
hangul_input		編譯時加入了韓語 (Hangul) 輸入的支援。|hangul|
iconv			可以使用 iconv() 進行轉換。
insert_expand		編譯時加入了插入模式中 CTRL-X 擴充套件命令的支援。
jumplist		編譯時加入了 |jumplist| 的支援。
keymap			編譯時加入了 'keymap' 的支援。
lambda			編譯時加入了 |lambda| 的支援。
langmap			編譯時加入了 'langmap' 的支援。
libcall			編譯時加入了 |libcall()| 的支援。
linebreak		編譯時加入了 'linebreak'、'breakat'、'showbreak' 和
			'breakindent' 的支援。
lispindent		編譯時加入了 lisp 縮排的支援。
listcmds		編譯時加入了緩衝區列表 |:files| 和引數列表 |arglist|
			的命令。
localmap		編譯時加入了局部對映和縮寫。|:map-local|
lua			編譯時加入了 Lua 介面 |Lua|。
mac			Vim 的 Macintosh 版本，但不是所有 OS X 版本。
macunix			為 OS X 編譯，帶有 |mac-darwin-feature|
osx			為 OS X 編譯，可帶或不帶有 |mac-darwin-feature|
menu			編譯時加入了 |:menu| 的支援。
mksession		編譯時加入了 |:mksession| 的支援。
modify_fname		編譯時加入了檔名的修飾符支援。|filename-modifiers|
mouse			編譯時加入了滑鼠的支援。
mouse_dec		編譯時加入了 Dec 終端的滑鼠支援。
mouse_gpm		編譯時加入了 gpm (Linux 控制檯滑鼠) 的支援。
mouse_netterm		編譯時加入了 netterm 的滑鼠支援。
mouse_pterm		編譯時加入了 qnx 的滑鼠支援。
mouse_sysmouse		編譯時加入了 sysmouse 支援 (*BSD 控制檯滑鼠)
mouse_sgr		編譯時加入了 sgr 的滑鼠支援。
mouse_urxvt		編譯時加入了 urxvt 的滑鼠支援。
mouse_xterm		編譯時加入了 xterm 的滑鼠支援。
mouseshape		編譯時加入了 'mouseshape' 的支援。
multi_byte		編譯時加入了 'encoding' 的支援。
multi_byte_encoding	'encoding' 設為某個多位元組的編碼。
multi_byte_ime		編譯時加入了 IME 輸入方法的支援。
multi_lang		編譯時加入了多語言的支援。
mzscheme		編譯時加入了 MzScheme 介面支援 |mzscheme|。
netbeans_enabled	編譯時加入了 |netbeans| 的支援並且已連線上。
netbeans_intg		編譯時加入了 |netbeans| 的支援。
num64			編譯時加入了64 位 |Number| 的支援。
ole			編譯時加入了 Win32 OLE automation 的支援。
packages		編譯時加入了 |packages| 的支援。
path_extra		編譯時加入了 'path' 和 'tags' 上下搜尋的支援。
perl			編譯時加入了 Perl 介面。
persistent_undo		編譯時加入了持久化撤銷歷史的支援。
postscript		編譯時加入了 PostScript 檔案列印的支援。
printer			編譯時加入了 |:hardcopy| 的支援。
profile			編譯時加入了 |:profile| 的支援。
python			編譯時加入了 Python 2.x 介面。|has-python|
python3			編譯時加入了 Python 3.x 介面。|has-python|
pythonx			編譯時加入了 |python_x| 介面。|has-pythonx|
qnx			Vim 的 QNX 版本。
quickfix		編譯時加入了 |quickfix| 的支援。
reltime			編譯時加入了 |reltime()| 的支援。
rightleft		編譯時加入了 'rightleft' 的支援。
ruby			編譯時加入了 Ruby 介面 |ruby|。
scrollbind		編譯時加入了 'scrollbind' 的支援。
showcmd			編譯時加入了 'showcmd' 的支援。
signs			編譯時加入了 |:sign| 的支援。
smartindent		編譯時加入了 'smartindent' 的支援。
spell			編譯時加入了拼寫檢查的支援 |spell|。
startuptime		編譯時加入了 |--startuptime| 支援。
statusline		編譯時加入了 'statusline' 和 'rulerformat' 還有
			'titlestring' 和 'iconstring' 的特殊格式的支援。
sun_workshop		編譯時加入了 Sun |workshop| 的支援。
syntax			編譯時加入了語法高亮的支援 |syntax|。
syntax_items		當前緩衝區有啟用的語法高亮專案。
system			編譯時決定使用 system() 而不是 fork()/exec()。
tag_binary		編譯時加入了標籤檔案的二分搜尋 |tag-binary-search|。
tag_old_static		編譯時加入了老的靜態標籤的支援。|tag-old-static|。
tag_any_white		編譯時加入了允許標籤檔案使用任何空白字元的支援。
			|tag-any-white|。
tcl			編譯時加入了 Tcl 介面。
termguicolors		編譯時加入了終端的真彩支援。
terminfo		編譯時決定使用 terminfo 而不是 termcap。
termresponse		編譯時加入了 |t_RV| 和 |v:termresponse| 的支援。
textobjects		編譯時加入了 |text-objects| 的支援。
tgetent			編譯時加入了 tgetent 的支援，可以使用外部 termcap 或
			terminfo 檔案。
timers			編譯時加入了 |timer_start()| 支援。
title			編譯時加入了視窗標題的支援。|'title'|。
toolbar			編譯時加入了 |gui-toolbar| 的支援。
ttyin			輸入是終端 (tty)
ttyout			輸出是終端 (tty)
unix			Vim 的 Unix 版本。
unnamedplus		編譯時加入了 'clipboard' 對 "unnamedplus" 的支援。
user_commands		使用者定義命令支援。
vertsplit		編譯時加入了垂直分割視窗的支援 |:vsplit|。
vim_starting		如果在啟動載入指令碼的階段則為真。|startup|
			*vim_starting*
viminfo			編譯時加入了 viminfo 的支援。
virtualedit		編譯時加入了 'virtualedit' 選項支援。
visual			編譯時加入了可視模式的支援。
visualextra		編譯時加入了附加的可視模式命令支援。
			|blockwise-operators|。
vms			Vim 的 VMS 版本。
vreplace		編譯時加入了 |gR| and |gr| 命令支援。
wildignore		編譯時加入了 'wildignore' 選項支援。
wildmenu		編譯時加入了 'wildmenu' 選項支援。
win32			Vim 的 Win32 版本。(MS-Windows 95 及其後的 32 或 64 位
			版本)。
win32unix		Vim 的 Win32 版本。使用 Unix 檔案命名 (Cygwin)
win64			Vim 的 Win64 版本。(MS-Windows 64 位)。
win95			支援 MS-Windows 95/98/ME 的 Win32 版本。
winaltkeys		編譯時加入了 'winaltkeys' 選項。
windows			編譯時加入了多視窗的支援。
writebackup		編譯時決定預設開啟 'writebackup'。
xfontset		編譯時加入了 X 字型集 的支援。|xfontset|。
xim			編譯時加入了 X 輸入法 的支援。|xim|。
xpm			編譯時加入了 pixmap 的支援。
xpm_w32			編譯時加入了 Win32 的 pixmap 的支援。(只為後向相容而
			保留，用 "xpm" 代替)
xsmp			編譯時加入了 X 會話管理 的支援。
xsmp_interact		編譯時加入了互動的 X 會話管理 的支援。
xterm_clipboard		編譯時加入了 xterm 剪貼簿的支援。
xterm_save		編譯時加入了儲存和恢復 xterm 螢幕的支援。
x11			編譯時加入了 X11 的支援。

							*string-match*
字串裡的模式匹配

|pattern| 說明的正規表示式通常用於尋找緩衝區行的匹配。如果匹配用來在字串裡尋
找匹配，幾乎所有的功能都相同。唯一的區別是，字串是作為單行處理的。如果字串
裡包含了 "\n" 字元，它並不看作是模式裡的換行。它可以匹配模式裡的 "\n"，甚至於
"."。示例: >
	:let a = "aaaa\nxxxx"
	:echo matchstr(a, "..\n..")
	aa
	xx
	:echo matchstr(a, "a.x")
	a
	x

不要忘記 "^" 只會在字串的第一個字元匹配，而 "$" 在字串的最後一個字元匹配。
它們不會匹配 "\n" 之後和之前的位置。

==============================================================================
5. 定義函式						*user-functions*

可以定義新的函式。呼叫的方式就像內建函式一樣。函式執行一系列 Ex 命令。普通模式
下的命令可以用 |:normal| 命令執行。

函式名須以大寫字母開始，以免和內建函式引起混淆。要避免在不同指令碼使用相同的名
字，避免顯見的或者過短的名字。一個好習慣是使用指令碼名字作為函式名字的開頭，比如
"HTMLcolor()"。

也可以使用花括號，見 |curly-braces-names|。|autoload| 機制可用於在呼叫時才提供
函式的定義。

							*local-function*
區域性於指令碼的函式必須以 "s:" 開始。區域性於指令碼的函式只能在同一指令碼和指令碼中定義的
函式、使用者命令和自動命令裡呼叫。也可以在指令碼定義的對映裡呼叫該函式，但必須使用
|<SID>| 而不是 "s:"，如果對映會在指令碼之外被擴充套件的話。
只有區域性於指令碼的函式，沒有區域性於緩衝區或區域性於視窗的函式。

					*:fu* *:function* *E128* *E129* *E123*
:fu[nction]		列出所有函式和它們的引數。

:fu[nction] {name}	列出 {name} 命名的函式。
			{name} 也可以是 |Funcref| 型別的 |Dictionary| 專案: >
				:function dict.init

:fu[nction] /{pattern}	列出名字匹配 {pattern} 的函式。
			列出所有以 "File" 結束的函式的例子: >
				:function /File$
<
							*:function-verbose*
如果 'verbose' 非零，列出函式的同時也顯示它上次定義的位置。例如: >

    :verbose function SetFileTypeSH
	function SetFileTypeSH(name)
	    Last set from /usr/share/vim/vim-7.0/filetype.vim
<
|:verbose-cmd| 有更多資訊。

						*E124* *E125* *E853* *E884*
:fu[nction][!] {name}([arguments]) [range] [abort] [dict] [closure]
			定義 {name} 命名的新函式。名字必須由字母數字和 '_' 字
			符組成，而且必須以大寫字母或者 "s:" 開頭 (見上)。注意
			"b:" 或 "g:" 是不允許的。(從補丁 7.4.260 開始，如果函
			數名中有冒號，給出 E884， 如 "foo:bar()"。此補丁之前不
			報錯)。

			{name} 也可以是 |Funcref| 型別的 |Dictionary| 專案: >
				:function dict.init(arg)
<			"dict" 必須是一個已經存在的字典。如果還不存在，專案
			"init" 被加入此字典。否則必須提供 [!] 以覆蓋已經存在的
			函式。返回指向一個編號函式的 |Funcref|。該函式只能通過
			|Funcref| 引用，沒有引用指向它時，該函式會被刪除。
								*E127* *E122*
			如果同名的函式已經存在而且沒有使用 [!]，給出錯誤資訊。
			如果給出 [!]，已有的函式被悄然替代。如果該函式正在執行
			期間除外。此時，這是一個錯誤。
			備註: 小心使用 !。如果不小心，可能會意外地替代已有的函
			數。這很難除錯。

			{arguments} 參見 |function-argument|。

					*:func-range* *a:firstline* *a:lastline*
			如果給出 [range] 引數，則該函式自己能理解並處理行範
			圍。該範圍通過 "a:firstline" 和 "a:lastline" 定義。如
			果沒有 [range]，":{range}call" 會在該範圍的每一行分別
			執行該函式，每次游標都定位在處理行的行首。見
			|function-range-example|。
			就像所有的 Ex 命令一樣，游標仍然會被移動到範圍的首行。
								*:func-abort*
			如果給出 [abort] 引數，該函式在遇到錯誤時立即中止。
								*:func-dict*
			如果給出 [dict] 引數，該函式必須通過 |Dictionary| 的項
			目才能呼叫。區域性變數 "self" 這時設為該字典。見
			|Dictionary-function|。
						*:func-closure* *E932*
			加入 [closure] 引數時，函式可以訪問外部作用域的變數和
			引數。通常這被稱為閉包。此例中 Bar() 使用 Foo() 作用
			域的 "x"。即使 Foo() 返回後仍被引用: >
				:function! Foo()
				:  let x = 0
				:  function! Bar() closure
				:    let x += 1
				:    return x
				:  endfunction
				:  return funcref('Bar')
				:endfunction

				:let F = Foo()
				:echo F()
<				1 >
				:echo F()
<				2 >
				:echo F()
<				3


						*function-search-undo*
			最近使用的搜尋模式和重做命令 "." 不會受到函式的影響。
			這也意味著 |:nohlsearch| 的效果在函式返回時會被撤銷。

				*:endf* *:endfunction* *E126* *E193* *W22*
:endf[unction]		結束函式定義。最好單起一行，沒有 [argument]。

			[argument] 可以是:
				| 命令		下面執行的命令
				\n 命令		下面執行的命令
				" 註釋		總是忽略
				其它 		忽略，如果 'verbose' 非零給出
						警告
			對後續命令的支援是 Vim 8.0.0654 加入的，之前任何引數都
			被悄悄地忽略。

			要在 `:execute` 命令裡定義函式，用換行符而不是
			|:bar|: >
				:exe "func Foo()\necho 'foo'\nendfunc"
<
				*:delf* *:delfunction* *E130* *E131* *E933*
:delf[unction][!] {name}
			刪除 {name} 命名的函式。
			{name} 也可以是 |Funcref| 型別的 |Dictionary| 專案: >
				:delfunc dict.init
<			會刪除 "dict" 的 "init" 專案。如果沒有更多指向它的引
			用，該函式被刪除。
			用了 ! 後，即使函式不存在也不報錯。
						*:retu* *:return* *E133*
:retu[rn] [expr]	從函式返回。如果給出 "[expr]"，計算該表示式的結果成為
			函式的返回值。如果沒有給出 "[expr]"，返回 0。
			如果函式退出時沒有顯式的呼叫 ":return"，返回 0。
			注意 沒有不可到達行的檢查，因而，如果有命令在
			":return" 之後，不會給出警告。

			如果 ":return" 在 |:try| 之後使用但在匹配的 |:finally|
			(如果有的話) 之前的話，":finally" 之後直到匹配的
			|:endtry| 的命令會先執行。該過程反覆應用於所有函式內的
			巢狀 ":try" 塊。在最外層 ":endtry" 結束之後才真正返
			回。


						*function-argument* *a:var*
引數的定義只要給出它的名字。在函式裡，可以使用 "a:name" 來訪問 ("a:" 代表引數
(argument))。
					*a:0* *a:1* *a:000* *E740* *...*
可以給出不超過 20 個引數，以逗號分隔。最後，可以給出引數 "..."，意味著可以有更
多的引數。在函式裡，可以通過 "a:1"、"a:2" 等等訪問它們。"a:0" 設為這些附加引數
的數目 (可以為 0)。"a:000" 設為包含這些引數的 |List|。注意 "a:1" 等同於
"a:000[0]"。
								*E742*
a: 作用域和其中的變數不能修改，它們是固定的。不過，如果使用了複合型別，例如
|List| 或 |Dictionary|，可以改變它們的內容。這樣就可以傳遞給函式一個 |List|，
讓該函式在裡面增加專案。如果要確保函式不能修改 |List| 或 |Dictionary|，用
|:lockvar|。

如果不使用 "..."，實際給出的引數數目必須等於命名引數的數目。如果使用 "..."，參
數的數目可以更多。

可以定義沒有引數的函式。但你這時仍然需要提供 ()。函式體在之後的行給出，直到匹
配的 |:endfunction| 為止。可以在函式體裡定義別的函式。

							*local-variables*
在函式裡，可以使用區域性變數。它們在函式返回時就會消失。全域性變數的訪問需要通過
"g:"。

例如: >
  :function Table(title, ...)
  :  echohl Title
  :  echo a:title
  :  echohl None
  :  echo a:0 . " items:"
  :  for s in a:000
  :    echon ' ' . s
  :  endfor
  :endfunction

該函式這時可以這樣呼叫: >
  call Table("Table", "line1", "line2")
  call Table("Empty Table")

要返回多於一個值，返回一個 |List|: >
  :function Compute(n1, n2)
  :  if a:n2 == 0
  :    return ["fail", 0]
  :  endif
  :  return ["ok", a:n1 / a:n2]
  :endfunction

該函式這時可以這樣呼叫: >
  :let [success, div] = Compute(102, 6)
  :if success == "ok"
  :  echo div
  :endif
<
						*:cal* *:call* *E107* *E117*
:[range]cal[l] {name}([arguments])
		呼叫函式。函式名和引數通過 |:function| 指定。可以使用不超過 20
		個引數。忽略返回值。
		如果沒有給出範圍而函式又接受範圍，該函式被呼叫一次。如果給出範
		圍，游標在執行函式前定位在該範圍的第一行的開始。
		如果給出範圍但函式自己不能處理之，該函式在範圍裡的每一行分別執
		行。游標定位在每個處理行的第一列。游標留在最後一行 (但可能被最
		後一個函式呼叫移動)。每一行上，引數被重新計算。所以這是可以的:
						*function-range-example*  >
	:function Mynumber(arg)
	:  echo line(".") . " " . a:arg
	:endfunction
	:1,5call Mynumber(getline("."))
<
		"a:firstline" 和 "a:lastline" 總是有定義的。它們可以用來在範圍
		的開始或結束處進行一些不同的處理。

		能處理範圍本身的函式示例: >

	:function Cont() range
	:  execute (a:firstline + 1) . "," . a:lastline . 's/^/\t\\ '
	:endfunction
	:4,8call Cont()
<
		該函式在範圍裡的每行開頭插入續行符 "\"，除了第一行以外。

		如果函式返回複合值，該值可被進一步解除參照 (譯者注: 呼叫其上的
		方法)，但該範圍不能被繼續使用。例如: >
	:4,8call GetDict().method()
<		這裡 GetDict() 得到範圍值，method() 不會。

								*E132*
使用者函式的遞迴呼叫受到 |'maxfuncdepth'| 選項的限制。


自 動 載 入 函 數 ~
							*autoload-functions*
如果使用很多或者很大的函式，可以在需要使用它們的時候才自動提供其定義。有兩個方
法: 用自動命令，還有用 'runtimepath' 裡的 "autoload" 目錄。


使用自動命令 ~

使用者手冊 |41.14| 一節有介紹。

自動命令可用於很長的 Vim 指令碼的外掛。你可以定義自動命令然後用 |:finish| 快速退
出指令碼。這使得 Vim 啟動快得多。這時，自動命令應該再次載入相同的檔案，並設定變
量使得 |:finish| 命令被跳過。

使用 FuncUndefined 自動命令事件，它需要一個能匹配等待定義的函式的模式。例如: >

	:au FuncUndefined BufNet* source ~/vim/bufnetfuncs.vim

檔案 "~/vim/bufnetfuncs.vim" 這時應該定義 "BufNet" 開始的函式。另見
|FuncUndefined|。


使用 autoload 指令碼 ~
							*autoload* *E746*
使用者手冊 |41.15| 一節有介紹。

在 "autoload" 目錄裡定義指令碼更簡單，但需要使用準確的檔名。能夠自動載入的函式
的名字形如: >

	:call filename#funcname()

這樣的函式如果呼叫時還沒有定義，Vim 在 'runtimepath' 裡的 "autoload" 目錄搜尋
指令碼檔案 "filename.vim"。例如 "~/.vim/autoload/filename.vim"。該檔案這時應該這
樣定義函式: >

	function filename#funcname()
	   echo "Done!"
	endfunction

檔名和函式的 # 之前的名字必須完全匹配，而定義的函式名也必須和呼叫時使用的形
式完全一致。

可以使用子目錄。函式名每個 # 相當於路徑分隔符。這樣，呼叫函式: >

	:call foo#bar#func()

的時候，Vim 尋找 'runtimepath' 裡的檔案 "autoload/foo/bar.vim"。

也適用於讀取還沒有設定的變數: >

	:let l = foo#bar#lvar

不過，如果 autoload 指令碼已經載入，不會為未知的變數再次載入該指令碼。

給這樣的變數賦值並沒有什麼特別。這可以用於在載入 autoload 指令碼之前給它傳遞一些
設定: >

	:let foo#bar#toggle = 1
	:call foo#bar#func()
<
注意 如果你不小心呼叫了應該在 autoload 腳本里定義，但該指令碼實際沒有定義的函式
時，每次試圖對該函式的呼叫都會重新載入一次指令碼。從而每次都會得到錯誤資訊。

還有，注意 如果你有兩個指令碼檔案，不能在使用的函式定義之前同時從一個檔案裡呼叫
另一個檔案裡的函式並且從那個檔案裡呼叫這個檔案的函式。
避免在頂層使用自動載入功能。

提示: 如果你釋出很多指令碼，可以用 |vimball| 工具把它們捆綁在一起。另請閱讀使用者
手冊 |distribute-script|。

==============================================================================
6. 花括號名字						*curly-braces-names*

多數使用變數的地方可以改用 "花括號名字" 變數。和常規的變數名類似，但可以包含一
到多個花括號 {} 包圍的表示式，形如: >
	my_{adjective}_variable

如果 Vim 遇到這種情形，它會計算花括號內的表示式，把結果放在表示式所在的位置，
然後重新解釋整個字串為完整的變數名。所以在上例中，如果變數 "adjective" 設為
"noisy"，那麼引用的將是 "my_noisy_variable"。如果 "adjective" 設為 "quiet"，那
麼引用的將是 "my_quiet_variable"。

一個這種形式的應用是建立一系列變數，由一個選項管理。比如，語句 >
	echo my_{&background}_message

會顯示 "my_dark_message" 或者 "my_light_message" 的內容，取決於 'background'
的當前值。

你可以使用多個花括號對: >
	echo my_{adverb}_{adjective}_message
..甚至巢狀使用: >
	echo my_{ad{end_of_word}}_message
其中 "end_of_word" 可以是 "verb" 或者 "jective"。

不過，花括號裡的表示式必須計算出合法的單個變數名，比如，這不行: >
	:let foo='a + b'
	:echo c{foo}d
.. 因為擴充套件的結果是 "ca + bd"，這不是合法的變數名。

						*curly-braces-function-names*
類似的，你可以呼叫和定義計算的出的函式名。比如: >
	:let func_end='whizz'
	:call my_func_{func_end}(parameter)

會呼叫函式 "my_func_whizz(parameter)"。

這樣_不_行: >
  :let i = 3
  :let @{i} = ''  " 報錯
  :echo @{i}      " 報錯

==============================================================================
7. 命令							*expression-commands*

:let {var-name} = {expr1}				*:let* *E18*
			設定內部變數 {var-name} 為表示式 {expr1} 的計算結果。
			該變數也會得到 {expr} 的型別。如果 {var-name} 不存在，
			它會被創立。

:let {var-name}[{idx}] = {expr1}			*E689*
			設定列表專案為表示式 {expr1} 的返回值。{var-name} 必須
			引用列表而 {idx} 必須是該列表裡合法的索引值。巢狀的列
			表可以重複使用索引。
			不能用於給列表 |List| 增加專案。
			不能用來給字串改變個別字節。為此你可以這麼做: >
				:let var = var[0:2] . 'X' . var[4:]
<
							*E711* *E719*
:let {var-name}[{idx1}:{idx2}] = {expr1}		*E708* *E709* *E710*
			設定 |List| 的一系列專案為表示式 {expr1} 的返回值，後
			者必須是正確數量專案的列表。
			{idx1} 可以省略，這時以零代替。
			{idx2} 可以省略，這時意味著到列表尾部。
			如果選擇的專案範圍部分越過列表的尾部，會加入新的專案。

					*:let+=* *:let-=* *:let.=* *E734*
:let {var} += {expr1}	類似於 ":let {var} = {var} + {expr1}"。
:let {var} -= {expr1}	類似於 ":let {var} = {var} - {expr1}"。
:let {var} .= {expr1}	類似於 ":let {var} = {var} . {expr1}"。
			如果 {var} 還沒有設定或者 {var} 和 {expr1} 的型別不符
			合操作符的要求，失敗。


:let ${env-name} = {expr1}			*:let-environment* *:let-$*
			設定環境變數 {env-name} 為表示式 {expr1} 的計算結果。
			它總是字串型。
:let ${env-name} .= {expr1}
			把 {expr1} 附加到環境變數 {env-name} 之後。如果該環境
			變數還不存在，相當於 "="。

:let @{reg-name} = {expr1}			*:let-register* *:let-@*
			把表示式 {expr1} 的計算結果寫到暫存器 {reg-name} 裡。
			{reg-name} 必須是單個字元，而且是一個可以寫入的暫存器
			(見 |registers|)。"@@" 可以用來訪問無名暫存器，而 "@/"
			設定搜尋模式。
			如果 {expr1} 的結果以 <CR> 或 <NL> 結束，該暫存器會成
			為面向行型別，不然，它會成為面向字元型別。
			這可以用來清除最近的搜尋模式: >
				:let @/ = ""
<			這和搜尋空字串不同，後者會在任何地方得到匹配。

:let @{reg-name} .= {expr1}
			把 {expr1} 附加到暫存器 {reg-name} 之後。如果暫存器為
			空，相當於把它設為 {expr1} 的值。

:let &{option-name} = {expr1}			*:let-option* *:let-&*
			設定選項 {option-name} 為表示式 {expr1} 的計算結果。字
			符串或數值型別的值總會被轉化為選項需要的型別。
			對於區域性於視窗或者緩衝區的選項而言，這和 |:set| 命令的
			效果相同: 區域性值和全域性值都被改變。
			例如: >
				:let &path = &path . ',/usr/local/include'
<			也可用於形如 t_xx 的終端程式碼。但只可用字母數字形式的名
			字。例如: >
				:let &t_k1 = "\<Esc>[234;"
<			如果程式碼還不存在，會新建一個終端鍵值，因此不會報錯。

:let &{option-name} .= {expr1}
			對字串選項: 附加 {expr1} 到選項值之後。和 |:set+=|
			不同，不會插入逗號。

:let &{option-name} += {expr1}
:let &{option-name} -= {expr1}
			對數值或布林選項: 加減 {expr1}。

:let &l:{option-name} = {expr1}
:let &l:{option-name} .= {expr1}
:let &l:{option-name} += {expr1}
:let &l:{option-name} -= {expr1}
			同上，但只設置選項的區域性值 (如果有的話)。和
			|:setlocal| 類似。

:let &g:{option-name} = {expr1}
:let &g:{option-name} .= {expr1}
:let &g:{option-name} += {expr1}
:let &g:{option-name} -= {expr1}
			同上，但只設置選項的全域性值 (如果有的話)。和
			|:setglobal| 類似。

:let [{name1}, {name2}, ...] = {expr1}		*:let-unpack* *E687* *E688*
			{expr1} 計算結果必須是 |List|。該列表的第一項賦給
			{name1}，第二項給 {name2}，依此類推。
			命名的數量必須匹配 |List| 專案的數量。
			每個名字必須是上面提到的 ":let" 命令的專案之一。
			例如: >
				:let [s, item] = GetItem(s)
<			細節: 先計算 {expr1}，然後按順序依次進行賦值。如果
			{name2} 依賴於 {name1}，該細節就有關係。例如: >
				:let x = [0, 1]
				:let i = 0
				:let [i, x[i]] = [1, 2]
				:echo x
<			結果是 [0, 2]。

:let [{name1}, {name2}, ...] .= {expr1}
:let [{name1}, {name2}, ...] += {expr1}
:let [{name1}, {name2}, ...] -= {expr1}
			同上，但附加/加/減值到每個 |List| 專案。

:let [{name}, ..., ; {lastname}] = {expr1}
			類似於上面的 |:let-unpack|，但 |List| 可以包含比給出名
			字的數量更多的專案。列表其餘專案賦給 {lastname}。
			如果沒有餘下的專案，{lastname} 設為空列表。
			例如: >
				:let [a, b; rest] = ["aval", "bval", 3, 4]
<
:let [{name}, ..., ; {lastname}] .= {expr1}
:let [{name}, ..., ; {lastname}] += {expr1}
:let [{name}, ..., ; {lastname}] -= {expr1}
			同上，但附加/加/減值到每個 |List| 專案。

								*E121*
:let {var-name}	..	列出變數 {var-name} 的值。可以給出多個變數的名字。這裡
			識別特殊的名字包括:		*E738*
			  g:	全域性變數
			  b:	緩衝區的區域性變數
			  w:	視窗的區域性變數
			  t:	標籤頁的區域性變數
			  s:	指令碼的區域性變數
			  l:	函式的區域性變數
			  v:	Vim 變數。

:let			列出所有變數的值。變數的型別在值之前給出:
			       <空>	字串
				#	數值
				*	函式引用


:unl[et][!] {name} ...				*:unlet* *:unl* *E108* *E795*
			刪除內部變數 {var-name}。可以給出多個變數的名字。它們
			都被刪除。該名字也可以是 |List| 或 |Dictionary| 專案。
			如果使用 [!]，即使變數不存在也不會給出錯誤。
			|List| 裡可以刪除一到多個專案: >
				:unlet list[3]	  " remove fourth item
				:unlet list[3:]   " remove fourth item to last
<			|Dictionary| 裡一次只能刪除一個專案: >
				:unlet dict['two']
				:unlet dict.two
<			這對於清除全域性和指令碼區域性變數很有用 (指令碼結束時並不自動
			刪除這些變數)。函式區域性變數在函式結束時是自動清除的。

:lockv[ar][!] [depth] {name} ...			*:lockvar* *:lockv*
			給內部變數 {name} 加鎖。加鎖意味著不能再修改該變數 (直
			到它被解鎖為止)。
			加鎖的變數可以刪除: >
				:lockvar v
				:let v = 'asdf'		" fails!
				:unlet v
<							*E741* *E940*
			如果試圖修改加鎖的變數，你會得到錯誤資訊: "E741: Value
			is locked: {name}"。
			如果試圖加鎖或解鎖內建變數，會報錯: "E940: Cannot lock
			or unlock variable {name}"。


			給 |List| 或 |Dictionary| 加鎖時用到 [depth]。它決定加
			鎖到達的深度:
				1	給 |List| 或 |Dictionary| 自身加鎖。不
					能增加或者刪除專案，但你可以修改它們的
					值。
				2	給這些值加也鎖，不能修改專案。如果專案
					是 |List| 或 |Dictionary|，不能增加或
					刪除其中專案，但仍然可以修改專案值。
				3	同 2，但又適用於 |List| / |Dictionary|
					中的 |List| / |Dictionary| 專案，更深
					一層。
			預設的 [depth] 為 2，{name} 是 |List| 或 |Dictionary|
			時，不能修改專案值。
								*E743*
			要使用沒有限制的深度，用 [!] 並省略 [depth]。不過，為
			了捕獲迴圈，設定最大深度為 100。

			注意 如果兩個變數引用同一個 |List| 而你鎖住其中一個，
			通過另一個變數來訪問 |List| 也同時被鎖住。
			例如: >
				:let l = [0, 1, 2, 3]
				:let cl = l
				:lockvar l
				:let cl[1] = 99		" won't work!
<			為了避免這一點，可以給列表建立備份。見 |deepcopy()|。


:unlo[ckvar][!] [depth] {name} ...			*:unlockvar* *:unlo*
			給內部變數 {name} 解鎖。和 |:lockvar| 剛好相反。


:if {expr1}			*:if* *:endif* *:en* *E171* *E579* *E580*
:en[dif]		如果 {expr} 計算為非零，執行命令直到其後匹配的 ":else"
			或者 ":endif" 為止。

			從 Vim 版本 4.5 到 5.0，":if" 和 ":endif" 之間的 Ex 命
			令被忽略。提供這兩個命令只是為了後向相容 (譯者注，原文
			如此)，以方便未來的擴充套件。可以巢狀。注意 任何的 ":else"
			或 ":elseif" 也被忽略，"else" 部分也一樣不會執行。

			利用這一點，你可以保持和舊版本的相容: >
				:if version >= 500
				:  版本 5 專用的命令
				:endif
<			為了找到 "endif"，仍然需要分析命令。有時，舊版本的 Vim
			不能識別新的命令。比如， ":silent" 被識別為
			":substitute" 命令。這種情形可以用 ":execute" 來避
			免: >
				:if version >= 600
				:  execute "silent 1,$delete"
				:endif
<
			注意: ":append" 和 ":insert" 命令在 ":if" 和 ":endif"
			之間不能正常工作。

						*:else* *:el* *E581* *E583*
:el[se]			如果這之前的命令沒有被執行，執行命令直到其後匹配的
			":else" 或 ":endif"。

					*:elseif* *:elsei* *E582* *E584*
:elsei[f] {expr1}	":else" ":if" 的縮寫，而且無需另一個 ":endif"。

:wh[ile] {expr1}			*:while* *:endwhile* *:wh* *:endw*
						*E170* *E585* *E588* *E733*
:endw[hile]		只要 {expr1} 計算的結果非零，重複 ":while" 和
			":endwhile" 之間的命令。
			如果發現迴圈裡有命令出錯，從 "endwhile" 之後繼續執行。
			例如: >
				:let lnum = 1
				:while lnum <= line("$")
				   :call FixLine(lnum)
				   :let lnum = lnum + 1
				:endwhile
<
			注意: ":append" 和 ":insert" 命令在 ":while" 和 ":for"
			迴圈裡不能正常工作。

:for {var} in {list}					*:for* *E690* *E732*
:endfo[r]						*:endfo* *:endfor*
			為每個 {list} 專案重複執行 ":for" 和 ":endfor" 之間的
			命令。變數 {var} 設為每個專案的值。
			如果迴圈裡某個命令出錯，從 "endfor" 之後繼續執行。
			在迴圈裡修改 {list} 影響使用的專案。如果不希望如此，構
			建一個備份: >
				:for item in copy(mylist)
<			如果不備份，Vim 在為當前專案執行命令前儲存列表裡下一個
			專案的引用。這樣，刪除當前專案不會影響迴圈的繼續。而刪
			除任何後來的專案也會使迴圈跳過它。這意味著下例可以工作
			(一個效率低下的清空列表的方法): >
				for item in mylist
				   call remove(mylist, 0)
				endfor
<			注意 給列表調整順序 (例如用 sort() 或 reverse()) 可能
			會有意想不到的效果。

:for [{var1}, {var2}, ...] in {listlist}
:endfo[r]
			和上面 ":for" 類似，但每個 {listlist} 專案必須是列表，
			其中每個專案被依次賦予 {var1}、{var2} 等。例如: >
				:for [lnum, col] in [[1, 3], [2, 5], [3, 8]]
				   :echo getline(lnum)[col]
				:endfor
<
						*:continue* *:con* *E586*
:con[tinue]		在 ":while" 或 ":for" 迴圈的內部，跳回迴圈開始的地方。
			如果在迴圈內部的 |:try| 之後但在匹配的 |:finally| (如
			果有的話) 之前，":finally" 之後，匹配的 |:endtry| 之前
			的命令會被先執行。該過程反覆應用於所有函式內的巢狀
			":try" 塊。在最外層 ":endtry" 結束之後才跳回迴圈的開始
			處。

						*:break* *:brea* *E587*
:brea[k]		在 ":while" 或 ":for" 迴圈的內部，跳到相匹配的
			":endwhile" 或 ":endfor" 之後的命令。
			如果在迴圈內部的 |:try| 之後但在匹配的 |:finally| (如
			果有的話) 之前，":finally" 之後，匹配的 |:endtry| 之前
			的命令會被先執行。該過程反覆應用於所有函式內的巢狀
			":try" 塊。在最外層 ":endtry" 結束之後才跳到迴圈之後的
			命令。

:try				*:try* *:endt* *:endtry* *E600* *E601* *E602*
:endt[ry]		改變 ":try" 和 ":endtry" 之間命令的錯誤處理，包括所有
			執行的內容，":source" 裡的命令，函式呼叫，或者自動命令
			的啟用等。

			如果檢測到錯誤或者中斷，而其後又跟隨了 |:finally| 命
			令，執行從 ":finally" 之後繼續。否則，或者在那以後遇到
			了 ":endtry"，則檢查是否存在 (動態的) 往外一層的
			":try" 以及其相應的 ":finally" 等等。然後，指令碼的處理
			被終止。(函式定義裡是否有 "abort" 引數都不相干。)
			示例: >
		:try | edit too much | finally | echo "cleanup" | endtry
		:echo "impossible"	" 到不了這裡，指令碼在上面已經終止
<
			另外，":try" 和 ":endtry" 之間的錯誤或者中斷 (動態地)
			被轉換成一個例外。它的捕獲過程如同它被 |:throw| 命令拋
			出那樣 (見 |:catch|)。這種情況下，指令碼的處理不會被終
			止。

			"Vim:Interrupt" 的值用於中斷例外。Vim 命令的錯誤被轉換
			成形如 "Vim({command}):{errmsg}" 的值，其它錯誤被轉換
			成形如 "Vim:{errmsg}"。這裡，{command} 是完整的命令
			名，而 {errmsg} 是錯誤例外如果沒有被捕獲的時候會顯示的
			訊息，它總以錯誤號開始。
			示例: >
		:try | sleep 100 | catch /^Vim:Interrupt$/ | endtry
		:try | edit | catch /^Vim(edit):E\d\+/ | echo "error" | endtry
<
					*:cat* *:catch* *E603* *E604* *E605*
:cat[ch] /{pattern}/	匹配 {pattern} 的例外丟擲時，如果它沒有被前一個
			":catch" 捕獲，則執行本語句之後的命令，直到遇到和本
			":catch" 處於同一 |:try| 塊的下一個 |:catch|、
			|:finally| 或者 |:endtry| 為止。否則，這些命令被跳過。
			如果沒有提供 {pattern}，所有的錯誤都會被捕獲。
			示例: >
		:catch /^Vim:Interrupt$/	" 捕獲中斷 (CTRL-C)
		:catch /^Vim\%((\a\+)\)\=:E/	" 捕獲所有的 Vim 錯誤
		:catch /^Vim\%((\a\+)\)\=:/	" 捕獲錯誤和中斷
		:catch /^Vim(write):/		" 捕獲所有 :write 的錯誤
		:catch /^Vim\%((\a\+)\)\=:E123/	" 捕獲錯誤 E123
		:catch /my-exception/		" 捕獲使用者例外
		:catch /.*/			" 捕獲一切
		:catch				" 等同於 /.*/
<
			除了 / 以外，也可以用別的字元包圍 {pattern}，只要它沒
			有特殊含義 (比如 '|' 或 '"') 而且不出現在 {pattern}
			裡。
			關於例外的資訊可見 |v:exception|。另見
			|throw-variables|。
			注意: 依賴 ":catch" 去捕獲錯誤資訊的_文字_是不可靠的，
			因為不同的 locale 的資訊可以不同。

					*:fina* *:finally* *E606* *E607*
:fina[lly]		任何匹配的 |:try| 和本 ":finally" 之間的部分要離開的時
			候都執行本語句之後的命令，直到遇到匹配的 |:endtry| 為
			止。包括這些情形: 正常完成且要執行到 ":finally"，通過
			|:continue|、|:break|、|:finish| 或 |:return|，或者由
			於錯誤或者中斷或者例外 (見 |:throw|)。

							*:th* *:throw* *E608*
:th[row] {expr1}	計算 {expr1} 然後丟擲例外。如果 ":throw" 在 |:try| 之
			後但在第一個對應的 |:catch| 之前使用，它之後的命令被跳
			過，直到遇到第一個匹配 {expr1} 為止。如果沒有這樣的
			":catch"，或者如果 ":throw" 在 ":catch" 之後
			|:finally| 之前使用，執行 ":finally" (如果有的話) 之後
			直到匹配的 |:endtry| 為止的命令。如果本 ":throw" 在
			":finally" 之後之後出現，直到 ":endtry" 為止的命令都被
			跳過。到達 ":endtry" 的時候，在動態計算的往外一層的
			":try" 塊上再次重複本過程 (這可能出現在外層呼叫的函式
			或者執行的指令碼上)，直到找到一個匹配的 ":catch"。如果最
			終該例外沒有被捕獲，命令處理被終止。
			示例: >
		:try | throw "oops" | catch /^oo/ | echo "caught" | endtry
<			注意 ”catch" 可能需要放在單獨一行上，因為某些錯誤可以
			導致整行在解析時被跳過而無法看到分隔命令的 "|"。

							*:ec* *:echo*
:ec[ho] {expr1} ..	回顯每個 {expr1}，以空格分隔。第一個 {expr1} 開啟一個
			新行。另見 |:comment|。
			使用 "\n" 來開啟新行。使用 "\r" 把游標移到第一列。
			使用 |:echohl| 命令的高亮設定。
			後面不能跟註釋。
			示例: >
		:echo "'shell' 的值是 " &shell
<							*:echo-redraw*
			後來的重畫可能使訊息再次消失。因為 Vim 常常會推遲重畫
			直到整個命令序列執行完為止，這個問題會頻繁出現。要避免
			":echo" 之前的命令引起它之後的重畫 (通常，重畫被延遲到
			有輸入的時候才進行)，使用 |:redraw| 命令強制重畫。例
			如: >
		:new | redraw | echo "這裡有一個新視窗"
<
							*:echon*
:echon {expr1} ..	回顯每個 {expr1}，不附加其它字元。另見 |:comment|。
			使用 |:echohl| 命令的高亮設定。
			後面不能跟註釋。
			例如: >
				:echon "'shell' 的值是 " &shell
<
			注意 兩者的區別: ":echo" 是一個 Vim 命令，而 ":!echo"
			是一個外部的外殼命令: >
		:!echo %		--> filename
<			":!" 的引數被擴充套件，見 |:_%|。 >
		:!echo "%"		--> filename or "filename"
<			和前例類似，你是否會看到雙引號取決於你的 'shell'。 >
		:echo %			--> nothing
<			'%' 不是一個表示式合法的字元。 >
		:echo "%"		--> %
<			只會回顯 '%' 字元。 >
		:echo expand("%")	--> filename
<			呼叫 expand() 函式來擴充套件 '%'。

							*:echoh* *:echohl*
:echoh[l] {name}	讓其後的 |:echo|、|:echon| 和 |:echomsg| 命令使用高亮
			組 {name}。也可用於 |input()| 的提示。示例: >
		:echohl WarningMsg | echo "Don't panic!" | echohl None
<			不要忘記把組設回 "None"。不然其後的 echo 都會被高亮。

							*:echom* *:echomsg*
:echom[sg] {expr1} ..	回顯表示式的結果，將其作為一個真正的訊息，並把該訊息保
			存在 |message-history| 裡。
			引數之間加入空格，和 |:echo| 類似。但不可顯示的字元只
			是回顯而不會被解釋。
			這裡的分析過程和 |:echo| 略有不同，而更像 |:execute|。
			所有的表示式都先經計算後進行連線，然後再進行回顯。
			表示式必須返回數值或字串，返回字典和列表會出錯。
			使用 |:echohl| 命令的高亮設定。
			示例: >
		:echomsg "It's a Zizzer Zazzer Zuzz, as you can plainly see."
<			|:echo-redraw| 說明如何避免螢幕重畫時訊息的消失問題。
							*:echoe* *:echoerr*
:echoe[rr] {expr1} ..	回顯表示式的結果，將其作為一個錯誤訊息，並把該訊息保
			存在 |message-history| 裡。如果用在指令碼或函式裡，會加
			入行號。
			引數之間加入空格，和 |:echo| 類似。如果在 try 條件句裡
			使用，該訊息會丟擲一個錯誤例外 (見 |try-echoerr|)。
			示例: >
		:echoerr "This script just failed!"
<			如果你只想要使用 |:echohl| 高亮的訊息。
			要得到鈴聲: >
		:exe "normal \<Esc>"
<
							*:exe* *:execute*
:exe[cute] {expr1} ..	計算 {expr1}，返回的字串作為 Ex 命令執行。
			多個引數用空格連線。如果不想有額外的空格，使用 "." 操
			作符來連線字串使之成為一個引數。
			{expr1} 用作被處理的命令，命令列編輯的鍵不會被識別。
			後面不能跟註釋。
			示例: >
		:execute "buffer" nextbuf
		:execute "normal" count . "w"
<
			":execute" 可以用來把命令附加到不能接受 '|' 的命令後
			面。比如: >
		:execute '!ls' | echo "theend"

<			":execute" 也是一個避免在 Vim 腳本里為 ":normal" 命令
			輸入控制字元的好方法: >
		:execute "normal ixxx\<Esc>"
<			這裡給出一個 <Esc> 字元，見 |expr-string|。

			要謹慎對待檔名中特殊字元的正確轉義。|fnameescape()|
			可用於 Vim 命令，|shellescape()| 可用於 |:!| 命令。示
			例: >
		:execute "e " . fnameescape(filename)
		:execute "!ls " . shellescape(filename, 1)
<
			注意: 執行的字串可以是任何命令列，但開始或結束一個
			"if"、"while" 和 "for" 命令不能保證沒有問題，因為跳過
			命令時，不執行 ":execute"，Vim 就不能準確找到塊開始和
			結束的地方。另外，"break" 和 "continue" 不應出現在
			":execute" 內部。
			下例不能工作，因為 ":execute" 不被執行，Vim 看不見
			":while"，找到 ":endwhile" 時就報錯: >
		:if 0
		: execute 'while i > 5'
		:  echo "test"
		: endwhile
		:endif
<
			但如果執行的字串裡有完整的 "while" 和 "if" 命令就沒
			有問題: >
		:execute 'while i < 5 | echo i | let i = i + 1 | endwhile'
<

							*:exe-comment*
			":execute"、":echo" 和 ":echon" 後面不能直接跟註釋。
			因它們把 '"' 看成字串的開始。但你可以把註釋加到 '|'
			後面。例如: >
		:echo "foo" | "這是一個註釋

==============================================================================
8. 例外處理						*exception-handling*

Vim 指令碼語言包含了例外處理特性。本節解釋如何在 Vim 腳本里應用該機制。

Vim 在出錯或者中斷的時候可以丟擲例外。見 |catch-errors| 和 |catch-interrupt|。
你也可以顯式地使用 ":throw" 命令丟擲例外。見 |throw-catch|。


TRY 條 件 句						*try-conditionals*

例外可以被捕獲或者用來激發清理程式碼的執行。你可以使用 try 條件句來指定 catch 子
句 (捕獲例外) 和/或 finally 子句 (執行清理)。
   try 條件句以 |:try| 命令開始，以匹配的 |:endtry| 命令結束。兩者之間，你可以
使用 |:catch| 命令開始 catch 子句，或者用 |:finally| 命令開始 finally 子句。
catch 子句可有零到多個，但 finally 子句至多隻有一個，且它之後不能再有 catch 子
句。catch 子句和 finally 子句之前的行稱為 try 塊。

     :try
     :  ...
     :  ...				TRY 塊
     :  ...
     :catch /{pattern}/
     :  ...
     :  ...				CATCH 子 句
     :  ...
     :catch /{pattern}/
     :  ...
     :  ...				CATCH 子 句
     :  ...
     :finally
     :  ...
     :  ...				FINALLY 子 句
     :  ...
     :endtry

try 子句允許觀察程式碼裡是否有例外，並採取合適的行動。try 塊裡的例外可能被捕獲。
try 塊和 catch 子句裡的例外可能引起清理動作。
   如果 try 塊的執行過程中沒有丟擲例外，控制轉移到 finally 子句。在它執行後，
指令碼從 ":endtry" 之後的行繼續。
   如果 try 塊的執行過程中丟擲了例外，該 try 塊其餘的行被跳過。例外和 ":catch"
命令的模式引數一一比較。第一個匹配的 ":catch" 之後的 catch 子句被採用，其餘的
catch 子句則不會執行。catch 子句在下一個最早遇到的 ":catch"、":finally" 或
":endtry" 命令結束。這時，finally 子句 (如果有的話) 被執行。當遇到 ":endtry"
的時候，指令碼從後面的行繼續，一如往常。
   如果 try 塊丟擲的例外不能匹配任何 ":catch" 命令的模式，該例外不能由本 try
條件句捕獲，因而不會執行任何的 catch 子句。只有 finally 子句，如果有的話，被採
用。該例外在 finally 子句的執行時被暫時擱置。在 ":endtry" 之後才繼續。這樣，
":endtry" 之後的命令不會被執行，而該例外可以在別的地方捕獲，見 |try-nesting|。
   如果在 catch 子句的執行過程中丟擲了另一個錯誤，catch 子句的其餘部分不再執
行。新的例外不會和試圖和同一個 try 條件句的任何 ":catch" 命令的模式匹配，因而
也不會執行任何它的 catch 子句。不過，如果有 finally 子句，它還是會被執行，而在
它的執行過程中暫時擱置新的例外。":endtry" 之後的命令也不會執行。而新的例外仍可
能在別的地方捕獲，見 |try-nesting|。
   如果在 finally 子句 (如果有的話) 的執行過程中丟擲了另一個錯誤，finally 子句
的其餘部分不再執行。如果 finally 子句是因為 try 塊或者某個 catch 子句裡產生的
例外引起的，原先的 (被暫時擱置的) 例外被放棄。":endtry" 之後的命令也不會執行。
而 finally 子句的這個例外被傳播，而可以在別的地方捕獲，見 |try-nesting|。

在 ":while" 迴圈包含的完整的 try 條件句裡的 try 塊或者某個 catch 子句裡遇到
":break" 或 ":continue" 時，或者在函式或者被執行的腳本里的 try 條件句裡的 try
塊或者某個 catch 子句裡執行 ":return" (函式) 或者 ":finish" (指令碼) 的時候，也
會執行 finally 子句。":break"、":continue"、":return" 或者 ":finish" 在
finally 子句的執行時被暫停，而在遇到 ":endtry" 時繼續。不過，如果在執行
finally 子句時丟擲例外，它們都被拋棄。
   在 ":while" 迴圈包含的完整的 try 條件句裡的 finally 子句裡遇到 ":break" 或
":continue" 時，或者在函式或者被執行的腳本里的 finally 子句裡執行 ":return" (
函式) 或者 ":finish" (指令碼) 的時候，finally 子句的其餘部分被跳過，而
":break"、":continue"、":return" 或 ":finish" 會如常繼續執行。如果 finally 的
執行是因為例外或者早先的 try 塊或者 catch 子句的 ":break"、":continue"、
":return" 或者 ":finish" 引起的，暫停的例外或者命令被放棄。

例子可見 |throw-catch| 和 |try-finally|。


TRY 條 件 句 的 嵌 套 					*try-nesting*

try 條件句可以任意巢狀。也就是說，完整的 try 條件句可以在另一個 try 條件句的
try 塊、某個 catch 子句或者 finally 子句裡出現。如果內層的 try 條件句不能捕獲
它的 try 塊丟擲的例外，或者在它的某個 catch 子句後者 finally 子句裡丟擲新的例
外的話，那麼根據上述規則由外層的 try 條件句繼續檢查是否能捕獲該例外。如果內層
try 條件句在外層 try 條件句的 try 塊裡，檢查外層的 catch 子句，不然只有
finally 子句會被執行。對巢狀的處理而言，內層 try 條件句是直接包含在外層裡面，
還是外層執行了指令碼或者呼叫了函式，而後者又包含了內層 try 條件句，無關緊要。

如果沒有活動的 try 條件句能捕獲某個例外，只有它們的 finally 子句會執行。最後，
指令碼結束它的處理。如果是 ":throw" 命令顯式地丟擲的未捕獲的例外，顯示錯誤資訊。
對於 Vim 隱含丟擲的未捕獲的錯誤或者中斷例外，錯誤資訊或者中斷資訊也會像平常一
樣顯示。

例子可見 |throw-catch|。


檢 查 例 外 處 理 代 碼					*except-examine*

例外處理的程式碼的編寫可能很麻煩。如果你不知道發生了什麼，把 'verbose' 設為 13，
或者在執行指令碼檔案時使用 ":13verbose" 命令修飾符。這樣，你能看到什麼時候例外被
丟擲、放棄、捕獲、或者最終處理。如果詳細程度大於等於 14，finally 子句暫停什麼
也會顯示。這些資訊在除錯模式裡也會給出 (見 |debug-scripts|)。


拋 出 和 捕 獲 例 外 					*throw-catch*

你可以丟擲任何數值或者字串作為例外。使用 |:throw| 命令然後把要丟擲的值作為參
數傳入: >
	:throw 4711
	:throw "string"
<							*throw-expression*
你可以指定表示式引數。該表示式先進行計算，然後丟擲其結果: >
	:throw 4705 + strlen("string")
	:throw strpart("strings", 0, 6)

在計算 ":throw" 命令的引數的時候，也可能會丟擲例外。除非它被捕獲，不然表示式的
計算會被放棄。":throw" 命令這時不會丟擲新的例外。
   例如: >

	:function! Foo(arg)
	:  try
	:    throw a:arg
	:  catch /foo/
	:  endtry
	:  return 1
	:endfunction
	:
	:function! Bar()
	:  echo "in Bar"
	:  return 4710
	:endfunction
	:
	:throw Foo("arrgh") + Bar()

這裡丟擲了 "arrgh"，而不會顯示 "in Bar"，因為 Bar() 沒有執行。 >
	:throw Foo("foo") + Bar()
卻顯示 "in Bar" 並且丟擲 4711。

別的接受表示式作為引數的命令也可能因為表示式計算過程的 (未捕獲的) 例外而被放
棄。例外這時被傳播給該命令的呼叫者。
   例如: >

	:if Foo("arrgh")
	:  echo "then"
	:else
	:  echo "else"
	:endif

這裡 "then" 和 "else" 都不會顯示。

							*catch-order*
try 條件句裡的例外可以用一個或多個 |:catch| 命令捕獲，見 |try-conditionals|。
每個 ":catch" 命令可以捕獲的值通過模式引數指定。捕獲匹配的例外時，執行其後的
catch 子句。
   例如: >

	:function! Foo(value)
	:  try
	:    throw a:value
	:  catch /^\d\+$/
	:    echo "Number thrown"
	:  catch /.*/
	:    echo "String thrown"
	:  endtry
	:endfunction
	:
	:call Foo(0x1267)
	:call Foo('string')

第一個 Foo() 的呼叫顯示 "Number thrown"，第二個 "String thrown"。
按照 ":catch" 命令本身的順序，依次匹配例外。只用第一個成功匹配。所以，你應該把
更專門的 ":catch" 放在前面。下面的順序並不合理: >

	:  catch /.*/
	:    echo "String thrown"
	:  catch /^\d\+$/
	:    echo "Number thrown"

這裡，第一個 ":catch" 總是會被匹配，所以第二個子句永遠不可能被採用。

							*throw-variables*
如果你使用通用的模式捕獲到例外，可以通過變數 |v:exception| 得到準確的例外值: >

	:  catch /^\d\+$/
	:    echo "Number thrown.  Value is" v:exception

你也許會對在什麼地方丟擲例外也感興趣。它被儲存在 |v:throwpoint| 裡。注意
"v:exception" 和 "v:throwpoint" 可用於最近捕獲的例外，只要該例外還沒有完成處
理。
   例如: >

	:function! Caught()
	:  if v:exception != ""
	:    echo 'Caught "' . v:exception . '" in ' . v:throwpoint
	:  else
	:    echo 'Nothing caught'
	:  endif
	:endfunction
	:
	:function! Foo()
	:  try
	:    try
	:      try
	:	 throw 4711
	:      finally
	:	 call Caught()
	:      endtry
	:    catch /.*/
	:      call Caught()
	:      throw "oops"
	:    endtry
	:  catch /.*/
	:    call Caught()
	:  finally
	:    call Caught()
	:  endtry
	:endfunction
	:
	:call Foo()

會顯示 >

	Nothing caught
	Caught "4711" in function Foo, line 4
	Caught "oops" in function Foo, line 10
	Nothing caught

更實際的例子:  下面的命令 ":LineNumber" 顯示呼叫它時，指令碼或者函式裡的行號: >

	:function! LineNumber()
	:    return substitute(v:throwpoint, '.*\D\(\d\+\).*', '\1', "")
	:endfunction
	:command! LineNumber try | throw "" | catch | echo LineNumber() | endtry
<
							*try-nested*
try 條件句沒有捕獲的例外可以在包圍它的 try 條件句中捕獲: >

	:try
	:  try
	:    throw "foo"
	:  catch /foobar/
	:    echo "foobar"
	:  finally
	:    echo "inner finally"
	:  endtry
	:catch /foo/
	:  echo "foo"
	:endtry

內層的 try 條件句沒有捕獲例外，只執行了 finally 子句。例外在外層得到捕獲。本例
顯示 "inner finally" 然後是 "foo"。

							*throw-from-catch*
你可以捕獲某例外，然後丟擲另一個。它在該 catch 子句之外捕獲: >

	:function! Foo()
	:  throw "foo"
	:endfunction
	:
	:function! Bar()
	:  try
	:    call Foo()
	:  catch /foo/
	:    echo "Caught foo, throw bar"
	:    throw "bar"
	:  endtry
	:endfunction
	:
	:try
	:  call Bar()
	:catch /.*/
	:  echo "Caught" v:exception
	:endtry

顯示 "Caught foo, throw bar" 然後是 "Caught bar"。

							*rethrow*
Vim 指令碼語言沒有真正的 rethrow。但可以丟擲 "v:exception" 來代替: >

	:function! Bar()
	:  try
	:    call Foo()
	:  catch /.*/
	:    echo "Rethrow" v:exception
	:    throw v:exception
	:  endtry
	:endfunction
<							*try-echoerr*
注意 這個方法不能用來 "rethrow" Vim 錯誤或者中斷例外，因為不能偽造 Vim 的內部
例外。試圖這麼做會產生一個錯誤例外。你應該丟擲自己的例外來說明這種情形。如果你
想產生 Vim 的錯誤例外幷包含原來的錯誤例外的值，可以使用 |:echoerr| 命令: >

	:try
	:  try
	:    asdf
	:  catch /.*/
	:    echoerr v:exception
	:  endtry
	:catch /.*/
	:  echo v:exception
	:endtry

本程式碼會顯示

	Vim(echoerr):Vim:E492: Not an editor command:   asdf ~


清 理 代 碼						*try-finally*

指令碼經常需要改變全域性設定然後結束時恢復之。不過，如果使用者按了 CTRL-C 中止指令碼，
這些設定會處於不一致的狀態。如果你處於某指令碼的開發階段而發生了錯誤或者你顯式地
丟擲例外而沒有試圖捕獲之，也會有相同的情況。用帶有 finally 子句的 try 條件句，
可以恢復設定，從而解決這個問題。可以保證無論是正常的控制流、出錯或者顯式的例外
":throw"、還是被中斷，都會執行 finally 子句 (注意 try 條件句的錯誤和中斷被轉換
成例外。如果沒有捕獲，它們在 finally 子句執行完之後會終止指令碼。)
例如: >

	:try
	:  let s:saved_ts = &ts
	:  set ts=17
	:
	:  " 這裡執行重要的任務。
	:
	:finally
	:  let &ts = s:saved_ts
	:  unlet s:saved_ts
	:endtry

無論任何函式還是指令碼的一部分，只要它需要修改全域性設定，而在失敗或者成功退出該函
數或者指令碼部分時需要恢復這些設定，就應該在本地應用本方法。

							*break-finally*
清理程式碼也適用於 ":continue"、":break"、":return" 或 ":finish" 退出的 try 塊或
catch 子句。
   例如: >

	:let first = 1
	:while 1
	:  try
	:    if first
	:      echo "first"
	:      let first = 0
	:      continue
	:    else
	:      throw "second"
	:    endif
	:  catch /.*/
	:    echo v:exception
	:    break
	:  finally
	:    echo "cleanup"
	:  endtry
	:  echo "still in while"
	:endwhile
	:echo "end"

會顯示 "first"、"cleanup"、"second"、"cleanup" 和 "end"。 >

	:function! Foo()
	:  try
	:    return 4711
	:  finally
	:    echo "cleanup\n"
	:  endtry
	:  echo "Foo still active"
	:endfunction
	:
	:echo Foo() "returned by Foo"

會顯示 "cleanup" 和 "4711 returned by Foo"。你不需要在 finally 子句里加上附加
的 ":return"。(最終，它會覆蓋原來的返回值。)

							*except-from-finally*
finally 子句裡可以使用 ":continue"、":break"、":return"、":finish" 或
":throw"，但不推薦，因為它放棄了 try 條件句的清理工作。不過當然了，finally 子
句裡仍然可能有中斷或者錯誤例外。
   finally 子句的錯誤引起中斷不能正常工作的例子: >

	:try
	:  try
	:    echo "Press CTRL-C for interrupt"
	:    while 1
	:    endwhile
	:  finally
	:    unlet novar
	:  endtry
	:catch /novar/
	:endtry
	:echo "Script still running"
	:sleep 1

如果你需要在 finally 裡放入可能出錯的命令，考慮捕獲或者忽略這些命令的錯誤，見
|catch-errors| 和 |ignore-errors|。


捕 獲 錯 誤						*catch-errors*

如果你想捕獲特定的錯誤，你需要把要關注的程式碼放到 try 塊裡，然後為該錯誤訊息加
入 catch 子句。try 條件句的存在使得所有的錯誤被轉換為例外。不會顯示訊息，而
|v:errmsg| 也不會設定。要找到 ":catch" 命令右邊的模式，你需要知道錯誤例外的格
式。
   錯誤例外使用如下的格式: >

	Vim({cmdname}):{errmsg}
或 >
	Vim:{errmsg}

{cmdname} 是失敗的命令名；第二種形式用於命令名未知的場合。{errmsg} 是錯誤在
try 條件句發生時，本應產生的錯誤訊息。它總是以大寫的 "E" 開始，後面跟兩或者三
位的錯誤號，一個冒號和一個空格。

例如:

命令 >
	:unlet novar
通常產生錯誤資訊 >
	E108: No such variable: "novar"
它在 try 條件句裡被轉換為例外 >
	Vim(unlet):E108: No such variable: "novar"

命令 >
	:dwim
通常產生錯誤資訊 >
	E492: Not an editor command: dwim
它在 try 條件句裡被轉換為例外 >
	Vim:E492: Not an editor command: dwim

你可以這樣捕獲所有的 ":unlet" 錯誤 >
	:catch /^Vim(unlet):/
或者這樣捕獲所有拼錯命令名字的錯誤 >
	:catch /^Vim:E492:/

有的錯誤資訊可能由不同的命令產生: >
	:function nofunc
和 >
	:delfunction nofunc
都會產生錯誤資訊 >
	E128: Function name must start with a capital: nofunc
它在 try 條件句裡被分別轉換為例外 >
	Vim(function):E128: Function name must start with a capital: nofunc
或 >
	Vim(delfunction):E128: Function name must start with a capital: nofunc
使用下面的模式，你可以根據其號碼捕獲錯誤，而不管產生的命令是什麼: >
	:catch /^Vim(\a\+):E128:/

有些命令，比如 >
	:let x = novar
產生多個錯誤資訊，這裡: >
	E121: Undefined variable: novar
	E15: Invalid expression:  novar
只有第一個會用做例外的值，因為它是最專門的那個 (見 |except-several-errors|)。
所以你應該這樣捕獲它 >
	:catch /^Vim(\a\+):E121:/

你可以這樣捕獲所有和名字 "nofunc" 相關的錯誤 >
	:catch /\<nofunc\>/

你可以這樣捕獲 ":write" 和 ":read" 命令產生的所有 Vim 的錯誤 >
	:catch /^Vim(\(write\|read\)):E\d\+:/

你可以這樣捕獲所有的 Vim 錯誤 >
	:catch /^Vim\((\a\+)\)\=:E\d\+:/
<
							*catch-text*
注意: 永遠不要根據錯誤資訊文字本身捕獲錯誤: >
	:catch /No such variable/
只適用於英語的 locale，如果使用者用 |:language| 命令使用別的語言就不行了。不過，
在註釋裡引用該訊息或許有幫助: >
	:catch /^Vim(\a\+):E108:/   " No such variable


忽 略 錯 誤						*ignore-errors*

你可以通過在本地捕獲來忽略某個 Vim 命令的錯誤: >

	:try
	:  write
	:catch
	:endtry

但強烈建議，_不要_使用這種簡單的形式，因為它捕獲的東西超過你的想象。":write"
命令裡，會執行一些自動命令，它們可能引起與寫入無關的錯誤。例如: >

	:au BufWritePre * unlet novar

作為指令碼的作者，你不應該負責處理這些錯誤: 使用你書寫的指令碼的使用者可能定義了這些
自動命令。而你這麼做只會遮蔽使用者自己的錯誤。
   更好的方法是用 >

	:try
	:  write
	:catch /^Vim(write):/
	:endtry

這樣，只捕獲真正的 write 錯誤。總之，只應該捕獲你有意忽略的錯誤。

對於單個不會執行自動命令的命令，你可以用 ":silent!" 命令來關閉錯誤到例外的轉
換: >
	:silent! nunmap k
即使在活動的 try 條件句裡也能這麼用。


捕 獲 中 斷						*catch-interrupt*

如果有活動的 try 條件句，中斷 (CTRL-C) 被轉換為例外 "Vim:Interrupt"。你可以和
其他例外一樣捕獲它。那樣，指令碼就不會中止。
   例如: >

	:function! TASK1()
	:  sleep 10
	:endfunction

	:function! TASK2()
	:  sleep 20
	:endfunction

	:while 1
	:  let command = input("Type a command: ")
	:  try
	:    if command == ""
	:      continue
	:    elseif command == "END"
	:      break
	:    elseif command == "TASK1"
	:      call TASK1()
	:    elseif command == "TASK2"
	:      call TASK2()
	:    else
	:      echo "\nIllegal command:" command
	:      continue
	:    endif
	:  catch /^Vim:Interrupt$/
	:    echo "\nCommand interrupted"
	:    " Caught the interrupt.  Continue with next prompt.
	:  endtry
	:endwhile

這裡，你可以用 CTRL-C 中止任務；指令碼會詢問新的命令。如果你在提示上按 CTRL-C，
指令碼就會中止。

要測試在你指令碼的某一行上如果按了 CTRL-C 會發生什麼，使用除錯模式，然後在那行上
執行 |>quit| 或 |>interrupt|。見 |debug-scripts|。


捕 獲 一 切						*catch-all*

命令 >

	:catch /.*/
	:catch //
	:catch

會捕獲一切: 錯誤例外，中斷例外和 |:throw| 命令顯式丟擲的例外。指令碼的頂層可用此
捕獲所有意料不到的問題。
   示例: >

	:try
	:
	:  " 這裡做重要的工作
	:
	:catch /MyException/
	:
	:  " 處理未知的問題
	:
	:catch /^Vim:Interrupt$/
	:    echo "指令碼被中斷"
	:catch /.*/
	:  echo "內部錯誤 (" . v:exception . ")"
	:  echo " - 發生在 " . v:throwpoint
	:endtry
	:" 指令碼結束
<
注意: 捕獲一切可能會捕獲到比你想得到的更多的錯誤。所以，強烈建議你只用指定模式
引數的 ":catch" 來捕獲你真正處理的錯誤。
   例如: 捕獲一切會使得按 CTRL-C 來中斷指令碼幾乎沒有辦法: >

	:while 1
	:  try
	:    sleep 1
	:  catch
	:  endtry
	:endwhile


例 外 和 自 動 命 令 					*except-autocmd*

執行自動命令的過程中可以使用例外。例如: >

	:autocmd User x try
	:autocmd User x   throw "Oops!"
	:autocmd User x catch
	:autocmd User x   echo v:exception
	:autocmd User x endtry
	:autocmd User x throw "Arrgh!"
	:autocmd User x echo "Should not be displayed"
	:
	:try
	:  doautocmd User x
	:catch
	:  echo v:exception
	:endtry

會顯示 "Oops!" 和 "Arrgh!"。

							*except-autocmd-Pre*
有些命令裡，自動命令在命令執行的主要動作之前執行。如果在自動命令的序列中拋
出沒有捕獲的例外，該序列和導致其執行的命令本身被放棄，而例外被傳播到命令的呼叫
者那裡。
   例如: >

	:autocmd BufWritePre * throw "FAIL"
	:autocmd BufWritePre * echo "應該不會顯示"
	:
	:try
	:  write
	:catch
	:  echo "Caught:" v:exception "from" v:throwpoint
	:endtry

這裡，":write" 命令不會寫入當前編輯的檔案 (你可以通過檢視 'modified' 發現)。因
為例外來自 BufWritePre 自動命令，它放棄了 ":write"。然後，該例外被捕獲而指令碼會
顯示: >

	Caught: FAIL from BufWrite Auto commands for "*"
<
							*except-autocmd-Post*
有些命令裡，自動命令在命令執行的主要動作之後執行。如果主要動作失敗，而命令包含
在活動的 try 條件句裡，將跳過這些自動命令並丟擲錯誤例外，該命令的呼叫者可以捕
獲這些例外。
   例如: >

	:autocmd BufWritePost * echo "檔案被成功寫入！"
	:
	:try
	:  write /i/m/p/o/s/s/i/b/l/e
	:catch
	:  echo v:exception
	:endtry

只會顯示: >

	Vim(write):E212: Can't open file for writing (/i/m/p/o/s/s/i/b/l/e)

如果你真想在主要動作失敗的時候也執行自動命令的話，在 catch 子句裡啟用自動命令
事件。
   例如: >

	:autocmd BufWritePre  * set noreadonly
	:autocmd BufWritePost * set readonly
	:
	:try
	:  write /i/m/p/o/s/s/i/b/l/e
	:catch
	:  doautocmd BufWritePost /i/m/p/o/s/s/i/b/l/e
	:endtry
<
你也可以用 ":silent!": >

	:let x = "ok"
	:let v:errmsg = ""
	:autocmd BufWritePost * if v:errmsg != ""
	:autocmd BufWritePost *   let x = "after fail"
	:autocmd BufWritePost * endif
	:try
	:  silent! write /i/m/p/o/s/s/i/b/l/e
	:catch
	:endtry
	:echo x

會顯示 "after fail"。

如果命令的主要動作沒有失敗，可以在命令的呼叫者那裡捕獲自動命令產生的例外: >

	:autocmd BufWritePost * throw ":-("
	:autocmd BufWritePost * echo "這裡不應該被顯示"
	:
	:try
	:  write
	:catch
	:  echo v:exception
	:endtry
<
							*except-autocmd-Cmd*
有的命令的正常動作可以被自動命令的序列代替。可以在命令的呼叫者那裡捕獲該序列產
生的例外。
   例如: 對於 ":write" 命令，呼叫者並不知道發生例外時，檔案是不是已經被寫入。
你需要想辦法告知呼叫者。 >

	:if !exists("cnt")
	:  let cnt = 0
	:
	:  autocmd BufWriteCmd * if &modified
	:  autocmd BufWriteCmd *   let cnt = cnt + 1
	:  autocmd BufWriteCmd *   if cnt % 3 == 2
	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"
	:  autocmd BufWriteCmd *   endif
	:  autocmd BufWriteCmd *   write | set nomodified
	:  autocmd BufWriteCmd *   if cnt % 3 == 0
	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"
	:  autocmd BufWriteCmd *   endif
	:  autocmd BufWriteCmd *   echo "File successfully written!"
	:  autocmd BufWriteCmd * endif
	:endif
	:
	:try
	:	write
	:catch /^BufWriteCmdError$/
	:  if &modified
	:    echo "Error on writing (file contents not changed)"
	:  else
	:    echo "Error after writing"
	:  endif
	:catch /^Vim(write):/
	:    echo "Error on writing"
	:endtry

如果指令碼在修改後執行了多次，它先顯示 >
	File successfully written!
然後 >
	Error on writing (file contents not changed)
然後 >
	Error after writing
等等。

							*except-autocmd-ill*
你不能把一個 try 條件句分散到不同事件的自動命令。
下面的程式碼是非法的構造: >

	:autocmd BufWritePre  * try
	:
	:autocmd BufWritePost * catch
	:autocmd BufWritePost *   echo v:exception
	:autocmd BufWritePost * endtry
	:
	:write


例 外 層 次 和 參 數 化 的 例 外			*except-hier-param*

有些程式語言支援使用例外類的層次結構，或者在例外類的物件裡傳入附加的資訊。你可
以在 Vim 裡完成類似的工作。
   為了丟擲屬於某層次的例外，只要丟擲完整的類名，部件之間用冒號分隔。比如，在
某個數學庫裡的溢位錯誤可以丟擲字串 "EXCEPT:MATHERR:OVERFLOW"。
   如果你想給例外類傳遞附加的資訊，把它加到括號裡。比如寫入檔案 "myfile" 時的
錯誤，可以丟擲字串 "EXCEPT:IO:WRITEERR(myfile)"。
   在 ":catch" 命令裡使用合適的模式，可以捕獲你的層次中的基本類或者派生類。括
號裡的附加資訊也可以運用 ":substitute" 命令從 |v:exception| 裡切出。
   例如: >

	:function! CheckRange(a, func)
	:  if a:a < 0
	:    throw "EXCEPT:MATHERR:RANGE(" . a:func . ")"
	:  endif
	:endfunction
	:
	:function! Add(a, b)
	:  call CheckRange(a:a, "Add")
	:  call CheckRange(a:b, "Add")
	:  let c = a:a + a:b
	:  if c < 0
	:    throw "EXCEPT:MATHERR:OVERFLOW"
	:  endif
	:  return c
	:endfunction
	:
	:function! Div(a, b)
	:  call CheckRange(a:a, "Div")
	:  call CheckRange(a:b, "Div")
	:  if (a:b == 0)
	:    throw "EXCEPT:MATHERR:ZERODIV"
	:  endif
	:  return a:a / a:b
	:endfunction
	:
	:function! Write(file)
	:  try
	:    execute "write" fnameescape(a:file)
	:  catch /^Vim(write):/
	:    throw "EXCEPT:IO(" . getcwd() . ", " . a:file . "):WRITEERR"
	:  endtry
	:endfunction
	:
	:try
	:
	:  " 一些算術和 I/O
	:
	:catch /^EXCEPT:MATHERR:RANGE/
	:  let function = substitute(v:exception, '.*(\(\a\+\)).*', '\1', "")
	:  echo "Range error in" function
	:
	:catch /^EXCEPT:MATHERR/	" 捕獲 OVERFLOW 和 ZERODIV
	:  echo "Math error"
	:
	:catch /^EXCEPT:IO/
	:  let dir = substitute(v:exception, '.*(\(.\+\),\s*.\+).*', '\1', "")
	:  let file = substitute(v:exception, '.*(.\+,\s*\(.\+\)).*', '\1', "")
	:  if file !~ '^/'
	:    let file = dir . "/" . file
	:  endif
	:  echo 'I/O error for "' . file . '"'
	:
	:catch /^EXCEPT/
	:  echo "Unspecified error"
	:
	:endtry

Vim 自己丟擲的例外 (錯誤或者按了 CTRL-C) 使用扁平的層次: 它們都在 "Vim" 類裡。
你自己不能丟擲帶有 "Vim" 字首的例外；它們是 Vim 保留的。
   如果已知失敗的命令名，Vim 錯誤例外使用該命令名作為引數。見 |catch-errors|。


特 別 之 處
							*except-compat*
例外處理的概念需要產生例外的命令序列被立即中止，而控制轉移到 finally 子句和/或
catch 子句。

在 Vim 指令碼語言裡，有一些情況下指令碼和函式在錯誤後還會繼續: 在沒有 "abort" 標誌
位的函式或者 ":silent!" 之後的命令裡，控制流轉到下一行。而在函式外，控制流轉到
最外層 ":endwhile" 或者 ":endif" 之後的行。另一方面，錯誤應該可以作為例外被捕
獲 (因而，需要立即被中止)。

這個問題的解決方法是把僅在有活動 try 條件句的時候，把錯誤轉化為例外，並立即中
止 (如果沒有用 ":silent!" 抑制的話)。這不是一個限制，因為 (錯誤) 例外只能在活
動的 try 條件句裡被捕獲。如果你需要立即終止而不需要捕獲錯誤的話，只要用一個沒
有 catch 子句的 try 子句就可以了 (你可以用 finally 子句指定終止前執行的清理代
碼。)

如果沒有活動的 try 條件句，使用通常的中止和繼續行為，而不是立即中止。這樣，保
證了與 Vim 6.1 和之前版本編寫的指令碼的相容性。

不過，如果在活動的 try 條件句裡執行已有的不使用例外處理命令的指令碼 (或者呼叫它
的一個函式)，你也許會改變已有指令碼發生錯誤時的控制流。你會在錯誤時立即中止並且
在新的腳本里捕獲錯誤。如果被執行的指令碼通過 ":silent!" 命令抑制了錯誤 (在合適的
時候測試 |v:errmsg| 來檢查錯誤)，它的執行路徑沒有改變。錯誤也不會轉換為例外。
(見 |:silent|。) 所以唯一留下的可能是不關心錯誤併產生錯誤資訊的指令碼。可能，你
也不希望在新的腳本里使用這樣的程式碼吧。

							*except-syntax-err*
例外處理命令的語法錯誤永遠不會被它所屬的 try 條件句的任何 ":catch" 命令所捕
獲。不過，還是會執行它的 finally 子句。
   例如: >

	:try
	:  try
	:    throw 4711
	:  catch /\(/ " 有語法錯誤
	:    echo "in catch with syntax error"
	:  catch
	:    echo "inner catch-all"
	:  finally
	:    echo "inner finally"
	:  endtry
	:catch
	:  echo 'outer catch-all caught "' . v:exception . '"'
	:  finally
	:    echo "outer finally"
	:endtry

會顯示: >
    inner finally
    outer catch-all caught "Vim(catch):E54: Unmatched \("
    outer finally
原來的例外被丟棄了，丟擲的是取而代之的語法錯誤的錯誤例外。

							*except-single-line*
":try"、":catch"、":finally" 和 ":endtry" 命令可以放在一行裡，但這樣如果有語法
錯誤，可能使得 "catch" 行無法被識別。所以，最好不要這麼做。
   例如: >
	:try | unlet! foo # | catch | endtry
":unlet!" 引數之後的拖尾字元丟擲了錯誤例外，但因此無法看到 ":catch" 和
":endtry" 命令，從而只能丟棄該錯誤例外並且顯示訊息 "E488: Trailing
characters"。

							*except-several-errors*
如果多個錯誤在一個命令裡出現，第一個錯誤資訊通常是最專門的，因而它被轉換為錯誤
例外。
   例如: >
	echo novar
產生 >
	E121: Undefined variable: novar
	E15: Invalid expression: novar
try 條件句裡錯誤例外的值是: >
	Vim(echo):E121: Undefined variable: novar
<							*except-syntax-error*
不過，如果同一命令在普通錯誤之後發現了語法錯誤，語法錯誤被用作丟擲的例外。
   例如: >
	unlet novar #
產生 >
	E108: No such variable: "novar"
	E488: Trailing characters
try 條件句裡錯誤例外的值是: >
	Vim(unlet):E488: Trailing characters
這麼做是因為語法錯誤可能會以使用者意想不到的方式改變執行的路徑。例如: >
	try
	    try | unlet novar # | catch | echo v:exception | endtry
	catch /.*/
	    echo "outer catch:" v:exception
	endtry
顯示 "outer catch: Vim(unlet):E488: Trailing characters"，然後給出錯誤資訊
"E600: Missing :endtry"，見 |except-single-line|。

==============================================================================
9. 示例							*eval-examples*

用二進位制顯示 ~
>
  :" 函式 Nr2Bin() 返回數值的二進位制字串。
  :func Nr2Bin(nr)
  :  let n = a:nr
  :  let r = ""
  :  while n
  :    let r = '01'[n % 2] . r
  :    let n = n / 2
  :  endwhile
  :  return r
  :endfunc

  :" 函式 String2Hex() 把字串裡的每個字元轉換成二進位制字串，用連字元分隔字
  :" 符。
  :func String2Bin(str)
  :  let out = ''
  :  for ix in range(strlen(a:str))
  :    let out = out . '-' . Nr2Bin(char2nr(a:str[ix]))
  :  endfor
  :  return out[1:]
  :endfunc

使用示例: >
  :echo Nr2Bin(32)
返回: "100000" >
  :echo String2Bin("32")
返回: "110011-110010"


給行排序 ~

下例用特定比較函式給行排序。 >

  :func SortBuffer()
  :  let lines = getline(1, '$')
  :  call sort(lines, function("Strcmp"))
  :  call setline(1, lines)
  :endfunction

可寫為一行程式: >
  :call setline(1, sort(getline(1, '$'), function("Strcmp")))


scanf() 的替代 ~
							*sscanf*
Vim 裡沒有 sscanf() 函式。如果你需要提取一行的部分內容，可以使用 matchstr() 和
substitute() 完成。本例子說明如何得到從類似 "foobar.txt, 123, 45" 的行裡提取文
件名，行號和列號。 >
   :" 設定匹配模式
   :let mx='\(\f\+\),\s*\(\d\+\),\s*\(\d\+\)'
   :"取得匹配整個表示式的文字部分
   :let l = matchstr(line, mx)
   :"從匹配中提取每個專案
   :let file = substitute(l, mx, '\1', '')
   :let lnum = substitute(l, mx, '\2', '')
   :let col = substitute(l, mx, '\3', '')

這裡，輸入是變數 "line"，返回值放在變數 "file"、"lnum" 和 "col" 裡。(Michael
Geddes 提供的方法)


輸出 scriptnames 到字典 ~
						*scriptnames-dictionary*
|:scriptnames| 命令可用於得到執行過的所有指令碼檔案的列表。沒有等價的函式或變數
(因為很少用到)。如果需要操作此列表，可以使用下面的程式碼: >
    " 把 ":scriptnames" 的輸出存放到 scriptnames_output 變數中。
    let scriptnames_output = ''
    redir => scriptnames_output
    silent scriptnames
    redir END

    " 把輸出分拆為行，並對每行進行分析。在 "script" 字典中加入專案。
    let scripts = {}
    for line in split(scriptnames_output, "\n")
      " 只處理非空白行。
      if line =~ '\S'
	" 獲取每行的第一個數字。
        let nr = matchstr(line, '\d\+')
	" 獲取檔名，刪除指令碼號 " 123: "。
        let name = substitute(line, '.\+:\s*', '', '')
	" 在字典中加入專案
        let scripts[nr] = name
      endif
    endfor
    unlet scriptnames_output

==============================================================================
10. 不包含 +eval 特性				*no-eval-feature*

如果編譯時關閉了 |+eval| 特性，以上的表示式計算命令都不可用。為了避免因此導致
你的 Vim 指令碼產生各種錯誤，":if" 和 ":endif" 命令仍然得到識別。不過 ":if" 的參
數和一切  ":if" 和匹配的 ":endif" 之間的內容都被忽略。可以巢狀 ":if" 塊，但只
允許出現在行首。不識別 ":else" 命令。

下例演示如何在不存在 |+eval| 特性時不執行命令: >

	:if 1
	:  echo "編譯加入了表示式求值"
	:else
	:  echo "你_永遠_看不到這條訊息"
	:endif

要在 |+eval| 特性關閉時才執行命令需要一點技巧，如下例所示: >

	silent! while 0
	  set history=111
	silent! endwhile

|+eval| 特性可用時，因為 "while 0" 跳過此命令。沒有 |+eval| 特性時，"while 0"
是錯誤但被安靜地忽略，從而執行此命令。

==============================================================================
11. 沙盤 (sandbox)				*eval-sandbox* *sandbox* *E48*

'foldexpr'、'formatexpr'、'includeexpr'、'indentexpr'、'statusline' 和
'foldtext' 選項在沙盤 (sandbox) 裡進行計算。這意味著這些表示式不會產生可怕的副
作用。在模式行上設定這些選項時，以及在標籤檔案裡和命令列上的 CTRL-R = 執行命令
時，這項措施提供了一定的安全性。
沙盤也用於 |:sandbox| 命令。

沙盤裡，不允許以下操作:
	- 修改緩衝區文字
	- 定義或者改變對映、自動命令、函式和使用者命令
	- 設定若干選項 (見 |option-summary|)
	- 設定若干 v: 變數 (見 |v:var|)  *E794*
	- 執行外殼命令
	- 讀入或者寫到檔案
	- 跳轉到另一緩衝區或者去編輯檔案
	- 執行 Python、Perl 等命令
這並不能保證 100% 安全，但應該可以擋住大多數攻擊。

							*:san* *:sandbox*
:san[dbox] {cmd}	在沙盤裡執行 {cmd}。用於計算可能在模式行裡設定的選項，
			比如 'foldexpr'。

							*sandbox-option*
一些選項包含表示式。對這些表示式進行計算時可能要使用沙盤才能避免安全性的威脅。
但沙盤限制較多，所以只有在從不安全的位置設定選項時才會如此。在此上下文中，不安
全的位置指:
- 執行當前目錄的 .vimrc 或 .exrc 時
- 在沙盤裡執行時
- 來自模式行的值

注意 如果在沙盤裡儲存選項值然後恢復之，該選項仍然標記為在沙盤裡設定。

==============================================================================
12. 文字鎖							*textlock*

在一些情況下，不允許修改緩衝區裡的文字、跳轉到其它視窗和一些其它會引起混淆或打
斷 Vim 正在進行的操作的動作。這主要適用於和 Vim 實際正在進行其它操作的同時發生
的事情。例如，'balloonexpr' 的計算可能發生在滑鼠指標定位在若干位置的任何時候。

文字鎖啟用時，不允許:
	- 修改緩衝區文字
	- 跳轉到其它緩衝區或視窗
	- 編輯其它檔案
	- 關閉視窗或者退出 Vim
	- 其它

==============================================================================
13. Testing							*testing*

Vim 在編譯後可以進行測試，通常用 "make test" 進行。
這些測試位於目錄 "src/testdir"。

在不同的時間點，加入了幾種不同型別的測試:
	test33.in		最老的，不要再加了
	test_something.in	舊風格測試
	test_something.vim	新風格測試

						*new-style-testing*
新寫的測試需用新風格的測試。使用 |assert_equal()| 之類的函式，以便在同一處地方
維護測試命令和期待的結果。
						*old-style-testing*
有些場合仍然需要舊風格的測試。例如在沒有 |+eval| 特性時測試 Vim。

更多資訊可見檔案 src/testdir/README.txt。


 vim:tw=78:ts=8:ft=help:norl:
