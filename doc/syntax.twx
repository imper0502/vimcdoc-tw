*syntax.txt*	For Vim version 8.0.  最近更新: 2017年8月


		  VIM 參考手冊	  by Bram Moolenaar
				譯者: Willis
				http://vimcdoc.sf.net


語法高亮			*syntax* *syntax-highlighting* *coloring*

語法高亮使得 Vim 可以用不同的字型或顏色顯示文字的不同部分。這些部分可以是特定
的關鍵字，或者匹配某模式的文字。Vim 不會分析整個檔案 (為了保持快速)，所以高亮
功能有其限制。詞法高亮或者是一個更合適的名字，但既然大家都使用語法高亮，我們也
就如此稱呼。

Vim 支援所有終端上的語法高亮。但因為多數普通的終端只有有限的高亮的選擇，GUI 版
本 gvim 的語法高亮的效果最好。

使用者手冊裡:
|usr_06.txt| 介紹語法高亮。
|usr_44.txt| 介紹如何寫語法檔案。

1.  快速入門			|:syn-qstart|
2.  語法檔案			|:syn-files|
3.  語法載入過程		|syntax-loading|
4.  語法檔案附註		|:syn-file-remarks|
5.  定義語法			|:syn-define|
6.  :syntax 引數		|:syn-arguments|
7.  語法模式			|:syn-pattern|
8.  語法簇			|:syn-cluster|
9.  包含語法檔案		|:syn-include|
10. 同步			|:syn-sync|
11. 列出語法專案		|:syntax|
12. Highlight 命令		|:highlight|
13. 連結組			|:highlight-link|
14. 清理			|:syn-clear|
15. 高亮標籤			|tag-highlight|
16. 視窗區域性語法		|:ownsyntax|
17. 彩色 xterm			|xterm-color|
18. 語法太慢了			|:syntime|

{Vi 無此功能}

如果編譯時關閉了 |+syntax| 特性，就不會有語法高亮的功能。

==============================================================================
1. 快速入門						*:syn-qstart*

						*:syn-enable* *:syntax-enable*
這個命令開啟語法高亮: >

	:syntax enable

實際上，它只是執行如下命令 >
	:source $VIMRUNTIME/syntax/syntax.vim

如果沒有設定 VIM 環境變數，Vim 會試圖用其它方法找到該路徑 (見 |$VIMRUNTIME|)。
通常總能找到，如果不行，你可以自己設定 VIM 環境變數為存放 Vim 相關檔案所在的
目錄。例如，如果你的語法檔案放在 "/usr/vim/vim50/syntax" 目錄，設定
$VIMRUNTIME 為 "/usr/vim/vim50"。啟動 Vim 前，你必須在外殼上進行此設定。

							*:syn-on* *:syntax-on*
":syntax enable" 命令會保持你當前的色彩設定。這樣，不管在使用此命令的前後，你
都可以用 ":highlight" 命令設定你喜歡的顏色。如果你希望 Vim 用預設值覆蓋你自己
的，只要用: >
	:syntax on
<
					*:hi-normal* *:highlight-normal*
如果你執行在 GUI 環境裡，你可以這樣得到黑底白字: >
	:highlight Normal guibg=Black guifg=White
關於色彩終端，見 |:hi-normal-cterm|。
關於設定你自己的語法高亮色彩，見 |syncolor|。

注意: MS-DOS 和 Windows 上的語法檔案以 <CR><NL> 結束每一行。Unix 上則以 <NL>
結尾。這意味著你需要為自己的系統選擇合適的檔案。不過，在 MS-DOS 和 Windows
上，如果 'fileformats' 選項非空，會自動選擇正確的格式。

注意: 使用反轉視訊時 ("gvim -fg white -bg black")，'background' 的預設值直到
GUI 視窗開啟時才會設定。這發生在 |gvimrc| 的讀入之後，從而會使用錯誤的預設高
亮。要在開啟高亮前設定 'background' 的預設值，在 |gvimrc| 檔案裡包含 ":gui" 命
令: >

   :gui		" 開啟視窗並設定 'background' 的預設值
   :syntax on	" 啟動語法高亮，使用 'background' 來設定顏色

注意: 在 |gvimrc| 裡使用 ":gui" 意味著 "gvim -f" 不會在前臺開啟！這時，要使用
":gui -f"。

							*g:syntax_on*
你可以用這個命令切換語法的開啟/關閉 >
   :if exists("g:syntax_on") | syntax off | else | syntax enable | endif

要把它放到對映裡，你可以用: >
   :map <F7> :if exists("g:syntax_on") <Bar>
	\   syntax off <Bar>
	\ else <Bar>
	\   syntax enable <Bar>
	\ endif <CR>
[使用 |<>| 記法，按本義輸入]

細節:
":syntax" 命令是用執行檔案指令碼實現的。要了解它到底幹了什麼，察看以下檔案:
    命令		檔案 ~
    :syntax enable	$VIMRUNTIME/syntax/syntax.vim
    :syntax on		$VIMRUNTIME/syntax/syntax.vim
    :syntax manual	$VIMRUNTIME/syntax/manual.vim
    :syntax off		$VIMRUNTIME/syntax/nosyntax.vim
另見 |syntax-loading|。

注意: 如果顯示長行很慢而關閉語法高亮就能加快，考慮設定 'synmaxcol' 選項為一個
較小的值。

==============================================================================
2. 語法檔案							*:syn-files*

某個語言的語法和高亮命令通常存在一個語法檔案裡。命名慣例是: "{name}.vim"。其
中，{name} 是語言的名字或者縮寫 (一旦在 DOS 檔案系統上，要適用 8.3 字元的名字
限制)。
例如:
	c.vim		perl.vim	java.vim	html.vim
	cpp.vim		sh.vim		csh.vim

語法檔案可以包含任何 Ex 命令，就像 vimrc 檔案那樣。但應該只有適用於特定語言的
命令才放在裡面。如果該語言是另外一個語言的超集，它可以包含那個語言對應的檔案。
例如，cpp.vim 可以包含 c.vim 檔案: >
   :so $VIMRUNTIME/syntax/c.vim

.vim 檔案通常使用自動命令載入。例如: >
   :au Syntax c	    runtime! syntax/c.vim
   :au Syntax cpp   runtime! syntax/cpp.vim
這些命令通常出現在 $VIMRUNTIME/syntax/synload.vim 檔案裡。

如果你有多個檔案，可以用檔案型別作為目錄名。該目錄下的所有 "*.vim" 檔案都會被
使用。例如:
	~/.vim/after/syntax/c/one.vim
	~/.vim/after/syntax/c/two.vim


創 立 你 自 己 的 語 法 文 件				*mysyntaxfile*

一旦你創立自己的語法檔案，並且需要 Vim 在使用 ":syntax enable" 的時候自動呼叫
它們的時候，按如下操作進行:

1. 建立自己的使用者執行時目錄。通常，把它放在 'runtimepath' 選項的第一項。Unix
的例子: >
	mkdir ~/.vim

2. 在其中建立 "syntax" 目錄。Unix 上: >
	mkdir ~/.vim/syntax

3. 編寫 Vim 語法檔案。或者從 internet 下載。然後寫入你的 syntax 目錄。例如，對
於 "mine" 語言的語法: >
	:w ~/.vim/syntax/mine.vim

現在你可以手動啟動語法檔案: >
	:set syntax=mine
這時，你並不需要退出 Vim。

如果你想 Vim 也實現檔案型別的檢測，見 |new-filetype|。

如果你想為多個使用者設立系統，而不希望每個使用者增加相同的語法檔案的話，可以使用
'runtimepath' 裡的其它目錄。


添 加 到 已 存 在 的 語 法 文 件		*mysyntaxfile-add*

如果你對已有的語法檔案大體滿意，只需要增加或者修正一些高亮專案，執行以下步驟即
可:

1. 建立你的 'runtimepath' 裡的使用者目錄，見上。

2. 在那裡建立目錄 "after/syntax"。Unix 上: >
	mkdir ~/.vim/after
	mkdir ~/.vim/after/syntax

3. 編寫 Vim 指令碼，包含你希望使用的命令。例如，要在 C 語法裡改變顏色: >
	highlight cComment ctermfg=Green guifg=Green

4. 把該檔案寫道 "after/syntax" 目錄。使用該語法的名字，另加上 ".vim"。對於我們
的 C 語法: >
	:w ~/.vim/after/syntax/c.vim

這樣就行了。下一次你編輯 C 檔案時，Comment 色彩就不會一樣了。你甚至不需要重啟
Vim。


替 換 已 存 在 的 語 法 文 件			*mysyntaxfile-replace*

如果你不喜歡釋出的語法檔案版本，或者你下載了新版本。可以採用上述的
|mysyntaxfile| 相同的步驟。只要確保你寫的語法檔案在 'runtimepath' 較早的位置就
可以了。Vim 只會載入第一個找到的語法檔案，假定它是用來設定 b:current_syntax 的
那個檔案。


命 名 慣 例			    *group-name* *{group-name}* *E669* *W18*

高亮組名用於匹配相同型別事物的高亮專案。它們被連結到用於指定顏色的高亮組。語法
組名本身不指定任何顏色或屬性。

高亮或者語法組的名字必須由 ASCII 字母，數字和下劃線組成。如使用正規表示式表示:
"[a-zA-Z0-9_]*"。不過，使用其它字元時 Vim 不報錯。

要允許每個使用者選擇他自己喜歡的色彩系列，許多語言應該使用相同的高亮組名。以下是
建議的組名 (如果語法高亮能夠正確工作，你應該能看到實際的顏色，除了 "Ignore" 以
外):

	*Comment	v 任何註釋

	*Constant	v 任何常數
	 String		v 字串常數: "這是字串"
	 Character	v 字元常數: 'c'、'\n'
	 Number		v 數值常數: 234、0xff
	 Boolean	v 布林型常數: TRUE、false
	 Float		v 浮點常數: 2.3e10

	*Identifier	v 任何變數名
	 Function	v 函式名 (也包括: 類的方法名)

	*Statement	v 任何語句
	 Conditional	v if、then、else、endif、switch 等
	 Repeat		v for、do、while 等
	 Label		v case、default 等
	 Operator	v "sizeof"、"+"、"*" 等
	 Keyword	v 其它關鍵字
	 Exception	v try、catch、throw

	*PreProc	v 通用預處理命令
	 Include	v 預處理命令 #include
	 Define		v 預處理命令 #define
	 Macro		v 同 Define
	 PreCondit	v 預處理命令 #if、#else、#endif 等

	*Type		v int、long、char 等
	 StorageClass	v static、register、volatile 等
	 Structure	v struct、union、enum 等
	 Typedef	v typedef 定義

	*Special	v 任何特殊符號
	 SpecialChar	v 常數中的特殊字元
	 Tag		v 可以使用 CTRL-] 的專案
	 Delimiter	v 需要注意的字元
	 SpecialComment	v 註釋裡的特殊部分
	 Debug		v 除錯語句

	*Underlined	v 需要突出的文字，HTML 連結

	*Ignore		v 留空，被隱藏  |hl-Ignore|

	*Error		v 有錯的構造

	*Todo		v 需要特殊注意的部分；主要是關鍵字 TODO FIXME 和 XXX

* 標記的名字是主要組，其它是次要組。對主要組而言，"syntax.vim" 檔案包含預設的
高亮設定。次要組則連結到主要組。所以它們擁有相同的高亮設定。不過，你可以通過
":highlight" 命令在 "syntax.vim" 檔案之後改變所有組的預設值。

注意 高亮組的名字對大小寫不敏感。"String" 和 "string" 可用來表示相同的組。

以下名字是保留字，它們不應用作組名:
	NONE   ALL   ALLBUT   contains	 contained

							*hl-Ignore*
如果你使用 Ignore 組，也可以考慮使用隱藏機制。見 |conceal|。

==============================================================================
3. 語法載入過程						*syntax-loading*

這裡解釋命令 ":syntax enable" 執行的細節。Vim 初始化自身時，它尋找執行時檔案的
位置。其值用來設定這裡使用的變數 |$VIMRUNTIME|。

":syntax enable" 和 ":syntax on" 完成以下步驟:

    執行 $VIMRUNTIME/syntax/syntax.vim
    |
    +-	清除舊的語法: 執行 $VIMRUNTIME/syntax/nosyntax.vim
    |
    +-	先執行 'runtimepath' 裡的 syntax/synload.vim
    |	|
    |	+-  為語法高亮設定色彩。如果已經定義了色彩方案，使用 ":colors {name}"
    |   |   再次載入。不然，執行 ":runtime! syntax/syncolor.vim"。":syntax on"
    |   |   會覆蓋已有的顏色，而 ":syntax enable" 只會設定沒有設定過的組。
    |	|
    |	+-  設定 syntax 自動命令，以便在設定 'syntax' 選項時，自動載入合適的語
    |   |   法檔案。 *synload-1*
    |	|
    |	+-  通過 |mysyntaxfile| 變數，載入使用者可選的檔案。這只是為了和 Vim 5.x
    |   |   相容。 *synload-2*
    |
    +-	執行 ":filetype on"，後者又執行 ":runtime! filetype.vim"。它載入任何找
    |   到的 filetype.vim。其中，總會執行 $VIMRUNTIME/filetype.vim。後者執行:
    |	|
    |	+-  根據字尾名，安裝自動命令來設定 'filetype' 選項。這為已知的檔案型別
    |   |   建立了檔名和檔案型別的聯絡。 *synload-3*
    |	|
    |	+-  通過 *myfiletypefile* 變數，載入使用者可選的檔案。這只是為了和 Vim
    |   |   5.x 相容。 *synload-4*
    |	|
    |	+-  安裝自動命令，在沒有檢測到檔案型別時執行 scripts.vim 。
    |   |   *synload-5*
    |	|
    |	+-  執行 $VIMRUNTIME/menu.vim，設定 Syntax 選單。|menu.vim|
    |
    +-	安裝 FileType 自動命令，在檢測到檔案型別時，設定 'syntax' 選項。
    |   *synload-6*
    |
    +-	執行 syntax 自動命令，為每個已經載入的緩衝區啟動語法高亮。


載入檔案時，Vim 這樣查詢相關的語法檔案:

    檔案的載入啟用 BufReadPost 自動命令。
    |
    +-	如果和 |synload-3| 中的一個自動命令匹配 (已知的檔案型別) 或者
    |   |synload-4| (使用者的檔案型別)，'filetype' 選項設為檔案的所屬型別。
    |
    +-	如果檔案型別沒有找到，啟用 |synload-5| 中的自動命令，並在
    |   'runtimepath' 裡找尋 scripts.vim。其中，總是會執行
    |   $VIMRUNTIME/scripts.vim。後者執行以下步驟。
    |	|
    |	+-  通過 *myscriptsfile* 變數，載入使用者可選的檔案。這只是為了和 Vim
    |   |   5.x 相容。
    |	|
    |	+-  如果檔案型別仍然未知，檢查檔案的內容，並使用類似於
    |       "getline(1) =~ pattern" 的檢查確定檔案型別能否識別，並設定
    |       'filetype'。
    |
    +-	如果檔案型別被確定並且設定了 'filetype'，啟用 FileType 自動命令，見上
    |   面的 |synload-6|。根據確定的檔案型別設定 'syntax'。
    |
    +-	上面設定 'syntax' 選項的步驟啟用 |synload-1| (和 |synload-2|) 設定的自
    |   動命令。它會使用以下命令找到 'runtimepath' 裡的主語法檔案:
    |		runtime! syntax/<name>.vim
    |
    +-	啟用任何使用者安裝的 FileType 或 Syntax 自動命令。這可以用來為某項語法修
        正高亮方式。

==============================================================================
4. 語法檔案附註						*:syn-file-remarks*

						*b:current_syntax-variable*
根據當前啟用的是哪部語法，Vim 把載入的語法的名字儲存在 "b:current_syntax" 變數
裡。例如: >
   :au BufReadPost * if b:current_syntax == "csh"
   :au BufReadPost *   做一些事
   :au BufReadPost * endif


2HTML						*2html.vim* *convert-to-HTML*

它本身並不是語法檔案，只是一個把當前視窗轉換成 HTML 的指令碼。Vim 開啟一個新窗
口，在那裡它構造 HTML 檔案。

儲存結果檔案以後，你可以使用任何瀏覽器瀏覽。那裡的顏色應該和你在 Vim 裡看到的
一模一樣。|g:html_line_ids| 可使你通過在瀏覽器的位址列中 URL 尾部加入 (例如)
#L123 或 #123 來跳到指定行。|g:html_dynamic_folds| 則使你可以開啟或關閉 Vim 中
的摺疊。

你不應該設定 'filetype' 或 'syntax' 選項為 "2html"！執行此指令碼，以轉換當前文
件: >

	:runtime! syntax/2html.vim
<
許多變數可用來調整 2html.vim 的結果；見下。列出的開關選項可以通過顯式設定其值
來達到開啟和關閉的目的，也可以通過用 |:unlet| 刪除變數的方式來恢復其預設值。

評註:
- 一些真的很老的瀏覽器可能不會顯示背景色。
- 你可以在大多數瀏覽器裡列印檔案 (而且有顏色)！
- 本版本的 TOhtml 可以和舊版本的 Vim 共用，但某些功能，例如隱藏 (conceal) 支援
  不會工作，而對編譯時沒有加入 GUI 支援的舊版本，色彩也可能不對。

此處是一個如何在 Unix 外殼上給所有的 .c 和 .h 檔案執行此指令碼的例子: >
   for f in *.[ch]; do gvim -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" $f; done
<
					*g:html_start_line* *g:html_end_line*
要限制轉換的行範圍，給下面介紹的 |:TOhtml| 命令加上行範圍，或者設定
"g:html_start_line" 和 "g:html_end_line" 分別為要轉換的第一行和最後一行。例
如，要指定最近設定的可視區域: >

	:let g:html_start_line = line("'<")
	:let g:html_end_line = line("'>")
	:runtime! syntax/2html.vim
<
							*:TOhtml*
:[range]TOhtml		":TOhtml" 命令在一個標準外掛裡定義。該命令為你執行
			|2html.vim|。給出範圍時，此命令設定
			|g:html_start_line| 和 |g:html_end_line| 分別為範圍的
			開始和結束行。預設範圍是整個緩衝區。

			如果視窗處於比較模式，除非置位了
			|g:html_diff_one_file|，:TOhtml 會在生成的 HTML 裡把當
			前標籤頁裡所有參與比較的視窗並排放在一個 <table>
			元素裡。|g:html_line_ids| 還可以允許你跳到指定視窗的指
			定行，(例如) #W1L42 跳到首個參加比較的視窗的第 42 行，
			#W3L87 則是第三個視窗的第 87 行。

			示例: >

	:10,40TOhtml " 把第 10-40 行轉換為 html
	:'<,'>TOhtml " 轉換當前/最近的可視選擇
	:TOhtml      " 轉換整個緩衝區
<
							*g:html_diff_one_file*
預設: 0。
為 0 時，|:TOhtml| 會在生成的 HTML 裡把當前標籤頁裡所有參與比較的視窗並排放在
一個 <table> 元素裡。
為 1 時，只轉換當前的緩衝區。
示例: >

	let g:html_diff_one_file = 1
<
							 *g:html_whole_filler*
預設: 0。
為 0 時，如果 |g:html_diff_one_file| 為 1，連續多於三行的填充行顯示為三行，中
間行提示插入的總行數。
為 1 裡，顯示所有的插入行，這也是 |g:html_diff_one_file| 沒有置位時的行為。
>
    :let g:html_whole_filler = 1
<
				     *TOhtml-performance* *g:html_no_progress*
預設: 0。
為 0 時，2html.vim 轉換的每個主要步驟都會在狀態行上顯示進度條。
為 1 時，不顯示進度條。會有很不顯著的速度提高，但你無法估計轉換過程要花多長時
間；對大檔案而言可能會挺久的！
示例: >

	let g:html_no_progress = 1

通過指示 Vim 以非互動方式執行會得到更好的效率提高，因為不用在指令碼切換緩衝區和
視窗時花時間重畫螢幕，例如: >

  vim -E -s -c "let g:html_no_progress=1" -c "syntax on" -c "set ft=c" -c "runtime syntax/2html.vim" -cwqa myfile.c
<
注意 -s 標誌位停止 .vimrc 和任何外掛的載入，因此必須顯式執行/開啟影響 HTML
轉換的設定。詳見 |-E| 和 |-s-ex|。最好單獨建一個指令碼來代替這裡的 -c 命令，然後
用 -u 標誌位載入之，這樣就不用一個個列出要執行的命令了。

							 *g:html_number_lines*
預設: 當前的 'number' 設定。
為 0 時，生成的 HTML 裡顯示緩衝區文字時不帶行號。
為 1 時，生成的 HTML 里加入行號列，和 Vim 的行號列相同高亮 (|hl-LineNr|) 。
要強制給行編號，即使沒有置位 'number': >
   :let g:html_number_lines = 1
要強制關閉行號: >
   :let g:html_number_lines = 0
要回到預設情況，即使用 'number' 的設定，可刪除此變數: >
   :unlet g:html_number_lines
<
                                                             *g:html_line_ids*
預設: 1 如果 |g:html_number_lines| 置位，否則為 0。
為 1 時，為每個行號加上 HTML 的 id 屬性，或者如果行號不顯示，為同樣的目的加入
一個空的 <span> 。單個緩衝區的 HTML 頁面的 ID 屬性形如 L123，比較檢視的頁面則
形如 W2L123，可以用 ID 來跳轉到該行 (或比較檢視中某個視窗)。同時，加入
Javascript 程式碼，在跳到指定行之前開啟其所在的已關閉的動態摺疊
(|g:html_dynamic_folds|)。
Javascript 還可以讓你在 url 中省略視窗號或開頭的那個 L。
示例: >

	page.html#L123	跳轉到單個緩衝區檔案的第 123 行
	page.html#123	同上

	diff.html#W1L42	跳轉到比較的首個視窗的第 42 行
	diff.html#42	同上
<
							      *g:html_use_css*
預設: 1。
為 1 時，生成使用層疊樣式表 (CSS1) 的合法 HTML 4.01 檔案，所有的現代瀏覽器和
多數舊式的瀏覽器都支援 CSS1。
為 0 時，生成 <font> 標籤和類似的過時標記。不推薦，但對真的很老的瀏覽器、電郵
客戶端、論壇帖子和類似不支援基本 CSS 的情形，可能會更好些。
例如: >
   :let g:html_use_css = 0
<
						       *g:html_ignore_conceal*
預設: 0。
為 0 時，可隱藏文字被從 HTML 中去除，並取決於 'conceallevel' 的當前值，用
|:syn-cchar| 或 'listchars' 代替。
為 1 時，在生成的 HTML 中包括所有的緩衝區文字，即使是經過隱藏 (|conceal|)。

以下兩個命令的任何一個都可以確保緩衝區的所有文字都包含在生成的 HTML 裡 (除非有
摺疊的情況): >
   :let g:html_ignore_conceal = 1
   :setl conceallevel=0
<
						       *g:html_ignore_folding*
預設: 0。
為 0 時，關閉摺疊裡的實際文字被 Vim 顯示摺疊所用的文字 (|fold-foldtext|) 代
替。如果你還想允許在 HTML 中使用者可以擴充套件摺疊看到實際文字，就象 Vim 可以做的那
樣的話，另見 |g:html_dynamic_folds|。
為 1 時，在生成的 HTML 中包括所有的緩衝區文字；不管文字是否在摺疊中都一樣。此
時，|g:html_dynamic_folds| 無效。

以下兩個命令的任何一個都可以確保緩衝區的所有文字都包含在生成的 HTML 裡 (除非有
隱藏 (conceal) 的情況): >
   zR
   :let g:html_ignore_folding = 1
<
							*g:html_dynamic_folds*
預設: 0。
為 0 時，生成的 HTML 不包含關閉摺疊裡的文字。
為 1 時，生成 Javascript 以動態開啟摺疊並顯示其中的文字，如同 Vim 那樣。

設定此變數為 1 時，2html.vim 總是使用 CSS 生成樣式，不管 |g:html_use_css| 的設
置。

|g:html_ignore_folding| 置位時，忽略此變數。
>
   :let g:html_dynamic_folds = 1
<
							*g:html_no_foldcolumn*
預設: 0。
為 0 時，如果 |g:html_dynamic_folds| 為 1，生成摺疊列，如同 vim 的 foldcolumn
(|fold-foldcolumn|) 那樣，使用者點選該列時切換摺疊的開與關。
為 1 時，不生成摺疊列；如果置位了 |g:html_hover_unfold|，可以用滑鼠移到摺疊文
本來開啟摺疊。
>
   :let g:html_no_foldcolumn = 1
<
				*TOhtml-uncopyable-text* *g:html_prevent_copy*
預設: 空字串。
如果在瀏覽器中選中生成的 HTML 文件的全部文字並複製，此選項防止其中部分割槽域被複
制。此項功能用於保證使用者只複製-貼上原始的文字，而不包括生成內容顯示的摺疊列或
行號。可以這樣來指定不被複制的區域:
	f:	摺疊列
	n:	行號 (也包括摺疊文字中的)
	t:	摺疊文字
	d:	比較填充行

例如，要使摺疊列和行號不被複制: >
	:let g:html_prevent_copy = "fn"
<
此功能目前的實現方法是插入只讀的 <input> 元素來包圍不想複製的區域。這不總是適
用。若干理解 HTML 的應用還是會貼上 <input> 元素。但只接受平凡文字的貼上目標應
該都行。

							   *g:html_no_invalid*
預設: 0。
為 0 時，如 |g:html_prevent_copy| 非空，有意地給 <input> 元素插入一個非法的屬
性。這使更多的應用不會貼上這些 <input> 元素。特別地，Microsoft Word 不會貼上
有非法屬性的 <input> 元素。
為 1 時，不會有意插入非法的標記，生成的頁面總是合法的。不過，
|g:html_prevent_copy| 非空時，小心貼上到 Microsoft Word；一旦貼上，很難去掉這
些 <input> 元素。

							 *g:html_hover_unfold*
預設: 0。
為 0 時，開啟 2html.vim 用 |g:html_dynmaic_folds| 設定產生摺疊的唯一方法是點選
生成的摺疊列。
為 1 時，用 CSS 2.0 機制，使得使用者把滑鼠移到顯示的摺疊文字上時可以開啟摺疊。對
不想開啟 Javascript 但想看到摺疊文字的使用者會有用。

注意 舊版本的瀏覽器 (尤其是 Internet Explorer 6) 不支援該功能。我們生成 IE6 瀏
覽器特定的 HTML 標記，使之迴歸到普通的 CSS 1 程式碼，這樣摺疊還能在此瀏覽器下正
常顯示，但沒有摺疊列它們無法被開啟。
>
   :let g:html_hover_unfold = 1
<
							      *g:html_id_expr*
預設: ""
動態摺疊和行號的跳轉依賴於文件中生成的 ID 的唯一性。如果生成的 HTML 被複制到更
大的文件時，ID 的唯一性就很難保證了。設定 |g:html_id_expr| 可以指定一個表達
式，讓 Vim 用來生成唯一的字串，附加到給定文件中的每個 ID 之後，以保證生成的
完整 ID 即使和更大的 HTML 文件的其他內容合併時也保持唯一。例如，要給每個 ID 後
附加 _ 和緩衝區號: >

	:let g:html_id_expr = '"_".bufnr("%")'
<
要給每個 ID 號附加字串 "_mystring": >

	:let g:html_id_expr = '"_mystring"'
<
注意 轉換比較檢視到 HTML 時，只對比較中的首個視窗計算此表示式，計算結果會用於
所有的視窗。

					  *TOhtml-wrap-text* *g:html_pre_wrap*
預設: 當前 'wrap' 的設定。
為 0 時，如果 |g:html_no_pre| 為 0 或未設，生成的 HTML 中的文字在瀏覽器視窗
邊緣處不迴繞。
為 1 時，如果 |g:html_use_css| 為 1，使用 CSS 2.0 的 "white-space:pre-wrap"
值，使文字在瀏覽器視窗邊緣處迴繞。
要顯式打開回繞: >
   :let g:html_pre_wrap = 1
要關閉迴繞: >
   :let g:html_pre_wrap = 0
迴歸到預設值，由 'wrap' 設定值來決定迴繞與否: >
   :unlet g:html_pre_wrap
<
							       *g:html_no_pre*
預設: 0。
為 0 時，生成的 HTML 用 <pre>...</pre> 標籤來包圍緩衝區文字。連續空格的顯示如
同 Vim 那樣，無需特別標記，製表符也可以按本義使用 (見 |g:html_expand_tabs|)。
為 1 時 (不推薦)，使用普通的 <div> 代替 <pre> 標籤，用一串 "&nbsp;" 來顯示連續
的空格，<br> 用於結束每行。這是支援生成的 HTML 中文本回繞的另一個方法，此方法
和舊式的瀏覽器更相容，但 2html.vim 生成的頁面顯示效果與 Vim 的差別顯著。
>
   :let g:html_no_pre = 1
<
							  *g:html_expand_tabs*
預設: 1 如果 'tabstop' 為 8，'expandtab' 為 0，且生成的 HTML 不用摺疊列或行
	號；
      0 不然。
為 0 時，緩衝區文字中的 <Tab> 被合適數目的空格，或當 |g:html_no_pre| 為 1 時，
&nbsp；，所替代。
為 1 時，如果 |g:html_no_pre| 為 0 或未設，在生成的 HTML 中保留緩衝區文字中的
<Tab> 字元。這使得瀏覽器中複製貼上不會丟失原始文件中的實際空白。注意 除非按照
預設設定的那些條件，這會很容易打亂 HTML 中文字的對齊和縮排。

強制 |2html.vim| 保留 <Tab> 字元: >
   :let g:html_expand_tabs = 0

強制擴充套件製表符: >
   :let g:html_expand_tabs = 1
<
				    *TOhtml-encoding-detect* *TOhtml-encoding*
強烈建議用 |g:html_use_encoding| 來為任何要放到網頁伺服器上的內容指定編碼。

如果沒有指定編碼，|2html.vim| 使用 'fileencoding' 的當前值 (如設定) 或者
'encoding' 值的 IANA 的推薦名字來設定。
對某些 'buftype' 型別，總使用 'encoding'。會根據選中的文件編碼相應的設定
'fileencoding' 的值。

自動檢測適用於所有 |encoding-names| 指定的編碼，但 TOhtml 目前只自動使用那些廣
為瀏覽器支援的編碼，對預設不自動檢測的特定編碼，你可以強制其檢測 (見下面的選
項)。IANA 名字可見 http://www.iana.org/assignments/character-sets。

備註，預設所有 Unicode 編碼所生成的 HTML 會轉化為不帶 BOM 的 UTF-8，這是 W3C
建議的:

	http://www.w3.org/International/questions/qa-choosing-encodings
	http://www.w3.org/International/questions/qa-byte-order-mark

							 *g:html_use_encoding*
預設: 無，使用 'fileencoding' 的當前值的 IANA 名字，見上述。
要完全跳過自動字符集檢測，設定 g:html_use_encoding 為你要使用的字符集。強烈
建議對所有要放上網頁伺服器的內容設定此值為廣為支援的編碼，如 UTF-8: >
   :let g:html_use_encoding = "UTF-8"
如果不想產生指定字符集的 HTML 行，設定 g:html_use_encoding 為空字串 (_不_推
薦): >
   :let g:html_use_encoding = ""
要回到自動的機制，刪除 g:html_use_encoding 變數: >
   :unlet g:html_use_encoding
<
						    *g:html_encoding_override*
預設: 無，autoload/tohtml.vim 包含 |encoding-names| 中提到名字的編碼的轉換。
如果用 |g:html_use_encoding| 指定的編碼不在預設的轉換列表中，本選項可以使
|2html.vim| 檢測到正確的 'fileencoding'。

這是個由字符集到編碼的組對所構成的字典，它會替代 TOhtml 自動檢測所生成的相應組
對，或擴充新組對以支援新的字符集。

要檢測 HTML 字符集 "windows-1252" 對應的編碼為 "8bit-cp1252"，用: >
   :let g:html_encoding_override = {'windows-1252': '8bit-cp1252'}
<
						     *g:html_charset_override*
預設: 無，autoload/tohtml.vim 包含 |encoding-names| 中提到名字的和有廣泛瀏覽器
		支援的轉換。
本選項指定 |2html.vim| 不能自動檢測的 'fileencoding' 或 'encoding' 所對應的
HTML 字符集。也可用來覆蓋現有的編碼到字符集的組對。例如，
TOhtml 預設對所有 Unicode/UCS 編碼使用 UTF-8。要用 UTF-16 和 UTF-32 代替之，
用: >
   :let g:html_charset_override = {'ucs-4': 'UTF-32', 'utf-16': 'UTF-16'}

注意 UTF-32 或 UTF-16 編碼的文件和已知至少一個主要瀏覽器有相容問題。

								 *g:html_font*
預設: "monospace"
用 g:html_font 可以指定轉換後的文件使用的字型或字型集。如果本選項設為字串，
以單引號括起該值。如果本選項設為列表，以單引號括起每個列表專案，然後以逗號連線
列表。不管哪種方式，加入 "monospace" 作為後備的通用字型族名，然後把整個結果用
作 font family (用 CSS 時) 或 font face (不用 CSS 時)。例如: >

   " font-family: 'Consolas', monospace;
   :let g:html_font = "Consolas"

   " font-family: 'DejaVu Sans Mono', 'Consolas', monospace;
   :let g:html_font = ["DejaVu Sans Mono", "Consolas"]
<
			*convert-to-XML* *convert-to-XHTML* *g:html_use_xhtml*
預設: 0。
為 0 時，生成標準 HTML 4.01 (如有可能，strict)。
為 1 時，生成 XHTML 1.0 (XML 相容的 HTML)。
>
    :let g:html_use_xhtml = 1
<

ABEL						*abel.vim* *ft-abel-syntax*

ABEL 高亮設定提供一些使用者定義的選項。要開啟這些選項，給相應的選項設定任意值。
例如: >
	:let abel_obsolete_ok=1
可用 ":unlet" 關閉。例如: >
	:unlet abel_obsolete_ok

變數				高亮 ~
abel_obsolete_ok		廢棄的關鍵字接受為 statement，而非 error
abel_cpp_comments_illegal	不把 '//' 解釋為行內註釋的引導符


ADA

見 |ft-ada-syntax|


ANT						*ant.vim* *ft-ant-syntax*

ant 語法檔案預設提供了 javascript 和 python 的語法高亮。其他指令碼語言的語法高亮
可以通過 AntSyntaxScript() 函式安裝。它接受的第一個引數是標籤名，而第二個是腳
本語法檔名。例如: >

	:call AntSyntaxScript('perl', 'perl.vim')

會為下面的 ant 程式碼提供 Perl 的語法高亮 >

	<script language = 'perl'><![CDATA[
	    # 這裡的一切都作為 perl 指令碼高亮
	]]></script>

|mysyntaxfile-add| 說明如何永久的安裝指令碼語言。


APACHE						*apache.vim* *ft-apache-syntax*

Apache 語法檔案提供的語法高亮取決於 Apache HTTP 伺服器的版本，預設為 1.3.x。設
置 "apache_version" 為 Apache 的相應版本 (字串形式) 可以得到其它版本的高亮方
式。例如: >

	:let apache_version = "2.0"
<

		*asm.vim* *asmh8300.vim* *nasm.vim* *masm.vim* *asm68k*
ASSEMBLY	*ft-asm-syntax* *ft-asmh8300-syntax* *ft-nasm-syntax*
		*ft-masm-syntax* *ft-asm68k-syntax* *fasm.vim*

匹配 "*.i" 的可以是 Progress 或者彙編檔案。如果自動檢測對你不工作，或者你從來
不編輯 Progress，在你啟動的 vimrc 裡這麼用: >
   :let filetype_i = "asm"
把 "asm" 替換成你實際使用的組合語言。

許多型別的組合語言都使用相同的副檔名。因而，你或者需要自己選擇型別，或者在
彙編檔案裡增加使 Vim 能識別的行。目前，包含了以下的語法檔案:
	asm		GNU 彙編 (預設)
	asm68k		Motorola 680x0 彙編
	asmh8300	Hitachi H-8300 版本的 GNU 彙編
	ia64		Intel Itanium 64
	fasm		Flat 彙編 (http://flatassembler.net)
	masm		Microsoft 彙編 (可能適用於任何 80x86)
	nasm		Netwide 彙編
	tasm		Turbo 彙編 (提供到 Penitum 和 MMX 的 80x86 操作碼)
	pic		PIC 彙編 (目前支援 PIC16F84)

最靈活的方式是在你的彙編檔案里加上如下一行: >
	asmsyntax=nasm
把 "nasm" 換成實際的彙編語法的名字。該行必須是檔案頭五行中的一行。此文字前後不
能緊接著非空白的其它文字。注意 指定 asmsyntax=foo 等價於在 |modeline| 中設定
ft=foo，如果兩者有衝突，模式行的設定優先 (尤其，如果模式行上有 ft=asm，總是使
用 GNU 的語法高亮，而不管 asmsyntax 如何設定)。

語法型別可以為某個緩衝區定製。方法是設定 b:asmsyntax 變數: >
	:let b:asmsyntax = "nasm"

如果沒有設定 b:asmsyntax，不管是自動還是手動，就會使用全域性變數 asmsyntax 的
值。它可以看作是預設的組合語言: >
	:let asmsyntax = "nasm"

如果什麼都沒有定義，最後就假定是 "asm" 語法。


Netwide 彙編器 (nasm.vim) 可選高亮特性 ~

要開啟特性: >
	:let   {variable}=1|set syntax=nasm
要關閉特性: >
	:unlet {variable}  |set syntax=nasm

變數			高亮 ~
nasm_loose_syntax	非正式的分析器允許的語法不視為錯誤 (取決於分析器；不推
			薦)
nasm_ctx_outside_macro	巨集之外的上下文不視為錯誤
nasm_no_warn		潛在有危險的語法不視為 Todo 那樣的警告


ASPPERL 和 ASPVBS			*ft-aspperl-syntax* *ft-aspvbs-syntax*

*.asp 和 *.asa 檔案可以是 Perl 或者 Visual Basic 指令碼。因為很難檢測，你可以設
置兩個全域性變數，來告訴 Vim 你要用哪一個。Perl 指令碼可用: >
	:let g:filetype_asa = "aspperl"
	:let g:filetype_asp = "aspperl"
Visual Basic 可用: >
	:let g:filetype_asa = "aspvbs"
	:let g:filetype_asp = "aspvbs"


BAAN						    *baan.vim* *baan-syntax*

baan.vim 提供 BaanIV 到 SSA ERP LN 發行版的 BaanC 的語法支援，用於 3 GL 和 4
GL 程式設計。支援很多的標準巨集定義/常數。

如果你在某個 |.vimrc| 裡指定下面這行，不合編碼標準的一些特殊錯誤會被報告: >
	let baan_code_stds=1

*baan-folding*

使用下面提到的變數，可以在不同層次上開啟語法摺疊 (在 |.vimrc| 裡設定)。原始碼
塊和 SQL 上越複雜的摺疊越需要 CPU。

要允許摺疊並在函式級別上開啟摺疊: >
	let baan_fold=1
可以在原始碼塊級別上開啟摺疊，如 if、while、for，... 這裡開始/結束關鍵字之前的
縮排必須一致 (空格不等於製表)。 >
	let baan_fold_block=1
可以為內嵌的 SQL 塊開啟摺疊，如 SELECT、SELECTDO、SELECTEMPTY，... 這裡開始/結
束關鍵字之前的縮排必須一致 (空格不等於製表)。 >
	let baan_fold_sql=1
<
注意: 程式碼塊級別的摺疊可能產生許多小的摺疊。建議在 .vimrc 裡用 |:set| 設定選項
'foldminlines' 和 'foldnestmax'，在 .../after/syntax/baan.vim 裡用 |:setlocal|
設定也可以 (見 |after-directory|)。例如: >
	set foldminlines=5
	set foldnestmax=6


BASIC			*basic.vim* *vb.vim* *ft-basic-syntax* *ft-vb-syntax*

Visual Basic 和 "普通的" Basic 都使用副檔名 ".bas"。要檢測使用的是哪一個，Vim
在檔案的頭五行檢查字串 "VB_Name"。如果沒找到，檔案型別將是 "basic"，不然就是
"vb"。帶 ".frm" 副檔名的檔案總被視為 Visual Basic 型別。


C							*c.vim* *ft-c-syntax*

C 高亮的一些設定是可選的。要開啟，給相應的變數賦任何值。例如: >
	:let c_comment_strings = 1
可用 ":unlet" 關閉。例如: >
	:unlet c_comment_strings

變數			高亮 ~
*c_gnu*			GNU gcc 專用的專案
*c_comment_strings*	註釋裡的字串和數字
*c_space_errors*	行尾的空格和 <Tab> 之前的空格
*c_no_trail_space_error* ... 不包括行尾的空格
*c_no_tab_space_error*	 ... 不包括 <Tab> 之前的空格
*c_no_bracket_error*	不高亮 {}；如果在 [] 裡面視為錯誤
*c_no_curly_error*	不高亮 {}；如果在 [] 和 () 裡面視為錯誤；
				除了出現在首列的 { 和 } 以外
				預設高亮它們，否則找不到缺失的 ")"。
*c_curly_error*		高亮丟失的 }；強制從檔案首開始同步，因而可能會較慢
*c_no_ansi*		不使用 ANSI 標準型別和常數
*c_ansi_typedefs*	 ... 但使用 ANSI 標準型別
*c_ansi_constants*	 ... 但使用 ANSI 標準常數
*c_no_utf*		不高亮字串裡的 \u 和 \U
*c_syntax_for_h*	*.h 檔案使用 C 語法，而不是 C++ 的，用 objc 語法，而不
			是 objcpp 的
*c_no_if0*		不把 "#if 0" 塊高亮為註釋
*c_no_cformat*		不高亮字串裡的 %-格式
*c_no_c99*		不高亮 C99 標準的專案
*c_no_c11*		不高亮 C11 標準的專案
*c_no_bsd*		不高亮 BSD 特定型別

如果 'foldmethod' 設為 "syntax"，那麼 /* */ 註釋和 { } 塊成為摺疊。如果你不想
讓註釋成為摺疊: >
	:let c_no_comment_fold = 1
"#if 0" 塊也被摺疊，除非: >
	:let c_no_if0_fold = 1

如果你注意到往回滾動時，高亮出現問題，但 CTRL-L 重畫又可以修正的話，嘗試設定
"c_minlines" 內部變數為較大的值: >
	:let c_minlines = 100
這使得語法同步在第一個顯示行之前的 100 行開始。預設值為 50 (如果設定了
c_no_if0，則為 15)。使用較大的值的缺點是重畫會變慢。

如果使用 "#if 0" / "#endif" 風格的註釋高亮，注意它只適用於 "#if 0" 出現在視窗
頂部往上不超過 "c_minlines" 行的場合。如果你有很長的 "#if 0" 構造，它不會被正
確地高亮。

要匹配註釋裡的附加專案，使用 cCommentGroup 簇。例如: >
   :au Syntax c call MyCadd()
   :function MyCadd()
   :  syn keyword cMyItem contained Ni
   :  syn cluster cCommentGroup add=cMyItem
   :  hi link cMyItem Title
   :endfun

ANSI 常數使用 "cConstant" 組高亮。這包括 "NULL"、"SIG_IGN" 還有其它。但不包
括，比如說，"TRUE"。因為它不在 ANSI 標準裡。如果你覺得弄不清楚，刪除 cConstant
高亮: >
	:hi link cConstant NONE

如果你看到 '{' 和 '}' 被高亮為錯誤，而實際並非如此的時候，復位 cErrInParen 和
cErrInBracket 的高亮。

如果想在你的 C 檔案裡使用摺疊，可以在 'runtimpath' 的 "after" 目錄下的一個檔案
里加上這些行。Unix 上，這會是 ~/.vim/after/syntax/c.vim. >
    syn sync fromstart
    set foldmethod=syntax

CH						*ch.vim* *ft-ch-syntax*

C/C++ 直譯器。Ch 的語法高亮和 C 相似，它基於 C 語法檔案。|c.vim| 說明所有 C 可
用的設定。

設定此變數，告訴 Vim 用 Ch 語法來處理 *.h 檔案，而不是 C 或 C++ 語法: >
	:let ch_syntax_for_h = 1


CHILL						*chill.vim* *ft-chill-syntax*

Chill 語法高亮和 C 類似。可用的設定見 |c.vim|。此外，還有:

chill_space_errors	類似於 c_space_errors
chill_comment_string	類似於 c_comment_strings
chill_minlines		類似於 c_minlines


CHANGELOG				*changelog.vim* *ft-changelog-syntax*

ChangeLog 支援行首的空格高亮。如果你不喜歡，在你的 .vimrc 里加入下行: >
	let g:changelog_spacing_errors = 0
下次你編輯 changelog 檔案時，就會應用。你也可以使用
"b:changelog_spacing_errors" 來為每個緩衝區分別設定 (在載入語法檔案以前)。

你可以改變現在使用的高亮，例如把空格標記為錯誤: >
	:hi link ChangelogError Error
或者避免高亮: >
	:hi link ChangelogError NONE
這些會立即生效。


CLOJURE							*ft-clojure-syntax*

預設的語法組可以用 *g:clojure_syntax_keywords* 和 *b:clojure_syntax_keywords*
變數進行擴充套件。其值應為語法組名對映到定製識別符號的 |List| 的 |Dictionary|:
>
	let g:clojure_syntax_keywords = {
	    \ 'clojureMacro': ["defproject", "defcustom"],
	    \ 'clojureFunc': ["string/join", "string/replace"]
	    \ }
<
合法的語法組名可參見 Closure 語法指令碼。

如果置位 |buffer-variable| *b:clojure_syntax_without_core_keywords* ，只匹配語
言常數和特殊表示式。

置位 *g:clojure_fold* 允許通過語法引擎來摺疊 Clojure 程式碼。任何超過一行的
list、 vector 或 map 會使用標準 Vim |fold-commands| 進行摺疊。

請 注意 此選項和重定義括號語法區域的指令碼不相容，如 rainbox-parentheses 外掛。

預設關閉此選項。
>
	" 預設
	let g:clojure_fold = 0
<

COBOL						*cobol.vim* *ft-cobol-syntax*

COBOL 高亮對傳統的程式碼和新開發的程式碼有不同的需要。這來自於需求的差異 (維護還是
開發)，以及一些其它因素。要使用傳統程式碼的高亮，在 .vimrc 里加上此行: >
	:let cobol_legacy_code = 1
要再次關閉，可用: >
	:unlet cobol_legacy_code


COLD FUSION			*coldfusion.vim* *ft-coldfusion-syntax*

ColdFusion 有 HTML 註釋的自己的版本。要開啟 ColdFusion 風格的註釋高亮，在你的
啟動檔案里加上此行: >

	:let html_wrong_comments = 1

ColdFusion 語法檔案是基於 HTML 的語法檔案的。


CPP						*cpp.vim* *ft-cpp-syntax*

多數設定同 |ft-c-syntax|。

變數			特色 ~
cpp_no_cpp11		不高亮 C++11 標準專案
cpp_no_cpp14		不高亮 C++14 標準專案


CSH						*csh.vim* *ft-csh-syntax*

這裡討論名為 "csh" 的外殼。注意 有的系統實際使用的是 tcsh。

要檢測一個檔案是 csh 還是 tcsh 異常困難。有的系統把 /bin/csh 符號連結到
/bin/tcsh，使得區別 csh 和 tcsh 幾乎不可能。如果 VIM 猜錯，你可以自己設定
"filetype_csh" 變數。要使用 csh:  *g:filetype_csh*
>
	:let g:filetype_csh = "csh"

要使用 tcsh: >

	:let g:filetype_csh = "tcsh"

帶 tcsh 副檔名的指令碼或者 tcsh 的標準檔名 (.tcshrc、tcsh.tcshrc、tcsh.login)
會使用檔案型別 tcsh。其它的 tcsh/csh 指令碼也會被識別為 tcsh，_除非_存在
"filetype_csh" 變數。如果存在 "filetype_csh" 變數，檔案型別會設為該變數的值。


CYNLIB						*cynlib.vim* *ft-cynlib-syntax*

Cynlib 檔案是使用 Cynlib 類庫的 C++ 檔案。它們使用 C++ 來為硬體建模和模擬。通
常 Cynlib 檔案使用 .cc 或 .cpp 副檔名，這使得它們和普通的 C++ 檔案難以區別。因
而，要使用 Cynlib 為 .cc 檔案高亮，在你的 .vimrc 檔案里加上此行: >

	:let cynlib_cyntax_for_cc=1

cpp 檔案也類似 (該副檔名通常為 Windows 使用) >

	:let cynlib_cyntax_for_cpp=1

要再次關閉，可用: >

	:unlet cynlib_cyntax_for_cc
	:unlet cynlib_cyntax_for_cpp
<

CWEB						*cweb.vim* *ft-cweb-syntax*

匹配 "*.w" 的檔案可為 Progress 檔案或者 cweb 檔案。如果自動檢測不行，或者你從
來不編輯 Progress，可以在啟動的 vimrc 檔案裡用: >
   :let filetype_w = "cweb"


DESKTOP					   *desktop.vim* *ft-desktop-syntax*

該語法檔案的主要目的是根據 freedesktop.org 標準:
http://standards.freedesktop.org/desktop-entry-spec/latest/
來高亮 .desktop 和 .directory 檔案。但實際上，幾乎沒人完全實現了標準。所以，它
實際被用來高亮所有的 Unix ini 檔案。如果你希望強制使用符合標準的嚴格的高亮方
式，在 vimrc 檔案放上: >
	:let enforce_freedesktop_standard = 1


DIFF							*diff.vim*

比較高亮通常會尋找翻譯的頭部。如果檔案裡有很長的行，這會變慢。這樣關閉翻譯: >

	:let diff_translations = 0

另見 |diff-slow|。


DIRCOLORS			       *dircolors.vim* *ft-dircolors-syntax*

dircolors 工具的高亮定義有一個選項。它的存在是為了和 Slackware GNU/Linux 釋出
版本里的該命令相容。它增加了一些多數版本忽略的關鍵字。在 Slackware 系統中，該
工具接受這些關鍵字並在處理中應用。要允許使用 Slackware 關鍵字，在你的啟動檔案
里加入如下一行: >
	let dircolors_is_slackware = 1


DOCBOOK					*docbk.vim* *ft-docbk-syntax* *docbook*
DOCBOOK XML				*docbkxml.vim* *ft-docbkxml-syntax*
DOCBOOK SGML				*docbksgml.vim* *ft-docbksgml-syntax*

有兩種型別的 DocBook 檔案: SGML 和 XML。要指定使用那種型別，需要設定
"b:docbk_type" 變數。如果 Vim 能夠識別，它會自動設定該變數。如果 Vim 猜不到，
預設的型別是 XML。
你可以手動設定: >
	:let docbk_type = "sgml"
或者: >
	:let docbk_type = "xml"
你需要在載入語法檔案前作如此設定，這有點複雜。
更簡單的方法是設定檔案型別為 "docbkxml" 或 "docbksgml": >
	:set filetype=docbksgml
或: >
	:set filetype=docbkxml

可以指定 DocBook 版本: >
	:let docbk_ver = 3
如無指定假定為 4。

DOSBATCH				*dosbatch.vim* *ft-dosbatch-syntax*

DOS 批處理檔案的高亮有一個選項。它和 Windows 2000 的命令直譯器的新擴充套件有關，可
以通過 dosbatch_cmdextversion 變數控制。Windows NT 上，它應該取值為 1，Windows
2000 應該為 2。下面這行可以選擇你想要的版本: >

   :let dosbatch_cmdextversion = 1

如果沒有定義該變數，預設設為 2，以支援 Windows 2000 版本。

第二個選項控制 *.btm 檔案是否被識別為 "dosbatch" 型別 (MS-DOS 批處理檔案) 或
"btm" 型別 (4DOS 批處理檔案)。預設使用後者。下行可以讓你選擇前者: >

   :let g:dosbatch_syntax_for_btm = 1

如果此變數無定義或為零，選擇 btm 語法。



DOXYGEN						*doxygen.vim* *doxygen-syntax*

Doxygen 使用特殊的文件格式生成程式碼文件 (和 Javadoc 類似)。本語法指令碼為 c、
cpp、idl 和 php 檔案加入 Doxygen 的高亮，Java 應該也能用。

有幾個辦法可以開啟 Doxygen 格式。首先，在檔案的模式行上可以給 syntax 加入
".doxygen"，進行顯式設定。示例: >
	:set syntax=c.doxygen
或 >
	// vim:syntax=c.doxygen

對於 C、C++、C#、IDL 和 PHP 檔案，也可以設定全域性或區域性於緩衝區變數
load_doxygen_syntax 來自動完成這個操作。在 .vimrc 里加上 >
	:let g:load_doxygen_syntax=1

有一些變數影響語法高亮，它們大多和非標準的高亮選項有關。

變數				預設	效果 ~
g:doxygen_enhanced_color
g:doxygen_enhanced_colour	0	Doxygen 註釋使用非標準的高亮。

doxygen_my_rendering		0	關閉 HTML 粗體、斜體和
					html_my_rendering 下劃線的高亮。

doxygen_javadoc_autobrief	1	如果為 0，關閉 Javadoc autobrief 色彩
					高亮。

doxygen_end_punctuation		'[.]'	匹配 brief 結束標點的正規表示式。

還有一些高亮組值得提提，你可以對它們進行配置。

高亮				效果 ~
doxygenErrorComment		如果 code、verbatim 或 dot 段裡丟失標點，註釋
				尾部的顏色。
doxygenLinkError		如果丟失 \link 段的 \endlink，註釋尾部的顏色。


DTD						*dtd.vim* *ft-dtd-syntax*

DTD 語法高亮預設是大小寫敏感的。如果不想如此，在你的啟動檔案里加入以下一行: >

	:let dtd_ignore_case=1

DTD 語法會把未知的標籤高亮為錯誤。如果這很討厭，在執行 dtd.vim 語法檔案之前，
可以用以下設定來關閉: >

	:let dtd_no_tag_errors=1

引數實體 (parameter entity) 的名字使用 'Type' 高亮組高亮，標點和 '%' 使用
'Comment'。引數實體的例項使用 'Constant' 高亮組高亮，定界符 % 和 ; 則使用
'Type' 高亮組。以下設定可以關閉這些設定: >

	:let dtd_no_param_entities=1

xml.vim 也包含了 DTD 語法檔案，用以高亮內嵌的 dtd。

EIFFEL					*eiffel.vim* *ft-eiffel-syntax*

儘管 Eiffel 不是大小寫敏感的，它的風格指南鼓勵如此，而且語法高亮檔案也鼓勵這樣
使用。這使得同一類名的高亮可以不同。如果你想關閉大小寫敏感的語法高亮，在啟動文
件里加上這行: >

	:let eiffel_ignore_case=1

大小寫對類名和註釋裡的 TODO 標記仍然有影響。

相反，要更嚴格的檢查，加入以下諸行之一: >

	:let eiffel_strict=1
	:let eiffel_pedantic=1

設定 eiffel_strict 只會捕獲以下五個預定義的單詞錯誤的大小寫: "Current"、
"Void"、"Result"、"Precursor" 和 "NONE"。用於警告它們可能被不小心用作特性或類
名。

設定 eiffel_pedantic 會非常嚴格地遵循 Eiffel 風格指南 (例如，大小寫字母的任意
混合和其它過時的大寫關鍵字的方法都會被捕獲)。

如果希望使用小寫版本的 "Current"、"Void"、"Result" 和 "Precursor"，可以用 >

	:let eiffel_lower_case_predef=1

而不用完全關閉大小寫敏感的高亮方式。

一些編譯器裡已經能夠實驗性地處理 ISE 推薦的新的建立語法，要開啟此語法: >

	:let eiffel_ise=1

最後，有的供應商支援十六進位制的常數。在你的啟動檔案里加上這行就可以處理它們 >

	:let eiffel_hex_constants=1


EUPHORIA	    *euphoria3.vim* *euphoria4.vim* *ft-euphoria-syntax*

Euphoria 有兩種語法高亮檔案。一種用於 Euphoria 3.1.1 版本，這是預設的語法高亮
檔案，另一種用於 Euphoria 4.0.5 或更新版本。

Euphoria 3.1.1 版本 (http://www.rapideuphoria.com/) 對開發 DOS 平臺上的應用還
是需要的，Euphoria 4 (http://www.openeuphoria.org/) 不再支援。

以下副檔名被自動識別為 Euphoria 檔案型別:

	*.e, *.eu, *.ew, *.ex, *.exu, *.exw
	*.E, *.EU, *.EW, *.EX, *.EXU, *.EXW

要選擇 Euphoria 的語法檔案，同時也自動識別 *.e 和 *.E 副檔名為 Euphoria 文
件型別，在啟動檔案里加入以下一行: >

	:let filetype_euphoria="euphoria3"

	或

	:let filetype_euphoria="euphoria4"


ERLANG						*erlang.vim* *ft-erlang-syntax*

Erlang 是 Ericsson 開發的函式程式語言。下列檔案字尾被識別為 Erlang 檔案: erl、
hrl、yaws。

預設開啟 BIF (內建函式) 的高亮。要關閉之，在 .vimrc 里加上: >

	:let g:erlang_highlight_bifs = 0

要開啟某些特殊原子 (atom) 的高亮，在 .vimrc 里加上: >

	:let g:erlang_highlight_special_atoms = 1


FLEXWIKI				*flexwiki.vim* *ft-flexwiki-syntax*

FlexWiki 是基於 ASP.NET 的 wiki 包，從 http://www.flexwiki.com 可以獲得。
備註: 此網站已不可用，Wikipedia 指出開發已在 2009 年停止。

多數常用的 FlexWiki 語法元素都提供了語法高亮。本檔案型別外掛指令碼設定了若干區域性
於緩衝區的選項，使 FlexWiki 頁面的編輯更加便捷。因為 FlexWiki 把換行符看成新段
落的開始，所以本外掛設定 'tw'=0 (無限行長)，置位 'wrap' (迴繞長行而不使用水平
滾動)，也置位 'linebreak' (在 'breakat' 包含的字元而不是在螢幕最後一個字元上回
繞)，等等。本外掛也包含了一些鍵盤對映，但它們預設是關閉的。

如果你開啟鍵盤對映，"j" 和 "k" 和游標鍵就會在顯示行間上下移動。為此，在 .vimrc
里加入: >
	:let flexwiki_maps = 1


FORM						*form.vim* *ft-form-syntax*

FORM 檔案裡的語法元素的色彩方案使用預設模式: Conditional、Number、Statement、
Comment、PreProc、Type 和 String。它遵循 1991 年版荷蘭 CAN 組織
J.A.M. Vermaseren 編著的語言說明書 'Symbolic Manipulation with FORM'。

如果你想自己增加對預設顏色的修改，需要重新定義以下語法組:

    - formConditional
    - formNumber
    - formStatement
    - formHeaderStatement
    - formComment
    - formPreProc
    - formDirective
    - formType
    - formString

注意 預設，form.vim 語法檔案使用相同的語法組裡實現 FORM 前處理器命令和指令。

預定義的 FORM 增強色彩模式可以用來區別頭部語句和 FORM 程式本體的語句。要啟用此
模式，在你的 vimrc 檔案裡定義以下變數 >

	:let form_enhanced_color=1

在深色 gvim 顯示中，增強模式也利用了附加的色彩特性。這裡，語句
(formStatement) 使用 LightYellow 而不是 Yellow。而條件句 (formConditional) 使
用 LightBlue，以達到更好的區分度。


FORTRAN					*fortran.vim* *ft-fortran-syntax*

預設高亮方式和方言 ~
預設使用適合 Fortran 2008 的高亮方式。這樣的選擇應該適用於絕大多數的使用者，因為
Fortran 2008 幾乎是以前所有版本的超集 (Fortran 2003、95、90 和 77)。

Fortran 原始碼形式 ~
Fortran 程式碼可以使用固定寬度的原始碼，也可以使用自由形式。注意 如果形式設定錯
誤，語法高亮也不會正確。

建立新的 Fortran 檔案時，語法指令碼假定使用的是固定寬度的原始碼。如果你總是使用
自由形式，那麼在你的 .vimrc 裡，把 >
    :let fortran_free_source=1
放在 :syntax 命令前。如果你總是使用固定寬度格式，那麼在你的 .vimrc 裡，把 >
    :let fortran_fixed_source=1
放在 .syntax 命令前。

如果以非標準的形式讓原始碼的格式取決於副檔名，那麼最方便的方法是在
ftplugin 檔案裡設定 fortran_free_source。關於 ftplugin 檔案的更多資訊，見
|ftplugin|。注意，要使之工作，你需要在 .vimrc 檔案的 "syntax on" 命令之前加上
"filetype plugin indent on" 命令。

編輯已有的 Fortran 檔案時，如果定義了 fortran_free_source 變數，語法指令碼假定使
用自由形式，如果定義了 fortran_fixed_source 變數，則假定使用固定寬度形式。如果
兩者都沒有，語法指令碼檢驗通用於 ifort、gfortran、Cray、NAG 和 PathScale 編譯器
慣例的副檔名 (.f、.for、.f77 為固定寬度，.f90、.f95、.f03、.f08 為自由形
式)。如果都不行，指令碼再檢查檔案的頭 500 行的頭 5 列。如果沒有發現自由形式的跡
象，那麼假定檔案為固定寬度形式的原始檔。這個演算法應該在絕大多數情況下適用。有的
情況下，比如檔案的開始有 500 行或更多完整行的註釋，該指令碼也許會錯誤地認為該
Fortran 程式碼使用的是固定寬度形式。如果此種情況真的發生，只要在前 500 行的頭 5
列裡的任何地方加上一個非註釋的語句，然後儲存 (:w) 並重新讀入 (:e!) 檔案就可以
了。

Fortran 檔案裡的製表鍵 ~
Fortran 標準不識別製表鍵。在固定寬度格式的 Fortran 原始碼裡，製表不是一個好主
意，因為需要固定的列邊界。因此，製表被識別為錯誤。不過，有的程式設計師喜歡使用制
表。如果你的 Fortran 檔案裡包含製表，那麼需要在 .vimrc 裡使用這樣的命令來設定
變數 fortran_have_tabs >
    :let fortran_have_tabs=1
並把它放在 :syntax 命令之前。不幸的是，製表的使用意味著語法檔案無法識別不正確
的邊界。

Fortran 檔案的語法摺疊 ~
如果你希望使用 foldmethod=syntax，那麼你需要先使用命令設定變數 fortran_fold >
    :let fortran_fold=1
來指示語法指令碼為程式單元定義摺疊區域。程式單元 (program unit) 包括程式語句開始
的主程式、子例程、函式子程式、塊資料子程式、介面塊和模組。如果你也使用如下命令
設定變數 fortran_fold_conditionals >
    :let fortran_fold_conditionals=1
那麼也會為 do 迴圈、if 塊和 select case 構造定義摺疊區域。如果你同時使用如下命
令設定變數 fortran_fold_multilinecomments >
    :let fortran_fold_multilinecomments=1
那麼還會為三行或更多連續的註釋定義摺疊區域。注意 定義摺疊區域會使大檔案變慢。

如果設定了 fortran_fold 和可能的 fortran_fold_conditionals 與/或
fortran_fold_multilinecomments，vim 會在你使用 foldmethod=syntax 時摺疊檔案。
兩個程式單元之間的註釋或空行不會被摺疊，因為它們不被視作任何一個程式單元的一部
分。

更精確的 Fortran 語法 ~
如果使用如下命令設定變數 fortran_more_precise >
    :let fortran_more_precise=1
那麼語法高亮會更精確，但也更慢。特別是，能夠識別 do、goto 和算術 if 語句使用的
語句標籤，還有 do、if、select、或 forall 構造結尾的構造名。

非預設的 Fortran 方言 ~
本語法指令碼支援兩種 Fortran 方言: f08 和 F。預設高亮方式 (f08) 基本令人滿意。一
些 2008 標準宣告過時或刪除的傳統結構被高亮為 todo 專案。

如果你使用 F，設定合適的方言的優點包括，F 排除的傳統特性會被高亮為 todo 專案；
還有，總是假定使用自由形式的源程式。

有幾個方式選擇方言。如果你所有的 Fortran 檔案使用相同的方言，在你的 .vimrc 文
件裡 syntax 命令之前設定 fortran_dialect。可以接受的 fortran_dialect 的值是大
小寫敏感的，而且必須是 "f08" 或 "F"。不合法的 fortran_dialect 的值被忽略。

如果原始碼的格式取決於副檔名，那麼最方便的方法是在 ftplugin 檔案裡設定一個
緩衝區區域性變數。關於 ftplugin 檔案的詳情，見 |ftplugin|。例如，如果你使用 .f90
副檔名的所有 Fortran 檔案都使用 F 子集，那麼在你的 ftplugin 檔案裡應該包含程式碼
>
    let s:extfname = expand("%:e")
    if s:extfname ==? "f90"
	let b:fortran_dialect="F"
    else
	unlet! b:fortran_dialect
    endif
<
注意 只有在你的 .vimrc 檔案的 "syntax on" 命令前加上了
"filetype plugin indent on" 命令，才能使這段程式碼工作。

如果副檔名還不能唯一確定方言，那麼你需要更精細的控制。可以為每個檔案定製方
言。方法是在檔案的頭三行內加上指令 "fortran_dialect=xx" (其中 xx=F 或 f08)。例
如，你較老的 .f 檔案可能用傳統程式碼編寫，但較新的那些可能使用 F，那麼你需要在後
者每個檔案的頭三行內加上以下形式的 Fortran 註釋，以便標識 >
  ! fortran_dialect=F

使用較早的語法版本的使用者，可能會設定 fortran_dialet 為現已廢棄的值 "f77"、
"f90"、"f95" 或 "elf"。這些設定都會被悄悄地當作 "f08" 處理。"elf" 使用者可能想
試試 "F" 也許會更好。

syntax/fortran.vim 指令碼包含內嵌註釋，說明如何為某些行加上註釋和/或去掉註釋來
(a) 識別一些非標準廠商自定的內在過程 (intrinsic)，(b) 使某些 2008 標準刪除或廢
止的功能不採用 todo 專案高亮。

限制 ~
括號檢查不能發現過少的閉括號。也不能識別 Hollerith 字串。有些關鍵字可能高亮
不正確，因為 Fortran90 沒有保留字。

更多關於 Fortran 的資訊可見 |ft-fortran-indent| 和 |ft-fortran-plugin|。


FVWM 配 置 文 件 				*fvwm.vim* *ft-fvwm-syntax*

要使得 Vim 識別不符合模式 *fvwmrc* 或 *fvwm2rc* 的 Fvwm 配置檔案，你需要在你
myfiletypes.vim 檔案裡放入附加適合你係統的模式。對於這些模式，你需要設定變數
"b:fvwm_version" 為 Fvwm 的主版本號，同時設定 'filetype' 選項為 fvwm。

例如，要使 Vim 識別 /etc/X11/fvwm2/ 裡的所有檔案為 Fvwm2 的配置檔案，可以這樣
設定: >

  :au! BufNewFile,BufRead /etc/X11/fvwm2/*  let b:fvwm_version = 2 |
					 \ set filetype=fvwm

如果你想讓 Vim 高亮所有的合法顏色名，告訴它如何找到在你的系統上顏色資料庫
(rgb.txt)。設定 "rgb_file" 指向該檔案就可以了。假如你的顏色資料庫在
/usr/X11/lib/X11/，加入下行 >

	:let rgb_file = "/usr/X11/lib/X11/rgb.txt"

到你的 .vimrc 檔案裡。


GSP						*gsp.vim* *ft-gsp-syntax*

GSP 頁面的預設色彩風格由 |html.vim| 定義，而 Java 程式碼 (在 Java 標籤裡或反引號
之間的內含程式碼) 的顏色由 |java.vim| 定義。 |html.vim| 裡定義的以下 HTML 組在這
裡被重新定義，以配合高亮的內含 (inline) Java 程式碼:

    htmlString
    htmlValue
    htmlEndTag
    htmlTag
    htmlTagN

多數你看到內含 Java 程式碼的地方，高亮應該沒問題，但在一些特殊情況下可能有問題。
要加入其它可包含內含 Java 程式碼而高亮不正確的 HTML 組，只要從 |html.vim| 裡把你
想要的行復製出來，並在 contains 子句里加上 gspJava 就可以了。

反引號裡的內含 Java 使用 htmlError 組高亮，使之更易看清。


GROFF						*groff.vim* *ft-groff-syntax*

groff 語法檔案是 |nroff.vim| 的包裝，見該標題下的說明參閱使用和配置的示例。提
供這個包裝的目的是通過 |modeline| 或個人的檔案型別檔案 (見 |filetype.txt|) 來
設定檔案型別，從而設定 groff 專用的語法擴充套件。


HASKELL			     *haskell.vim* *lhaskell.vim* *ft-haskell-syntax*

Haskell 語法檔案支援普通的 Haskell 程式碼和文學的 (literate) Haskell 程式碼，後者
包括 Bird 風格和 Tex 風格。Haskell 語法高亮也能高亮 C 預處理指令。

如果你想高亮定界符 (適用於淺色背景)，在 .vimrc 里加上: >
	:let hs_highlight_delimiters = 1
要把 True 和 False 識別為關鍵字而不是普通的識別符號，加上: >
	:let hs_highlight_boolean = 1
要把基本型別的名字識別為關鍵字: >
	:let hs_highlight_types = 1
要把更多相對常用的型別識別為關鍵字: >
	:let hs_highlight_more_types = 1
如果想高亮除錯函式的名字，在你的 .vimrc 里加上: >
	:let hs_highlight_debug = 1

Haskell 語法高亮也高亮 C 預處理指令，但非法的 # 開始的指令被標記為錯誤。這和
Haskell 的操作符語法有衝突，因為它們可能會用 # 開始。如果你想高亮這些為操作符
而不是錯誤，在 .vimrc 里加入: >
	:let hs_allow_hash_operator = 1

文學的 Haskell 程式碼的語法高亮會試圖自動猜測你的文學 Haskell 程式碼是否包含 Tex
標記，並相應地高亮 Tex 構造或什麼也不做。要在全域性改變此行為，在你的 .vimrc 文
件裡放上 >
	:let lhs_markup = none
就可完全關閉高亮。或者 >
	:let lhs_markup = tex
強制使用 Tex 標記風格的高亮。更靈活的方法是使用該變數的區域性於緩衝區的版本，例
如 >
	:let b:lhs_markup = tex
會強制為特定的緩衝區使用 TeX 高亮。必須在該緩衝區開啟語法高亮或者載入檔案前設
置。


HTML						*html.vim* *ft-html-syntax*

HTML 檔案裡，標籤的色彩方案工作方式如下。

開放標籤的 <> 和關閉標籤的 </> 的顏色不同。這是有意的！開放標籤使用 'Function'
色，而關閉標籤使用 'Type' 色 (察看 syntax.vim 瞭解它們是如何為你定義的)。

已知的標籤名使用 C 語句 (Statement) 的色彩。未知的標籤名分別和相應的 <> 或 </>
顏色相同，以便糾錯。

注意 這同樣適用於引數 (或屬性) 名。已知的屬性名和未知的顏色不同。

一些 HTML 標籤用於改變文字的顯示。html.vim 語法色彩檔案識別以下的標籤，並相應
地改變普通文字的顯示方式: <B> <I> <U> <EM> <STRONG> (<EM> 是 <I> 的別名，而
<STRONG> 是 <B> 的別名)，<H1> - <H6>，<HEAD>，<TITLE> 和 <A> (<A> 必須在作為鏈
接，即包含了 href，才會如此。如 <A href="somefile.html">)。

如果你想改變文字顯示的方式，必須重定義以下的語法組:

    - htmlBold
    - htmlBoldUnderline
    - htmlBoldUnderlineItalic
    - htmlUnderline
    - htmlUnderlineItalic
    - htmlItalic
    - htmlTitle 設定標題
    - htmlH1 - htmlH6 設定標題頭部 (header) 的文字

要使得重定義能夠工作，你必須重定義所有的組，最後兩組 (htmlTitle 和 htmlH[1-6]
可選) 可以除外。在你的 vimrc (這是根據初始化時讀入檔案的順序) 裡定義下面的變數
>
	:let html_my_rendering=1

要想看一個例子，下載 http://www.fleiner.com/vim/download.html 的 mysyntax.vim
檔案。

在你的 vimrc 檔案里加上這行，可以遮蔽這種顯示方式: >
	:let html_no_rendering=1

HTML 註釋相當特別 (詳情見 HTML 的參考文件)，此語法高亮方案會高亮所有的錯誤。不
過，如果你喜歡不太正確 (以 <!-- 開始並以 --> 結束) 的風格，可以定義 >
	:let html_wrong_comments=1

HTML 文件的內嵌 (embedded) JavaScript 和 Visual Basic 使用 'Special' 高亮，而
其中的語句、註釋、字串等使用標準的程式語言的顏色。注意 現在只支援 JavaScript
和 Visual Basic，還沒有加入其它的指令碼語言。

內嵌和內含 (inline) 的層疊樣式表 (CSS) 也被高亮。

有多種 html 前處理器語言，html.vim 的編寫方式使得包含它非常容易。要想這麼做，
只要在相應語言的語法高亮檔案里加入如下兩行 (該例子來自 asp.vim 檔案) 就可以了:

    runtime! syntax/html.vim
    syn cluster htmlPreproc add=asp

現在你只需要把所有包含預處理語言的區域專案加到 htmlPreproc 簇裡就可以了。


HTML/OS (Aestiva 提供)				*htmlos.vim* *ft-htmlos-syntax*

HTML/OS 的色彩高亮方案工作方式如下:

預設為函式和變數名使用相同的顏色，因為 VIM 並不為 Function 和 Identifier 指定
不同的顏色。要改變這一點 (如果你希望函式名能用不同的顏色加以識別的話，建議使
用)，你需要在 ~/.vimrc 里加入下行: >
  :hi Function term=underline cterm=bold ctermfg=LightGray

當然如果你願意，ctermfg 可以使用別的顏色。

HTML/OS 碰到的另一個問題是沒有特殊的指示 HTML/OS 編碼的檔案型別。開啟檔案並用
下面的方法開啟 HTML/OS 語法，你就可以改變這一點: >
  :set syntax=htmlos

最後要提醒一下，啟動 HTML/OS 程式碼塊的開啟和關閉字元序列分別是 << 或 [[ 和 >>
或 ]]。


IA64				*ia64.vim* *intel-itanium* *ft-ia64-syntax*

為 Intel Itanium 64 組合語言提供高亮。|asm.vim| 說明如何識別該檔案型別。

要識別 *.inc 檔案為 IA64，在你的 .vimrc 檔案里加入這行: >
	:let g:filetype_inc = "ia64"


INFORM						*inform.vim* *ft-inform-syntax*

Inform 高亮包含 Inform 庫提供的符號，因為多數程式大量使用它們。如果不希望高亮
這些庫裡的符號，在你的 vim 啟動檔案里加入: >
	:let inform_highlight_simple=1

預設假定 Inform 程式面向 Z 機器。並適當地高亮 Z 機器的組合語言符號。如果期望程
序面向 Glulx/Glk 環境，你需要在啟動檔案的序列中加入: >
	:let inform_highlight_glulx=1

這樣就只高亮 Glulx 操作碼，並把 glk() 加到高亮的系統函式集合裡。

Inform 編譯器遇到特定已廢棄的關鍵字時，會標記它們為錯誤。通常，Vim 也把這些關
鍵字標為錯誤。如果不想高亮這些錯誤，你必須在啟動檔案的序列中加入: >
	:let inform_suppress_obsolete=1

預設的高亮設定符合編譯器版本 6.30 和庫版本 6.11 的語言特性。如果你使用較老的
Inform 開發環境，可能需要在啟動檔案的序列中加入: >
	:let inform_highlight_old=1

IDL							*idl.vim* *idl-syntax*

IDL (Interface Definition Language，介面定義語言) 檔案用於定義 RFC 呼叫。
Microsoft 的領地裡也用來定義 COM 介面和呼叫。

IDL 的結構足夠簡單，所以可以分析完整語法，而不需要一些啟發式的猜測。結果很大，
甚至可能有些重複工作，但看來能用了。

這裡有一些 Microsft 的 idl 檔案擴充套件。有些可以通過 idl_no_ms_extensions 關閉。

更復雜的擴充套件可以通過定義 idl_no_extensions 來關閉。

變數				效果 ~

idl_no_ms_extensions		關閉一些 Microsoft 專用的擴充套件
idl_no_extensions		關閉複雜擴充套件
idlsyntax_showerror		顯示 IDL 錯誤 (可能過於侵略性，但很有用)
idlsyntax_showerror_soft	使預設的錯誤顏色柔和一些


JAVA						*java.vim* *ft-java-syntax*

java.vim 語法高亮檔案提供若干選項:

在 Java 1.0.2 裡，小括號裡不可能有大括號，所以這被標識為錯誤。但從 Java 1.1 開
始，這是合法的 (無名類的使用)，因而它不再標為錯誤。如果你喜歡舊的方式，在 vim
啟動檔案里加入下行: >
	:let java_mark_braces_in_parens_as_errors=1

所有 java.lang.* 的識別符號在所有的類裡都是可見的。要高亮它們，可用: >
	:let java_highlight_java_lang_ids=1

如果你從 http://www.fleiner.com/vim/download.html 下載 javaid.vim 指令碼，你也可
以高亮大多數標準 java 包裡的識別符號。
如果你只想高亮特定包裡的識別符號，比如說 java.io，可以用: >
	:let java_highlight_java_io=1
察看 javaid.vim 檔案，可以得到它支援的所有包的列表。

函式名不會高亮，因為找到函式的方法取決於你如何寫 Java 程式碼。語法檔案知道兩種可
以高亮函式的方法:

如果你的函式定義總是使用一個製表、8 個空格或者 2 個空格的縮排，可以設定 >
	:let java_highlight_functions="indent"
不過，如果你遵循 Java 指南里函式和類的命名規則 (關於大小寫)，就可以用 >
	:let java_highlight_functions="style"
如果兩個選項都不合適，但你仍然期望高亮函式宣告，修改 java.vim 裡的定義或者建立
你自己的 java.vim。你自己的版本應該包含原來的版本，並增加高亮函式的程式碼。

Java 1.1 裡，只應該用函式 System.out.println() 和 System.err.println() 來進行
除錯。所以你可以用不同的方式高亮除錯語句。要這麼做，你必須在啟動檔案里加上以下
定義: >
	:let java_highlight_debug=1
結果那些語句會被高亮為 'Special' 字元序列。如果你喜歡用不同的方式分別高亮，必
須為以下各組定義新的高亮:
    Debug、DebugSpecial、DebugString、DebugBoolean、DebugType
它們分別用來高亮語句本身，除錯字串裡的特殊字元、字串、布林常量和型別
(this，super)。我本人喜歡給語句設定別的背景。

Javadoc 是一個程式，它接受特殊的 Java 程式檔案裡的註釋，並建立 HTML 頁面。標準
的配置會以類似於 HTML 檔案 (見 |html.vim|) 方式高亮該 HTML 程式碼，你甚至可以在
程式碼里加入 Javascript 和 CSS (見下)。但有四處不同:
  1. 標題 (第一個後面有若干空白跟隨的 '.' 或第一個 '@' 之前的所有字元) 使用不
     同的顏色 (要改變其顏色，修改 CommentTitle 組)。
  2. 文字使用 'Comment' 高亮。
  3. HTML 註釋使用 'Special' 高亮。
  4. 特殊的 Javadoc 標籤 (@see、@param、...) 用 Special 高亮。 而 ( @see、
     @param、@exception 的)引數則使用 Function 高亮。
要關閉該特性，在你的啟動檔案里加入該行: >
	:let java_ignore_javadoc=1

如果你使用上述的特殊 Javadoc 註釋高亮方式，你也可以開啟 Javascript、Visual
Basic 指令碼和內嵌 CSS (樣式表) 的特殊高亮。只有在你實際有包含 Javascript 或內
嵌 CSS 的 Javadoc 註釋時，這才有意義。要使用的選項分別是 >
	:let java_javascript=1
	:let java_css=1
	:let java_vb=1

要以不同的顏色高亮巢狀的括號，分別定義 javaParen、javaParen1 和 javaParen2 的
顏色。比如用 >
	:hi link javaParen Comment
或 >
	:hi javaParen ctermfg=blue guifg=#0000ff

如果你注意到往回滾動時，高亮出現問題，但 CTRL-L 重畫又可以修正的話，嘗試設定
"java_minlines" 內部變數為較大的值: >
	:let java_minlines = 50
這使得語法同步在第一個顯示行之前的 50 行開始。預設值為 10。使用較大的值的缺點
是重畫會變慢。


LACE						*lace.vim* *ft-lace-syntax*

Lace (Language for Assembly of Classes in Eiffel，Eiffel 類整合語言) 對大小寫
不敏感，但風格指南不是這麼建議的。如果你喜歡對大小寫不敏感的高亮，在啟動檔案裡
定義 vim 變數 'lace_case_insensitive': >
	:let lace_case_insensitive=1


LEX						*lex.vim* *ft-lex-syntax*

Lex 使用強力攻擊 (brute-force) 的方式進行同步，因為 "^%%$" 段定界符沒有提供任
何關於後續段的提示。因而，如果使用者有同步問題的話 (比如使用很大的 lex 檔案)，
他/她可以嘗試改變  >
	:syn sync minlines=300
的值。


LIFELINES				*lifelines.vim* *ft-lifelines-syntax*

要把廢棄函式高亮為錯誤，在 .vimrc 中加入: >

	:let g:lifelines_deprecated = 1
<

LISP						*lisp.vim* *ft-lisp-syntax*

Lisp 語法高亮提供兩個選項: >

	g:lisp_instring : 如果存在，那麼 "(...)" 字串會被高亮，就像字串裡
			  的內容是 Lisp 程式碼一樣。對 AutoLisp 有用。
	g:lisp_rainbow  : 如果存在且非零，那麼不同的括號層次產生不同的高亮。
<
g:lisp_rainbow 選項為小括號和反引號提供 10 層不同的色彩。因為色彩層次的數量關
系，不同於非 rainbow (彩虹) 方式，rainbow 模式直接使用 ctermfg 和 guifg 指定高
亮色彩，而回避了標準的使用高亮組的色彩方案控制。實際使用的高亮值仍然取決於深/
淺設定 (見 |'bg'|)。


LITE						*lite.vim* *ft-lite-syntax*

lite 語法高亮有兩個選項。

如果你喜歡字串裡的 SQL 語法高亮，使用: >

	:let lite_sql_query = 1

同步的預設 minlines 為 100。如果你喜歡別的值，可以把 "lite_minlines" 設為你想
要的值。例如: >

	:let lite_minlines = 200


LPC						*lpc.vim* *ft-lpc-syntax*

LPC 代表一種簡單又節省記憶體的語言: Lars Pensj| C。LPC 的檔名通常是 *.c。把這
些檔案識別為 LPC 會惹惱那些只用 C 程式的使用者。如果你想使用 Vim 的 LPC 語法，在
你的 .vimrc 檔案裡設定變數: >

	:let lpc_syntax_for_c = 1

如果這對某些特殊的 C 或 LPC 檔案不能工作，用模式行。在 LPC 檔案裡:

	// vim:set ft=lpc:

對於被識別為 LPC 的 C 檔案:

	// vim:set ft=c:

如果你不想設定此變數，在_每個_ LPC 檔案裡使用模式行。

LPC 有若干實現，我們打算支援最常用的實現。這裡預設的 LPC 語法基於 MudOS 系列。
對於 MudOS v22 和以前的版本。你應該關閉合適的修飾符，它也會把 v22 之後的新的
efuns 認定為非法。如果你使用最新的 MudOS 版本，不要設定該變數: >

	:let lpc_pre_v22 = 1

對於 LpMud 3.2 系列的 LPC: >

	:let lpc_compat_32 = 1

對於 LPC4 系列的 LPC: >

	:let lpc_use_lpc4_syntax = 1

對於 uLPC 系列的 LPC:
uLPC 是為 Pike 開發的，所以你應該使用 Pike 的語法，而且原始檔應該是 *.pike。


LUA						*lua.vim* *ft-lua-syntax*

Lua 語法檔案可用於 Lua 4.0、5.0、5.1 或 5.2 (5.2 是預設)。用全域性變數
lua_version 和 lua_subversion 可以選擇其中一個版本。例如，如果要啟用 Lua 5.1
高亮，設定變數如下: >

	:let lua_version = 5
	:let lua_subversion = 1


MAIL						*mail.vim* *ft-mail.vim*

Vim 高亮 email 的所有標準元素 (信頭、簽名、引用文字和 URL / email 地址)。要符
合標準的習慣，簽名應該以 "--" 開頭，跟隨可選的若干空格並以回車結束的一行開始。

Vim 把 ']'、'}'、'|'、'>' 或者有 '>' 跟隨的單詞開始的行高亮為引用文字。不過，
只有在引用文字用 '>' 的方式引用 (後面可跟一個可選的空格)，Vim 才把把該文本里的
信頭和簽名高亮為引用文字。

mail.vim 預設從第一個顯示行之前的 100 行開始同步語法。如果你的機器很慢，而且通
常處理的 email 的信頭不長，你可以把它設為較小的值: >

    :let mail_minlines = 30


MAKE						*make.vim* *ft-make-syntax*

Makefile 裡，命令通常被高亮以便你發現錯誤。不過，如果你覺得顏色太多了，可以這
樣關閉此特性: >

	:let make_no_commands = 1


MAPLE						*maple.vim* *ft-maple-syntax*

Waterloo Maple Inc 的 Maple V 支援符號代數。該語言支援很多函式包，使用者可以選擇
性地裝載。如果使用者願意，可以高亮 Maple V release 4 提供的標準包函式。使用者可以
在 .vimrc 檔案里加入: >

	:let mvpkg_all= 1

來高亮所有的包裡的函式。使用者也可以通過從下表選擇變數/包來挑選一個子集，並在
.vimrc 檔案裡 (在執行 $VIMRUNTIME/syntax/syntax.vim 之前) 設定挑選的變數為 1
就可以了。

			Maple V 包函式選擇器表 >
  mv_DEtools	 mv_genfunc	mv_networks	mv_process
  mv_Galois	 mv_geometry	mv_numapprox	mv_simplex
  mv_GaussInt	 mv_grobner	mv_numtheory	mv_stats
  mv_LREtools	 mv_group	mv_orthopoly	mv_student
  mv_combinat	 mv_inttrans	mv_padic	mv_sumtools
  mv_combstruct	 mv_liesymm	mv_plots	mv_tensor
  mv_difforms	 mv_linalg	mv_plottools	mv_totorder
  mv_finance	 mv_logic	mv_powseries


MATHEMATICA		*mma.vim* *ft-mma-syntax* *ft-mathematica-syntax*

自動假設空白的 *.m 檔案為 Matlab 檔案，除非你在 .vimrc 裡指定了: >

	let filetype_m = "mma"


MOO						*moo.vim* *ft-moo-syntax*

如果你在表示式裡使用 C 風格的註釋但發現它影響了高亮，可以嘗試使用擴充套件的 (會變
慢！) C 風格註釋的匹配: >

	:let moo_extended_cstyle_comments = 1

要關閉字串裡的代詞替換 (pronoun substitution) 模式高亮: >

	:let moo_no_pronoun_sub = 1

要關閉正規表示式 '%|' 操作符和字串裡匹配的 '%(' 和 '%)' 所用的高亮: >

	:let moo_no_regexp = 1

可以識別不匹配的雙引號並高亮為錯誤: >

	:let moo_unmatched_quotes = 1

要高亮內建的屬性 (.name、.location、.programmer 等): >

	:let moo_builtin_properties = 1

可以識別未知的內建函式並高亮為錯誤。如果你使用該選項，應該把自己的擴充套件加到
mooKnownBuiltinFunction 組裡。要開啟該選項: >

	:let moo_unknown_builtin_functions = 1

把 sprintf() 加到已知內建函式列表的例子: >

	:syn keyword mooKnownBuiltinFunction sprintf contained


MSQL						*msql.vim* *ft-msql-syntax*

msql 語法高亮有兩個選項。

如過你希望高亮字串裡的 SQL 語法，使用: >

	:let msql_sql_query = 1

同步的 minlines 預設為 100。如果你喜歡別的值，可以設定 "msql_minlines" 為你所
希望的值。例如: >

	:let msql_minlines = 200


NCF						*ncf.vim* *ft-ncf-syntax*

NCF 語法高亮有一個選項。

如果你想把不能識別的 (依據 ncf.vim) 語句高亮為錯誤，使用: >

	:let ncf_highlight_unknowns = 1

如果你不想高亮它們為錯誤，留著該變數不設定就可以了。


NROFF						*nroff.vim* *ft-nroff-syntax*

nroff 語法檔案可直接用於 AT&T n/troff 而無需修改。如果要使用 GNU groff，你需要
在使用之前啟用語法檔案裡的一些附加特性。

例如，Linux 和 BSD 的釋出版本使用 groff 作為預設的文字處理包。要啟用 groff
附加的語法高亮特性，在你的啟動檔案里加入以下選項: >

  :let b:nroff_is_groff = 1

Groff 和老的 AT&T n/troff 不同，後者還可以在 Solaris 找到。Groff 巨集和請求名可
以超過 2 個字元，而且有語言基本命令之外的擴充套件。例如，AT&T troff 裡你可以用請求
\(yr 得到 2 位數的年份。groff 裡為了照顧相容性，可以使用相同的請求，你也可以直
接使用 groff 本身的巨集: \[year]。巨集請求可以超過 2 個字元，比如，GNU mm 接受
".VERBON" 和 ".VERBOFF" 請求，以建立 verbatim (不作轉換的) 環境。

要得到 g/troff 能給出的最好的輸出，需要遵循一些關於空格和標點的簡單的規則。

1. 不要在行尾留空白。

2. 在句尾的句號、感嘆號等之後留且只留一個空格。

3. 由於下面的原因，最好在所有的句號之後立即回車。

這些不尋常的提示的背後原因是，如果你不遵循上面的這些規則，g/n/troff 使用的換行
演算法很容易弄錯。

和 TeX 不同，troff 逐行而不是逐段填充文字。此外，它沒有 glue (可伸縮的距離) 或
stretch 的概念，所有的水平和垂直空白輸入都直接成為輸出。

因此你必須小心，不要在句子之間留下比你在最終文件想要的更多的空白。因此，通常在
每個標點符號之後都立即插入一個回車。如果你想要最終處理過的文字 "對齊"，需要在
輸入文本里維持常規的空間。要把行尾的空格和標點之後兩個或更多的空格標為錯誤，可
用: >

  :let nroff_space_errors = 1

另一個檢測額外的空格和其它錯誤的技術會影響你檔案的正確排版。這個方法是在你的配
置檔案裡定義語法組 "nroffDefinition" 和 "nroffDefSpecial" 顯眼的高亮定義。例
如: >

  hi def nroffDefinition term=italic cterm=italic gui=reverse
  hi def nroffDefSpecial term=italic,bold cterm=italic,bold
			 \ gui=reverse,bold

如果你想像段標記符那樣方便地瀏覽原始檔裡的預處理專案，可以在 .vimrc 檔案裡啟用
以下選項: >

	let b:preprocs_as_sections = 1

還有，語法檔案為 ms 包裡設定帶縮排的 (exdented) 段落巨集 (.XP) 增加了一個附加的
段標記符。

最後，有一個 |groff.vim| 語法檔案，可以基於每個檔案或，預設情況下，在全域性開啟
groff 的語法高亮。


OCAML						*ocaml.vim* *ft-ocaml-syntax*

OCaml 語法檔案處理帶以下字尾的檔案: .ml、.mli、.mll 和 .mly。設定以下變數 >

	:let ocaml_revised = 1

你就可以切換標準的 OCaml 語法為 camlp4 前處理器支援的改進的語法。設定變數 >

	:let ocaml_noend_error = 1

防止把 "end" 高亮為錯誤，這可用於源程式包含很長的結構而 Vim 不再能保持同步的場
合。


PAPP						*papp.vim* *ft-papp-syntax*

PApp 語法檔案處理 .papp 檔案和，在一定程度上，.pxml 和 .pxsl 檔案。它們都是
perl / xml / html / 其它格式 的混合，並使用 xml 作為頂層的檔案格式。預設，所有
phtml 和 pxml 段裡的內容都被處理為包含內嵌前處理器命令的字串。如果你在啟動文
件裡設定變數: >

	:let papp_include_html=1

它就會試圖語法高亮 pthml 段裡的 html 程式碼，但這相對較慢，而且對於有效的編輯未
免色彩太鮮豔了些 ;)

可以在 http://papp.plan9.de 找到最新的 papp.vim 語法檔案的版本。


PASCAL						*pascal.vim* *ft-pascal-syntax*

匹配 "*.p" 的檔案可以是 Progress 或者 Pascal 的。如果自動檢測對你不適用，或者
你從來不編輯 Progress，在啟動 vimrc 里加入: >

   :let filetype_p = "pascal"

Pascal 語法檔案被擴充套件，以支援 Turbo Pascal、Free Pascal 編譯器和 GNU Pascal 編
譯器的一些擴充套件。也支援 Delphi 的關鍵字。預設開啟 Turbo Pascal 7.0 特性。如果你
只想使用標準的 Pascal 關鍵字，在你的啟動檔案里加入下行: >

   :let pascal_traditional=1

要開啟 Delphi 專用的構造 (比如單行註釋、關鍵字、等等): >

   :let pascal_delphi=1


pascal_symbol_operator 選項控制符號 (symbol) 操作符，如 +、* 等，是否使用
Operator 的色彩高亮。要給符號的操作符加上顏色，在你的啟動檔案里加入下行: >

   :let pascal_symbol_operator=1

有些函式預設是高亮的。要關閉: >

   :let pascal_no_functions=1

另外，一些編譯器有專門的變數。除了 pascal_delphi 以外，還有 pascal_gpc 和
pascal_fpc。預設試圖匹配 Turbo Pascal 的擴充套件。 >

   :let pascal_gpc=1

或 >

   :let pascal_fpc=1

要確保字串在一行內定義，你可以定義 pascal_one_line_string 變數。 >

   :let pascal_one_line_string=1

如果你不喜歡 <Tab> 字元，你可以設定 pascal_no_tabs 變數。製表會被高亮為
Error。 >

   :let pascal_no_tabs=1



PERL						*perl.vim* *ft-perl-syntax*

perl 的語法高亮有一些可用的選項。

現在預設開啟內建 POD 的高亮。如果不希望因 Perl 檔案內嵌的 POD 高亮增加複雜度，
可以把 'perl_include_pod'  選項設為 0: >

	:let perl_include_pod = 0

要減低分析的複雜度 (同時提高了效率)，你可以關閉變數名和內容的分析過程的兩個元
素。

要使變數和函式名裡對包的引用與名字的其它部分不區別顯示 (如 '$PkgName::VarName'
裡的 'PkgName::'): >

	:let perl_no_scope_in_variables = 1

(Vim 6.x 裡相反，用 "perl_want_scope_in_variables" 開啟區別顯示。)

如果你不想分析複雜的結構，比如 '@{${"foo"}}': >

	:let perl_no_extended_vars = 1

(Vim 6.x 裡相反，用 "perl_extended_vars" 開啟此項分析。)

你可以改變顏色字串。預設，字串和 qq 等變形會象下面第一行那樣高亮。如果你設
置了變數 perl_string_as_statement，那麼就像下面第二行那樣高亮。
   "hello world!"; qq|hello world|;
   ^^^^^^^^^^^^^^NN^^^^^^^^^^^^^^^N	  (unlet perl_string_as_statement)
   S^^^^^^^^^^^^SNNSSS^^^^^^^^^^^SN	  (let perl_string_as_statement)

(^ = perlString、S = perlStatement、N = 什麼都沒有)

同步有三個選項。前兩個關掉一些啟用同步的方法，而只有在無法正確工作的時候你才需
要它們。比如，如果滾動時突然全屏的顏色發生改變，那麼你應該嘗試改變並關閉其中的
某一個。如果你可以發現哪一行導致這種錯誤，請告訴我。

大致上，其中一個在 "^\s*sub\s*" 上啟用，另一個則在 "^[$@%]" 上。 >

	:let perl_no_sync_on_sub
	:let perl_no_sync_on_global_var

下面，你還可以設定 VIM 往前找語法高亮的起始點的最大距離。 >

	:let perl_sync_dist = 100

如果你想要在 perl 裡使用摺疊，設定 perl_fold: >

	:let perl_fold = 1

如果你想摺疊 if 等語句塊，設定如下: >

	:let perl_fold_blocks = 1

'perl_fold' 置位時，預設摺疊例程。如果不想要，可以設定
'perl_nofold_subs': >

	:let perl_nofold_subs = 1

預設不折疊無名例程；可以用 'perl_fold_anonymous_subs' 開啟之: >

	:let perl_fold_anonymous_subs = 1

'perl_fold' 置位時，預設對包摺疊。如果不想要，可以設定
'perl_nofold_packages': >

	:let perl_nofold_packages = 1

PHP3 和 PHP4		*php.vim* *php3.vim* *ft-php-syntax* *ft-php3-syntax*

[注意: 以前這被稱為 "php3"，但因為現在這也支援 php4，它被改名為 "php"]

php 的語法高亮支援以下選項。

如果你喜歡字串裡的 SQL 語法高亮: >

  let php_sql_query = 1

要高亮 Baselib 方法: >

  let php_baselib = 1

開啟字串裡的 HTML 語法高亮: >

  let php_htmlInStrings = 1

使用舊的色彩風格: >

  let php_oldStyle = 1

開啟 ASP 風格的短標籤的高亮: >

  let php_asp_tags = 1

關閉短標籤: >

  let php_noShortTags = 1

要高亮外層 ] 或 ) 的錯誤: >

  let php_parent_error_close = 1

要在有開啟的 ( 和 [ 但沒有相應的結束符號的情況下跳過 php 結束標籤: >

  let php_parent_error_open = 1

開啟類和函式的摺疊: >

  let php_folding = 1

選擇同步方法: >

  let php_sync_method = x

x = -1 使得同步以搜尋方法進行 (預設)，
x > 0 使得同步至少往回 x 行，
x = 0 使得同步從頭開始。


PLAINTEX				*plaintex.vim* *ft-plaintex-syntax*

TeX 是排版語言，而 plaintex 是代表 Tex 的 "平凡" 變種的檔案型別。如果你想
*.tex 檔案被識別為平凡 TeX，見 |ft-tex-plugin|。

此語法檔案有以下選項 >

	let g:plaintex_delimiters = 1

如果你想高亮方括號 "[]" 和大括號 "{}" 的話。


PPWIZARD					*ppwiz.vim* *ft-ppwiz-syntax*

PPWizard 是 HTML 和 OS/2 INF 檔案的前處理器。

該語法檔案有如下選項:

- ppwiz_highlight_defs : 決定 PPWizard 定義的高亮模式。可能值是

  ppwiz_highlight_defs = 1 : PPWizard #define 語句保留其內容的色彩 (比如，
    PPWizard 的巨集和變數)

  ppwiz_highlight_defs = 2 : 前處理器 #define 和 #evaluate 語句使用單色顯示，
    除了續行符以外

  預設 ppwiz_highlight_defs 的設定為 1。

- ppwiz_with_html : 如果該值為 1 (預設)，高亮按本義出現的 HTML 程式碼；如果為
  0，把 HTML 程式碼當成普通的文字。


PHTML						*phtml.vim* *ft-phtml-syntax*

phtml 語法高亮有兩個選項。

如果你喜歡字串裡的 SQL 語法高亮，使用: >

	:let phtml_sql_query = 1

同步的 minlines 預設為 100。如果你喜歡別的值，可以設定 "phtml_minlines" 為你所
希望的值。例如: >

	:let phtml_minlines = 200


POSTSCRIPT				*postscr.vim* *ft-postscr-syntax*

PostScript 的高亮有若干選項。

首先決定是 PostScript 語言的哪個版本要高亮。目前定義了三個語言版本。Level 1 是
原始和基礎的版本，包括所有的 Level 2 釋出之前的擴充套件。Level 2 是最常用的版本，
包括 Level 3 釋出之前它自身的所有擴充套件。Level 3 是目前支援的最高版本。你可以
這樣定義 postscr_level 變數，以選擇需要高亮的 PostScript 的語言級別: >

	:let postscr_level=2

如果該變數沒有定義，預設值為 2 (Level 2)，因為這是目前最常用的版本。

注意，不是所有的 PS 直譯器都支援某一特定語言級別的所有語言特性。特別是，PS 文
件開頭的 %!PS-Adobe-3.0 並_不_意味著使用的 PostScript 是 Level 3 的
PostScript！

如果你使用 Display PostScript，可以這樣定義 postscr_display 變數來包含 Display
PS 語言特性的高亮: >

	:let postscr_display=1

如果你使用 Ghostscript，可以這樣定義 postscr_ghostscript 變數來包含
Ghostscript 特有的語言特性的高亮: >

	:let postscr_ghostscript=1

PostScript 是一個很大的語言，有許多預定義的元素。儘管包含所有這些元素的高亮很
有用，在較慢的機器上這會使得 Vim 變慢。為了使得對機器更友善，預設不給字型名和
字元編碼高亮。如果你不是顯式地開啟它們，應該沒有問題。如果你確實想看到它們的高
亮，可以設定下面之中的一個或兩個變數: >

	:let postscr_fonts=1
	:let postscr_encodings=1

關於 and、or 和 not 的高亮有一個風格的選項。PostScript 裡，這些操作符的函式取
決於它們運算元的型別 - 如果運算元都是布林型，它們是邏輯操作符。如果是整數，它
們是二進位制操作符。如果二進位制和布林型操作符高亮方式不同，它們可以用任何一種方式
高亮。預設它們被作為邏輯操作符。如果這樣定義 postscr_andornot_binary 變數，它
們可以用二進位制操作符方式進行高亮: >

	:let postscr_andornot_binary=1
<

			*ptcap.vim* *ft-printcap-syntax*
PRINTCAP + TERMCAP	*ft-ptcap-syntax* *ft-termcap-syntax*

該語法檔案適用於 printcap 和 termcap 資料庫。

要使得 Vim 識別不匹配模式 "printcap" 或 "termcap" 的 printcap/termcap 檔案，你
需要在 |myfiletypefile| 檔案裡定義合適你的系統的附加的模式。對這些模式，你必須
設定變數 "b:ptcap_type" 為 "print" 或 "term"，然後設定 'filetype' 選項為
ptcap。

比如，要使得 Vim 識別 /etc/termcaps/ 裡的所有檔案為 termcap 檔案，加入下行: >

   :au BufNewFile,BufRead /etc/termcaps/* let b:ptcap_type = "term" |
				       \ set filetype=ptcap

如果你注意到往回滾動時高亮有問題，但 CTRL-L 又可以修正的時候，嘗試設定
"ptcap_minlines" 內部變數為一個大的數字: >

   :let ptcap_minlines = 50

(預設為 20 行。)


PROGRESS				*progress.vim* *ft-progress-syntax*

匹配 "*.w" 的檔案可以是 Progress 或者 cweb 的。如果自動識別對你無效，或者你從
來不編輯 cweb，在你的啟動 vimrc 里加入: >
   :let filetype_w = "progress"
這同樣適用於可為彙編檔案的 "*.i" 和可為 Pascal 檔案的 "*.p"。如果你不使用匯編
和 Pascal，你可以這麼用: >
   :let filetype_i = "progress"
   :let filetype_p = "progress"


PYTHON						*python.vim* *ft-python-syntax*

有六個選項可以控制 Python 的語法高亮。

關於高亮數值: >
	:let python_no_number_highlight = 1

關於高亮內建函式: >
	:let python_no_builtin_highlight = 1

關於高亮標準例外: >
	:let python_no_exception_highlight = 1

關於高亮 doctest 和其中的程式碼: >
	:let python_no_doctest_highlight = 1
或 >
	:let python_no_doctest_code_highlight = 1
(第一個選項隱含第二個)。

要高亮行尾的空白還有空格和製表的混合: >
	:let python_space_error_highlight = 1

如果你想要所有可能的 Python 高亮 (等同於置位上面最後的選項及復位其餘選項): >
	:let python_highlight_all = 1

注意: 對以上選項，只關心其存在於否，值並不重要，可以把上面的 1 換成任何值。


QUAKE						*quake.vim* *ft-quake-syntax*

Quake 語法定義應可用於多數基於某個 Quake 引擎的 FPS (First Person Shooter)。不
過，在相關的三個遊戲 (Quake、Quake 2 和 Quake 3 Arena) 中，命令的名字略有不
同。所以，語法定義檢查三個全域性變數是否存在，從而使使用者可以指定他們的檔案裡哪些
命令是合法的。這三個變數的設定有如下效果。

設定使得高亮命令只適用於 Quake: >
	:let quake_is_quake1 = 1

設定使得高亮命令只適用於 Quake 2: >
	:let quake_is_quake2 = 1

設定使得高亮命令只適用於 Quake 3 Arena: >
	:let quake_is_quake3 = 1

組合這三個變數的使用也是可以的，不過高亮的命令也許比你的遊戲裡實際可用的命令要
多。


READLINE				*readline.vim* *ft-readline-syntax*

readline 庫主要由 BASH 外殼使用，在已有的命令和選項的基礎上，它又增加了不少。
要高亮這些附加的命令和選項，可以把這行加到你的 |vimrc| 裡，或者在載入使用
readline 語法的檔案前，在命令列輸入: >
	let readline_has_bash = 1

這使得 BASH (2.05a 和其後的版本，也包括部分以前的) 增加的命令被高亮。


RESTRUCTURED TEXT			*rst.vim* *ft-rst-syntax*

可以這樣設定程式碼塊使用的語法定義 >
	let rst_syntax_code_list = ['vim', 'lisp', ...]
<

REXX						*rexx.vim* *ft-rexx-syntax*

如果你注意到往回滾動時，高亮出現問題，但 CTRL-L 重畫又可以修正的話，嘗試設定
"rexx_minlines" 內部變數為較大的值: >
	:let rexx_minlines = 50
這使得語法同步在第一個顯示行之前的 50 行開始。預設值為 10。使用較大的值的缺點
是重畫會變慢。

Vim 試圖自己猜測 ".r" 檔案的真實型別。如果無法檢測 (根據註釋行內容)，假定為
"r"。要使預設為 rexx，給 .vimrc 檔案加上:  *g:filetype_r*
>
	:let g:filetype_r = "r"


RUBY						*ruby.vim* *ft-ruby-syntax*

    Ruby: 操作符高亮			|ruby_operators|
    Ruby: 空白錯誤			|ruby_space_errors|
    Ruby: 摺疊				|ruby_fold| |ruby_foldable_groups|
    Ruby: 減少昂貴操作			|ruby_no_expensive| |ruby_minlines|
    Ruby: 拼寫檢查字串		|ruby_spellcheck_strings|

						*ruby_operators*
 Ruby: 操作符高亮 ~

可通過定義 "ruby_operators" 來高亮操作符: >

	:let ruby_operators = 1
<
						*ruby_space_errors*
 Ruby: 空白錯誤 ~

可以通過定義 "ruby_space_errors" 開啟空白錯誤的高亮: >

	:let ruby_space_errors = 1
<
會高亮行尾的空白，而空格後的製表也被認為是錯誤。通過定義
"ruby_no_trail_space_error" 和 "ruby_no_tab_space_error"，可以進一步限定。這兩
個變數分別忽略行尾空白和空格之後的製表。

					*ruby_fold* *ruby_foldable_groups*
 Ruby: 摺疊 ~

定義 "ruby_fold" 可以開啟摺疊: >

	:let ruby_fold = 1
<
會把區域性於當前緩衝區或視窗的 'foldmethod' 選項設為 "syntax"，它開啟 Ruby 檔案
型別編輯時的基於語法的摺疊。

預設摺疊相當詳細，例如，"if"、"do"、"%w[]" 那樣的小的語法單元會建立對應的摺疊
層次。

可以設定 "ruby_foldable_groups" 來限制可摺疊的組: >

        :let ruby_foldable_groups = 'if case %'
<
可選值為空格分隔的關鍵字列表:

    關鍵字       含義 ~
    --------  ------------------------------------- ~
    ALL        絕大多數的塊語法 (預設)
    NONE       無
    if         "if" 或 "unless" 塊
    def        "def" 塊
    class      "class" 塊
    module     "module" 塊
    do         "do" 塊
    begin      "begin" 塊
    case       "case" 塊
    for        "for"、"while"、"until" 迴圈
    {          花括號塊或雜湊字面值
    [          陣列字面值
    %          "%" 記號的字面值，如: %w(STRING)、%!STRING!
    /          正規表示式
    string     字串和外殼命令輸出 (被 '、"、` 包圍)
    :          符號
    #          多行註釋
    <<         Here 文件
    __END__    "__END__" 指令之後的原始碼

						*ruby_no_expensive*
 Ruby: 減少昂貴操作 ~

預設，"end" 關鍵字根據它關閉的塊對應的開啟語句設定顏色。儘管很有用，該特性很消
耗資源: 如果你發現重畫變慢 (或者你所在的終端色彩支援不好)，你可能想關閉該特
性，只要定義 "ruby_no_expensive" 變數即可: >

	:let ruby_no_expensive = 1
<
此時，所有的控制關鍵字使用相同的顏色。

						*ruby_minlines*

如果你想使用該特性，但注意到往回滾動時，高亮出現問題，但 CTRL-L 重畫又可以修正
的話，嘗試設定 "ruby_minlines" 變數超過 50: >

	:let ruby_minlines = 100
<
理想的話，該值應該足夠大，使得最大的類或模組能夠得到處理。

						*ruby_spellcheck_strings*
 Ruby: 拼寫檢查字串 ~

定義 "ruby_spellcheck_strings" 可以用 Ruby 語法來執行字串的拼寫檢查: >

	:let ruby_spellcheck_strings = 1
<

SCHEME						*scheme.vim* *ft-scheme-syntax*

預設只高亮 R5RS 關鍵字並進行適當的縮排。

如果定義  b:is_mzscheme 或 g:is_mzscheme 變數，可以使用 MzScheme 特定的內容。

此外，scheme.vim 也支援 Chicken Scheme->C compiler 的關鍵字。如果需要，定義
b:is_chicken 或 g:is_chicken。


SDL						*sdl.vim* *ft-sdl-syntax*

SDL 的高亮可能會缺少一些關鍵字，但 SDL 的關鍵字太多了，完全照顧過來是不太可能
的。

新的標準 SDL-2000 指定所有的識別符號都是大小寫敏感的 (以前並非如此)，而所有使用
的關鍵字必須或者是完全小寫，或者完全大寫。要使得高亮能夠反映這些特性，你可以設
置如下的變數: >
	:let sdl_2000=1

這也會設定很多新的關鍵字。如果你想遮蔽舊的關鍵字 (其實，這是個好主意)，可以
用: >
	:let SDL_no_96=1

縮排可能還沒完全處理好，不過我在自己的專案目前的應用裡已經相當滿意了。


SED						*sed.vim* *ft-sed-syntax*

要使得製表在普通的空白裡突出顯示 (方法是在製表上使用 Todo 高亮)，在 vimrc 檔案
裡如此定義 "highlight_sedtabs" >

	:let highlight_sedtabs = 1

(這種特殊高亮只適用於搜尋模式、替換文字、地址或者 Append/Change/Insert
命令裡包含的文字中的製表。) 如果你開啟該選項，那麼最好把製表寬度設為一個字元；
這麼做，你很容易計算字串裡的製表數量。

漏洞:

  transform 命令 (y) 和 substitute 命令的處理相同。也就是說，就語法檔案而言，
  transform 和 substitute 接受相同的標誌。這不正確 (Transform 不接受標誌)。但
  我容忍這個問題，因為牽涉的命令需要很複雜的處理 (95 個模式，每個可能的模式定
  界符就需要一個模式)。


SGML						*sgml.vim* *ft-sgml-syntax*

SGML 檔案裡，標籤的色彩方案工作方式如下。

開放標籤的 <> 和關閉標籤的 </> 的色彩不同。這是有意的。開放標籤使用 'Function'
色彩，而關閉標籤使用 'Type' 色彩 (見 syntax.vim 察看它們是怎麼定義的)。

已知的標籤名和 C 語句的色彩相同。未知的標籤名和相應的 <> 或 </> 顏色相同，以便
糾錯。

注意 這也適用於引數 (或屬性) 的名字。已知的屬性名和未知的標色不同。

一些 SGML 標籤用於改變文字的顯示。sgml.vim 語法色彩檔案識別以下的標籤，並相應
地改變普通文字的顯示方式: <varname> <emphasis> <command> <function> <literal>
<replaceable> <ulink> 和 <link>。

如果你想改變文字顯示的方式，必須重定義以下的語法組:

    - sgmlBold
    - sgmlBoldItalic
    - sgmlUnderline
    - sgmlItalic
    - sgmlLink 設定連結

要使得重定義能夠工作，你必須重定義所有的組。在你的 vimrc (這是根據初始化時讀入
檔案的順序) 裡定義下面的變數 >
	:let sgml_my_rendering=1

在你的 vimrc 檔案里加上這行，可以遮蔽這種顯示方式: >
	:let sgml_no_rendering=1

(從 Claudio Fleiner <claudio@fleiner.com> 的 html.vim 的幫助文字轉來)


		*ft-posix-synax* *ft-dash-syntax*
SH		*sh.vim*  *ft-sh-syntax*  *ft-bash-syntax*  *ft-ksh-syntax*

這裡討論較古老的 Unix (Bourne) sh 和較新的外殼如 bash、dash、posix 和 Korn
shell 的語法高亮。

Vim 試圖根據檔名決定使用的 shell 型別: >

    ksh : .kshrc* *.ksh
    bash: .bashrc* bashrc bash.bashrc .bash_profile* *.bash
<
如果這些都不符，那麼就檢查檔案的第一行 (比如尋找 /bin/sh  /bin/ksh
/bin/bash)。如果第一行指定了外殼型別，那麼就使用該型別。不過有的檔案 (比如
.profile) 肯定是外殼檔案，但其型別並不容易推出。另外，有的系統裡 sh 被符號連結
到 "bash" (linux、Windows+cygwin) 或 "ksh" (posix)。

你可以在 <.vimrc> 裡設定下列變數中的一個，以指定全域性的預設值:

    ksh: >
	let g:is_kornshell = 1
<   posix: (和設定 g:is_kornshell 為 1 效果幾乎相同) >
	let g:is_posix     = 1
<   bash: >
	let g:is_bash	   = 1
<   sh: (預設) Bourne shell >
	let g:is_sh	   = 1

<   (dash 使用者應使用 posix)

如果沒有 "#! ..." 一行，而使用者也沒有用上述方法設定預設的 sh.vim 語法設定，那麼
syntax/sh.vim 假定使用 Bourne shell 語法。請不要在錯誤報告裡引用 RFC 或者市場
佔有率的統計資料 (譯者注: 此處大概指希望使用其它預設值的使用者) -- 自己選擇系統
使用的預設 sh 版本並在 <.vimrc> 檔案裡安裝相應的 "let..." 就可以了。

syntax/sh.vim 檔案提供若干級別的基於語法的摺疊: >

	let g:sh_fold_enabled= 0     (預設，無語法高亮)
	let g:sh_fold_enabled= 1     (開啟函式摺疊)
	let g:sh_fold_enabled= 2     (開啟 here 文件摺疊)
	let g:sh_fold_enabled= 4     (開啟 if/do/for 摺疊)
>
那麼若干語法專案 (即 Here 文件和函式體) 就可以進行語法摺疊 (見 |:syn-fold|)。
把這些值加在一起可以得到多種專案的摺疊: >

	let g:sh_fold_enabled= 3     (開啟函式和 here 文件的摺疊)

如果你注意到往回滾動時，高亮出現問題，但 CTRL-L 重畫又可以修正的話，嘗試設定
"sh_minlines" 內部變數為較大的值: >
	:let sh_minlines = 500
這使得語法同步在第一個顯示行之前的 500 行開始。預設值為 200。使用較大的值的缺
點是重畫會變慢。

如果你沒有要同步的東西，但顯示又很慢，可以設定 "sh_maxlines" 內部變數來加速。
比如: >

	let sh_maxlines = 100
<
預設值是 sh_minlines 的兩倍。設定為較小的值可以提高顯示的速度。缺點是高亮錯誤
出現的可能性也較大。

syntax/sh.vim 試圖示記若干問題為錯誤；包括常見的多餘的 ']'、'done'、'fi' 等情
況。如果發現錯誤處理對你有問題，可以在 .vimrc 裡這樣遮蔽錯誤高亮: >

	let g:sh_no_error= 1
<

						*sh-embed*  *sh-awk*
 Sh: 內 嵌 語 言~

你也許想要在 sh 裡內嵌其他語言。多謝 Lorance Stinson 提供了一個 awk 的例子。
把下面內容寫入 $HOME/.vim/after/syntax/sh/awkembed.vim: >

    " AWK Embedding:
    " ==============
    " Shamelessly ripped from aspperl.vim by Aaron Hope.
    if exists("b:current_syntax")
      unlet b:current_syntax
    endif
    syn include @AWKScript syntax/awk.vim
    syn region AWKScriptCode matchgroup=AWKCommand start=+[=\\]\@<!'+ skip=+\\'+ end=+'+ contains=@AWKScript contained
    syn region AWKScriptEmbedded matchgroup=AWKCommand start=+\<awk\>+ skip=+\\$+ end=+[=\\]\@<!'+me=e-1 contains=@shIdList,@shExprList2 nextgroup=AWKScriptCode
    syn cluster shCommandSubList add=AWKScriptEmbedded
    hi def link AWKCommand Type
<
此程式碼會接受如下單引號括起的 awk 程式碼: >
	awk '...awk code here...'
使之採用 awk 高亮語法。顯然此方法可以類似地擴充套件到其他語言上。


SPEEDUP						*spup.vim* *ft-spup-syntax*
(AspenTech plant simulator)

Speedup 語法檔案有如下選項:

- strict_subsections : 如果定義該變數，只有段 (section) 和子段 (subsection) 裡
  的關鍵字會作為 Statement 高亮，而其它關鍵字不會 (比如 OPERATION 段裡的
  WITHIN)。

- highlight_types : 該變數的定義使得流型別 (stream type)，比如 temperature 或
  pressure，用 Type 高亮，而不是普通的 Identifier。這裡包括 DECLARE 段常見的類
  型；如果定義了自己的型別，要在語法檔案裡自己加入。

- oneline_comments : 該值可選 1 到 3，它決定了 # 風格的註釋的高亮方式。

  oneline_comments = 1 : 允許偶數個 # 之後的正常 Speedup 程式碼。

  oneline_comments = 2 : 第二個 # 開始的程式碼顯示為出錯。這是預設設定。

  oneline_comments = 3 : 如果某行包含超過一個 #，把整行顯示為出錯。

特別因為 OPERATION 段因為 PRESET (預設) 的變數而可能會很大，同步的正確設定很重
要。如果你的機器足夠快，你可以在語法檔案的末尾增加 minlines 和/或 maxlines 的
值。


SQL						*sql.vim* *ft-sql-syntax*
				*sqlinformix.vim* *ft-sqlinformix-syntax*
				*sqlanywhere.vim* *ft-sqlanywhere-syntax*

儘管有 ANSI 的 SQL 標準，多數資料庫引擎都增加了自己的擴充套件。Vim 目前支援 Oracle
和 Informix 的 SQL 方言。Vim 預設假設 "*.sql" 檔案使用 Oracle SQL。

Vim 目前通過不同語法指令碼提供不同供應商的 SQL 支援。你可以把 Vim 的預設設定從
Oracle 改為任何目前支援的 SQL 型別。你也可以方便地為每個緩衝區設定不同的 SQL
方言。

詳細的操作可見 |ft_sql.txt|。


TCSH						*tcsh.vim* *ft-tcsh-syntax*

這裡討論名為 "tcsh" 的外殼。這是 csh 的超集。關於如何檢測檔案型別，見
|csh.vim|。

Tcsh 不允許字串裡的 \"，除非設定了 "backslash_quote" 外殼變數。如果你希望
VIM 認定不應該存在反斜槓 + 引號的構造，在 .vimrc 里加入這行: >

	:let tcsh_backslash_quote = 0

如果你注意到往回滾動時，高亮出現問題，但 CTRL-L 重畫又可以修正的話，嘗試設定
"tcsh_minlines" 內部變數為較大的值: >
	:let tcsh_minlines = 1000
這使得語法同步在第一個顯示行之前的 1000 行開始。如果設定 "tcsh_minlines" 為
"fromstart"，同步從檔案開始處進行。tcsh_minlines 的預設值為 100。使用較大的值
的缺點是重畫會變慢。


TEX				*tex.vim* *ft-tex-syntax* *latex-syntax*

			Tex 內容~
	Tex: 要語法摺疊麼？				|tex-folding|
	Tex: 不想拼寫檢查				|g:tex_nospell|
	Tex: 不想檢查註釋裡的拼寫？			|tex-nospell|
	Tex: 需要在 Verbatim 區中使用拼寫檢查？		|tex-verb|
	Tex: 在註釋還是數學模式裡			|tex-runon|
	Tex: 語法高亮很慢？				|tex-slow|
	Tex: 想高亮更多的命令？				|tex-morecommands|
	Tex: 過多的 Error 高亮？			|tex-error|
	Tex: 需要新的數學模式的組？			|tex-math|
	Tex: 開始新的風格？				|tex-style|
	Tex: 利用隱藏模式				|tex-conceal|
	Tex: 選擇性的隱藏模式				|g:tex_conceal|
	Tex: 控制 iskeyword				|g:tex_isk|
	Tex: 下標和上標的精細控制			|tex-supersub|

				*tex-folding* *g:tex_fold_enabled*
 Tex: 要語法摺疊麼？ ~

<syntax/tex.vim> 的版本 28 支援基於語法的 part、chapter、section、subsection
等等的摺疊。把 >
	let g:tex_fold_enabled=1
放到你的 <.vimrc> 裡，並 :set fdm=syntax。我建議把後者放到你的 LaTeX 檔案末尾
的模式行裡來執行: >
	% vim: fdm=syntax
如果系統過慢，可以看看 >
	https://vimhelp.appspot.com/vim_faq.txt.html#faq-29.7
<
						*g:tex_nospell*
 Tex: 不想拼寫檢查~

如果不想 LaTeX 文件在任何地方檢查拼寫，在 .vimrc 里加入 >
	let g:tex_nospell=1
如果只想關閉註釋中的拼寫檢查，見 |g:tex_comment_nospell|。

				*tex-nospell* *g:tex_comment_nospell*
 Tex: 不想檢查註釋裡的拼寫？ ~

有些傢伙喜歡在註釋裡寫原始碼，所以希望在 LaTeX 檔案的註釋裡關閉拼寫檢查。為
此，在 <.vimrc> 裡放上: >
      let g:tex_comment_nospell= 1
如果你要關閉 LaTeX 文件中所有地方的拼寫檢查，見 |g:tex_nospell|。

				*tex-verb* *g:tex_verbspell*
 Tex: 需要在 Verbatim 區中使用拼寫檢查？~

通常 verbatim 區域用於原始碼這類的東西；很少有人想對原始碼進行拼寫檢查。如果你
真的想要對 verbatim 區進行拼寫檢查，在 <.vimrc> 裡放入: >
	let g:tex_verbspell= 1
<
					*tex-runon* *tex-stopzone*
 Tex: 在註釋還是數學模式裡？~

<syntax/tex.vim> 高亮支援 TeX、LaTeX 和部分的 AmsTeX。高亮支援包括三個主要的區
域: normal、texZone 和 texMathZone。儘管付出了相當的努力使得這些區域能正確地
終止，$..$ 和$$..$$ 定界的區域無法同步，因為開始和結束模式無法區別。因而，提供
了一個特殊的 "TeX 註釋" >
	%stopzone
它會使得 texZone 或 texMathZone 強迫終止。

					*tex-slow* *tex-sync*
 Tex: 語法高亮很慢？~

如果你使用機器速度很慢，可能會想減小這些變數的值 >
	:syn sync maxlines=200
	:syn sync minlines=50
(特別是後者)。如果你的機器很快，可以考慮增大它們的值。它們主要影響同步 (確切地
說也就是: 如果有的話，哪個語法組包含螢幕頂部的文字？)。

另外一個高亮緩慢的原因是基於語法的摺疊；解決辦法見 |tex-folding|。

					*g:tex_fast*

最後，如果語法高亮還是太慢，可以在 .vimrc 裡設定

	:let g:tex_fast= ""

g:tex_fast 變數使得語法高亮指令碼避免定義任何語法區域和相關的同步。這使得語法高
亮速度大大加快；作為代價：高亮和基於語法的摺疊會少很多，也不能進行基於語法的
錯誤檢查。

可以選擇接受若干而非全部的語法專案；用下表可以選擇性地開啟部分語法高亮: >

    b : 接受粗體和斜體語法
    c : 接受 texComment 語法
    m : 接受 texMatcher 語法 (即 {...} 和 [...])
    M : 接受 texMath 語法
    p : 接受 部分、章節、小節等的語法
    r : 接受 texRefZone 語法 (nocite、bibliography、label、pageref、eqref)
    s : 接受 上標/下標區域
    S : 接受 texStyle 語法
    v : 接受 verbatim 語法
    V : 接受 texNewEnv 和 texNewCmd 語法
<
例如，g:tex_fast= "M" 會開啟數學相關的高亮但關閉其他基於區域的語法高亮。
(另見: |g:tex_conceal| 和 |tex-supersub|)

					    *tex-morecommands* *tex-package*
 Tex: 想高亮更多的命令？ ~

LaTeX 是可程式設計的語言，因而有數以千計的包，包含各種專門的 LaTeX 命令、語法和字
體。如果你用了某個包，當然希望釋出的 syntax/tex.vim 能支援它。但這顯然是不實際
的。請考慮使用 |mysyntaxfile-add| 介紹的技術來擴充套件或者修改 syntax/tex.vim 提供
的高亮處理。任何你編寫的擴充套件一般應放在 $HOME/after/syntax/tex/[pkgname].vim，
並請考慮上傳到 http://vim.sf.net/。

					*tex-error* *g:tex_no_error*
 Tex: 過多的 Error 高亮？~

<tex.vim> 支援各種的詞法檢查。儘管錯誤檢查經常很有用，它指示的地方實際上可能沒
有錯誤。如果你有這個問題，可以在 <.vimrc> 裡放上如下的語句: >
	let g:tex_no_error=1
從而 <tex.vim> 提供的所有錯誤檢查都會被抑制。

								*tex-math*
 Tex: 需要新的數學模式的組？~

如果你需要在 LaTeX 裡包含新的數學組，下面的程式碼給出一個告訴你可以如何操作的例
子: >
	call TexNewMathZone(sfx,mathzone,starform)
你需要為新數學組起一個獨一無二的字尾 (目前，A-L 和 V-Z 被 <syntax/tex.vim> 自
己佔用)。比如，看看 <syntax/tex.vm> 是怎麼設定 eqnarray 的: >
	call TexNewMathZone("D","eqnarray",1)
需要把 "mathzone" 換成新數學組的組名，然後在 .vim/after/syntax/tex.vim 裡調
用。如果 "starform" 變數為真，意味著新數學組有星號的形式 (比如， eqnarray*)。

					*tex-style* *b:tex_stylish*
 Tex: 開始新的風格？~

你可以在 *.tex 檔案裡使用 "\makeatletter"，從而在命令裡可用 "@"。不過，因為
*.tex 檔案沒有如下的字尾: sty cls clo dtx ltx，語法高亮會把這裡使用的 @ 標為錯
誤。要解決這個問題: >

	:let b:tex_stylish = 1
	:set ft=tex

把 "let g:tex_stylish=1" 放到你的 <.vimrc> 裡，這會使得 <syntax/tex.vim> 總能
接受 @ 的這種使用方式。

					*tex-cchar* *tex-cole* *tex-conceal*
 Tex: 利用隱藏模式~

如果你設定 |'conceallevel'| 為 2 而編碼是 utf-8，若干字元序列會翻譯為合適的
utf-8 字形，包括各種重音字元、數學模式的希臘字母。數學模式的上標和下標。不是所
有的字元都可以轉為上標和下標；這是由於 utf-8 支援的限制。事實上，只有很少的字
符支援下標。

一個用法是垂直分割視窗 (見 |CTRL-W_v|)；其中一個把 |'conceallevel'| 設為 0，另
一個設為 2；兩者都用 |'scrollbind'|。

					*g:tex_conceal*
 Tex: 選擇性的隱藏模式~

通過在 <.vimrc> 中設定 g:tex_conceal，可以有選擇性地使用隱藏模式。預設的設定為
"admgs"，隱藏以下對應的字元集合: >

	a = 重音/連寫體 (accents/ligatures)
	b = 粗體和斜體
	d = 定界符
	m = 數學符號
	g = 希臘字母
	s = 上標/下標
<
省略其中一個或幾個字元關閉對應的使用隱藏字元進行替代的操作。

						*g:tex_isk* *g:tex_stylish*
 Tex: 控制 iskeyword~

通常，LaTeX 關鍵字只支援 0-9, a-z, A-Z, 192-255。Latex 關鍵字不支援下劃線，除
了 *.sty 檔案以外。語法高亮指令碼使用以下的邏輯:

	* 如果 g:tex_stylish 存在且為 1
		檔案被作為 "sty" 檔案對待，允許 "_" 成為關鍵字一的部分
		(獨立於 g:tex_isk)
	* 否則如果檔名字尾是 sty、cls、clo、dtx 或 ltx
		檔案被作為 "sty" 檔案對待，允許 "_" 成為關鍵字一的部分
		(獨立於 g:tex_isk)

	* 如果 g:tex_isk 存在，它被用作區域性的 'iskeyword'
	* 否則區域性的 'iskeyword' 設為 48-57,a-z,A-Z,192-255

			*tex-supersub* *g:tex_superscripts* *g:tex_subscripts*
 Tex: 下標和上標的精細控制~

	關於如何開啟隱藏字元的替換，見 |tex-conceal|。

	關於如何選擇性的隱藏重音、粗體/斜體、數學、希臘文、和上標/下標，見
	|g:tex_conceal|。

	可以更加精細地控制基於語法地隱藏哪些上標和下標 (見 |:syn-cchar|)。因為
	不是所有的字型都支援所有字元，可以覆蓋隱藏替換列表；預設這些列表是這樣
	給出的: >

	    let g:tex_superscripts= "[0-9a-zA-W.,:;+-<>/()=]"
	    let g:tex_subscripts= "[0-9aehijklmnoprstuvx,+-/().]"
<
	例如，我用 Luxi Mono Bold；它不支援下標字元 "hklmnpst"，所以我在
	~/.vim/ftplugin/tex/tex.vim 裡放上 >
		let g:tex_subscripts= "[0-9aeijoruvx,+-/().]"
<	以防止出現不可理解的 utf8 字形。


TF						*tf.vim* *ft-tf-syntax*

tf 語法高亮有一個選項。

同步的 minlines 預設為 100。如果你希望設為別的值，可以把 "tf_minlines" 設為你
希望的值。例如: >

	:let tf_minlines = 你的選擇
<
VIM			*vim.vim* 		*ft-vim-syntax*
			*g:vimsyn_minlines*	*g:vimsyn_maxlines*

準確的語法高亮和螢幕重新整理速度需要一定的折衷。要提高準確性，你可能想增加
g:vimsyn_minlines 變數的值。而 g:vimsyn_maxlines 變數可以用來增加螢幕的重新整理速
度 (詳情可見 |:syn-sync|)。

	g:vimsyn_minlines : 用於設定同步的 minlines
	g:vimsyn_maxlines : 用於設定同步的 maxlines

	(g:vim_minlines 和 g:vim_maxlines 是這些選項過時的名字)

						*g:vimsyn_embed*
g:vimsyn_embed 選項允許使用者選擇是否使用及使用何種型別的嵌入指令碼高亮。 >

   g:vimsyn_embed == 0   : 不支援任何內嵌指令碼
   g:vimsyn_embed =~ 'l' : 支援內嵌 lua
   g:vimsyn_embed =~ 'm' : 支援內嵌 mzscheme
   g:vimsyn_embed =~ 'p' : 支援內嵌 perl
   g:vimsyn_embed =~ 'P' : 支援內嵌 python
   g:vimsyn_embed =~ 'r' : 支援內嵌 ruby
   g:vimsyn_embed =~ 't' : 支援內嵌 tcl
<
g:vimsyn_embed 預設是代表 vim 自身支援的直譯器的字串。連線多個字元以支援多個
內嵌直譯器的型別；例如 g:vimsyn_embed= "mp" 支援內嵌的 mzscheme 和內嵌 perl。
						*g:vimsyn_folding*

syntax/vim.vim 現在支援一些摺疊: >

   g:vimsyn_folding == 0 或不存在: 沒有基於語法的摺疊
   g:vimsyn_folding =~ 'a' : 自動命令組
   g:vimsyn_folding =~ 'f' : 摺疊函式
   g:vimsyn_folding =~ 'l' : 摺疊 lua      指令碼
   g:vimsyn_folding =~ 'm' : 摺疊 mzscheme 指令碼
   g:vimsyn_folding =~ 'p' : 摺疊 perl     指令碼
   g:vimsyn_folding =~ 'P' : 摺疊 python   指令碼
   g:vimsyn_folding =~ 'r' : 摺疊 ruby     指令碼
   g:vimsyn_folding =~ 't' : 摺疊 tcl      指令碼
<
							*g:vimsyn_noerror*
syntax/vim.vim 給出的錯誤高亮未必都正確；Vim 指令碼是一個要正確高亮難度很高的語
言。如果不想出現錯誤高亮，在你的 |vimrc| 裡放上: >

	let g:vimsyn_noerror = 1


XF86CONFIG				*xf86conf.vim* *ft-xf86conf-syntax*

XFree86 v3.x 和 v4.x 版本里，XF86Config 檔案的語法有所不同。兩者都支援且有自動
檢測，但離完善還很遠。你可能仍然需要手動指定版本。根據你的 XFree86 的版本，在
.vimrc 裡把 xf86conf_xfree86_version 變數設為 3 或 4。例如: >
	:let xf86conf_xfree86_version=3
如果混合使用多種版本，設定 b:xf86conf_xfree86_version 變數。

注意 不支援選項名的空格和下劃線。如果你想高亮選項名，使用 "SyncOnGreen" 而不是
"__s yn con gr_e_e_n"。


XML						*xml.vim* *ft-xml-syntax*

預設高亮 Xml 的名稱空間。設定了下面的全域性變數以後可以繼承此設定: >

	:let g:xml_namespace_transparent=1
<
							*xml-folding*
xml 語法檔案提供開啟和關閉標籤間的語法摺疊 |folding| (見 |:syn-fold|)。這可以
用下面的程式碼開啟 >

	:let g:xml_syntax_folding = 1
	:set foldmethod=syntax
<
注意: 語法摺疊會顯著地減慢語法高亮。大檔案尤其如此。


X Pixmaps (XPM)					*xpm.vim* *ft-xpm-syntax*

xpm.vim 根據 XPM 檔案的內容動態地建立語法專案。這樣你就可以修改色彩規格字元
串。修改後，可用 ":set syn=xpm" 再次執行。

要複製帶某顏色的畫素，使用 "yl" 命令抽出 "畫素" 然後在別的地方使用 "P" 插入。

你想用滑鼠畫圖麼？試試這些程式碼: >
   :function! GetPixel()
   :   let c = getline(".")[col(".") - 1]
   :   echo c
   :   exe "noremap <LeftMouse> <LeftMouse>r".c
   :   exe "noremap <LeftDrag>	<LeftMouse>r".c
   :endfunction
   :noremap <RightMouse> <LeftMouse>:call GetPixel()<CR>
   :set guicursor=n:hor20	   " 可以看到游標下的顏色
這使得右鍵變成畫素提取工具，而左鍵成為一支筆。該程式碼只可用於每個畫素一個字元的
XPM 檔案，而且你不能在畫素字串之外點選。不過，你自己可以嘗試改進之。

如果使用大小減半的字型，看其來會舒服得多。比如，在 X 上: >
	:set guifont=-*-clean-medium-r-*-*-8-*-*-*-*-80-*


YAML						*yaml.vim* *ft-yaml-syntax*

					*g:yaml_schema* *b:yaml_schema*
YAML 模型是一個標籤集合和解析非特定標籤的機制的組合。對使用者來說，這意味著取決
於簡單向量內容，YAML 分析器可把簡單向量 (實際可以只是字串而沒有其它) 當作其
它型別的值: null、布林型、浮點數、整數。`g:yaml_schema` 選擇決定根據什麼模型來
對值進行特殊高亮。支援的模型為

模型		描述 ~
failsafe	沒有額外高亮。
json		支援 JSON 風格的數值、布林型和 null。
core		支援更多風格的數值、布林型和 null。
pyyaml		除了 core 模型以外，還支援高亮時間戳，但和 core 模型識別的數值
		有些區別，也有很多 core 模型沒有的附加的布林值。

預設的模型是 `core`。

注意 模型實際不侷限於簡單的向量，但這是 YAML 規格定義的模型的唯一區別，也是語
法檔案定義的唯一區別。


ZSH						    *zsh.vim* *ft-zsh-syntax*

zsh 的語法高亮指令碼開啟基於語法的摺疊: >

	:let g:zsh_fold_enable = 1

==============================================================================
5. 定義語法						*:syn-define* *E410*

Vim 理解三種語法專案的型別:

1. 關鍵字
   它只能包含由 'iskeyword' 選項定義的關鍵字字元，而且不能包含其它語法專案。
   它必須匹配完整的單詞 (在匹配的前後不能有其它的關鍵字字元)。
   關鍵詞 "if" 只在 "if(a=b)" 裡匹配，而不在 "ifdef x" 裡匹配。因為 "(" 不是關
   鍵字字元，但 "d" 是。

2. 匹配
   它匹配單個正規表示式模式。

3. 區域
   它始於 "start" 正規表示式模式的匹配，結束於 "end" 正規表示式模式的匹配。兩
者之間可以包含任何文字。其中，"skip" 正規表示式模式可以用來避免 "end" 模式的匹
配。

若干語法*專案*可以放在一個語法*組*裡。你可以為一個語法組設定高亮屬性。例如，你
可以定義 "/* .. */" 註釋為一個專案，"// .." 註釋為另一個，並把兩者都放在
"Comment" 組裡。這時，你就可以設定 "Comment" 以粗體字型和藍色出現。你可以自由
選擇各種組合，比如為每個語法專案設定一個高亮組，乃至把所有專案都放到一個組。這
取決於你如何指定你的高亮屬性。把每個專案放到單獨的組裡的後果是你需要為很多組指
定高亮屬性。

注意 語法組和高亮組類似。你為高亮組指定高亮屬性，而這些屬性會被用於同名的語法
組。

如果有多個專案在相同位置匹配，*最後*定義的那個勝出。這樣，你可以覆蓋較早定義的
匹配相同文字的語法專案。不過，關鍵字總是優先於匹配和區域，而匹配大小寫的關鍵字
又優先於忽略大小寫的關鍵字。


優 先 級						*:syn-priority*

如果多個語法專案可以匹配，使用如下規則:

1. 如果多個匹配或區域專案在相同的位置開始，最後定義者優先。
2. 關鍵字比匹配和區域專案優先。
3. 從較早位置開始的專案優先於從較後位置開始的專案。


定 義 大 小 寫 敏 感					*:syn-case* *E390*

:sy[ntax] case [match | ignore]
	要求其後的 ":syntax" 命令在本設定為 "match" 時必須匹配大小寫，本設定為
	"ignore" 時則可以忽略大小寫。注意，它不影響之前的專案，而隻影響其後直
	到下一個 ":syntax case" 命令為止的所有專案。

:sy[ntax] case
	顯示 "syntax case match" 或 "syntax case ignore" 之一 (經過翻譯)。


拼 寫 檢 查						*:syn-spell*

:sy[ntax] spell [toplevel | notoplevel | default]
	定義不在任何語法專案裡的文字在何處進行拼寫檢查:

	toplevel:	文字進行拼寫檢查。
	notoplevel:	文字不進行拼寫檢查。
	default:	如果有 @Spell 簇，不進行拼寫檢查。

	語法專案裡的文字用 @Spell 和 @NoSpell 簇 |spell-syntax|。如果沒有
	@Spell 和 @NoSpell 簇，那麼 "default" 和 "toplevel" 進行拼寫檢查。

	要啟用拼寫檢查，必須置位 'spell' 選項。

:sy[ntax] spell
	顯示 "syntax spell toplevel"、"syntax spell notoplevel" 或
	"syntax spell default" 之一 (經過翻譯)。


語 法 ISKEYWORD 設 置					*:syn-iskeyword*

:sy[ntax] iskeyword [clear | {option}]
	定義關鍵字字元。類似於 'iskeyword' 選項，但只適用於語法高亮。

	clear:		關閉語法特定的 iskeyword 設定，使用區域性於緩衝區的
			'iskeyword' 設定。
	{option}        設定語法的 'iskeyword' 選項為新值。

	示例: >
  :syntax iskeyword @,48-57,192-255,$,_
<
	這使得語法特定的 iskeyword 選項包含所有的字母、數位，所有的重音字元，
	還包含 ”_" 和 "$"。

	如果不給出引數，輸出當前值。

	此選項的設定影響語法模式中的 |/\k| 匹配，也決定新匹配會如何檢查
	|:syn-keyword|。

	建議寫語法檔案時，使用此命令也為特定的語法語言設定正確的值，而不改變
	'iskeyword' 選項。

定 義 關 鍵 字						*:syn-keyword*

:sy[ntax] keyword {group-name} [{options}] {keyword} .. [{options}]

	定義一系列關鍵字。

	{group-name}	是語法組名，比如 "Comment"。
	[{options}]	見下 |:syn-arguments|。
	{keyword} ..	是關鍵字列表，這些關鍵字成為該組的成員。

	示例: >
  :syntax keyword   Type   int long char
<
	{options} 可以在該行的任何位置給出。它們應用於所有的關鍵字，包括選項之
	前的關鍵字。以下例子完全相同: >
  :syntax keyword   Type   contained int long char
  :syntax keyword   Type   int long contained char
  :syntax keyword   Type   int long char contained
<								*E789* *E890*
	如果像 Vim 裡的 Ex 命令那樣，使用有可選尾部的關鍵字並把可選字元放在 []
	裡，你可以一次定義各種變化形式: >
  :syntax keyword   vimCommand	 ab[breviate] n[ext]
<
	不要忘記只有所有字元都包含在 'iskeyword' 選項裡才能作為關鍵字識別。如
	果有一個字元不是，該關鍵字永遠不會被識別。不過，可以使用多位元組字元，它
	們不需要出現在 'iskeyword' 裡。
	|:syn-iskeyword| 說明如何定義語法特定的 iskeyword 設定。

	關鍵字比匹配和區域有更高的優先順序。如果有多個專案匹配，會優先使用關鍵
	字。關鍵字不會巢狀，也不能包含其它專案。

	注意 你不能使用和選項同名的關鍵字 (即使這裡不允許的選項也不行)。這時，
	應該使用匹配。

	關鍵字的最大長度為 80 個字元。

	根據被包含與否的不同，可以多次定義同一關鍵字，例如，你可以定義一次不被
	包含的關鍵字並使用一個高亮組。而為被包含的同一關鍵字使用不同的高亮組。
	例如: >
  :syn keyword vimCommand tag
  :syn keyword vimSetting contained tag
<	如果發現獨立於別的語法專案之外的 "tag"，使用 "vimCommand" 高亮組。如果
	發現 "tag" 出現在能包含 "vimSetting" 的專案裡，則使用 "vimSetting"。


定 義 匹 配						*:syn-match*

:sy[ntax] match {group-name} [{options}]
		[excludenl]
		[keepend]
		{pattern}
		[{options}]

	定義一個匹配。

	{group-name}		語法組名，比如 "Comment"。
	[{options}]		見下 |:syn-arguments|。
	[excludenl]		使得包含行尾匹配 "$" 的模式不擴充套件包含本專案的
				匹配或者區域專案。必須在模式之前給出。
				|:syn-excludenl|
	keepend			不允許被包含的匹配專案超越結束模式的匹配文字。
				見 |:syn-keepend|。
	{pattern}		定義匹配的搜尋模式。見下面的 |:syn-pattern|。
				注意 模式可以匹配多於一行的模式，這使得匹配依
				賴於 Vim 從哪裡開始搜尋模式。你需要確信同步機
				制能正確處理這個問題。

	例如 (匹配字元常數): >
  :syntax match Character /'.'/hs=s+1,he=e-1
<

定 義 區 域 		*:syn-region* *:syn-start* *:syn-skip* *:syn-end*
							*E398* *E399*
:sy[ntax] region {group-name} [{options}]
		[matchgroup={group-name}]
		[keepend]
		[extend]
		[excludenl]
		start={start_pattern} ..
		[skip={skip_pattern}]
		end={end_pattern} ..
		[{options}]

	定義一個區域。區域可以覆蓋多行。

	{group-name}		語法組名，比如 "Comment"。
	[{options}]		見下 |:syn-arguments|。
	[matchgroup={group-name}]  其後定義的開始或者結束模式的匹配文字專用的
				語法組。該語法組並不用於兩者之間的文字。如果不
				想開始或結束匹配使用另外的語法組，可以用 NONE
				作為組名來複位。
				見 |:syn-matchgroup|。
	keepend			不允許被包含的匹配專案越過結束模式的匹配文字。
				見 |:syn-keepend|。
	extend			否決包含本區域的專案的 "keepend" 設定。見
				|:syn-extend|。
	excludenl		使得包含行尾匹配 "$" 的模式不擴充套件包含本專案的
				匹配或者區域。只適用於結束模式。必須在該模式之
				前給出。|:syn-excludenl|
	start={start_pattern}	定義區域開始的搜尋模式。見下 |:syn-pattern|。
	skip={skip_pattern}	定義不需要查詢結束模式的區域內部文字的搜尋模
				式。見下 |:syn-pattern|。
	end={end_pattern}	定義區域結束的搜尋模式。見下 |:syn-pattern|。

	示例: >
  :syntax region String   start=+"+  skip=+\\"+  end=+"+
<
	開始 / 跳過 / 結束模式和其它選項可用任何順序給出。跳過模式可有零到一
	個。開始和結束模式必須有一個或更多。這意味著，你可以忽略跳過模式，但你
	必須給出至少一個的開始和結束模式。在等號前後，可以使用空白字元 (不過多
	數情況下，其實沒有空白字元更清楚一些)。

	如果給出多於一個的開始模式，只須匹配其中任何一個。這意味著這些開始模式
	之間是*或*的關係。如有多個匹配，使用最後一個。結束模式也是如此。

	結束模式從開始模式之後立即開始搜尋，這裡不考慮位移。這意味著，結束模式
	的匹配文字永遠不會與開始模式的重疊。

	跳過和結束模式可以跨行匹配，但因為模式的搜尋可以從任何一行開始，這經常
	不能如你所願。跳過模式也不能避免下一行中結束模式的匹配。要避免麻煩，最
	好使用單行的模式。

	注意: 一個區域的開始完全取決於開始模式的匹配。不檢查是否存在結束模式的
	匹配。下面_不能_工作: >
		:syn region First  start="("  end=":"
		:syn region Second start="("  end=";"
<	Second 總是在 First 之前得到匹配 (最後定義的模式享有更高的優先權)。
	Second 區域會繼續到後面出現的 ';' 為止。這之前是否出現 ':' 無關緊要。
	要解決這個問題，可以使用匹配: >
		:syn match First  "(\_.\{-}:"
		:syn match Second "(\_.\{-};"
<	該模式使用 "\_." 匹配任何字元或換行符，並以 "\{-}" 重複 (重複儘量少的
	次數)。

							*:syn-keepend*
	預設，被包含的專案可以隱藏結束模式的匹配。這對巢狀有用。比如， "{" 開
	始 "}" 結束的區域可以包含另一個這樣的區域。第一個遇到的 "}" 會結束被包
	含的區域，不是外面的那個:
	    {		開始外層 "{}" 區域
		{	開始被包含的 "{}" 區域
		}	結束被包含的 "{}" 區域
	    }		結束外層 "{} 區域
	如果你不希望如此，"keepend" 引數可以使得外層區域結束模式的匹配同時結束
	任何包含在內的專案。這使得相同區域的巢狀不再可能，但可以允許被包含專案
	高亮結束模式的部分內容，而不會因此跳過結束模式的匹配。例如: >
  :syn match  vimComment +"[^"]\+$+
  :syn region vimCommand start="set" end="$" contains=vimComment keepend
<	"keepend" 使得 vimCommand 總是在行尾結束，即使被包含的 vimComment 包括
	了 <EOL> 的匹配也不例外。

	如果不使用 "keepend"，在每個被包含專案的匹配文字之後，才會重新嘗試結束
	模式的匹配。如果使用 "keepend"，尋找結束模式第一次出現的匹配，並截斷任
	何被包含的專案。
							*:syn-extend*
	"keepend" 的行為可以被 "extend" 引數改變。當一個專案使用 "extend" 的時
	候，包含它的外層專案所用的 "keepend" 被忽略，從而使得那個專案可以得到
	擴充套件。
	這可以使一些被包含的專案能擴充套件某區域，而另一些則不能。例如: >

   :syn region htmlRef start=+<a>+ end=+</a>+ keepend contains=htmlItem,htmlScript
   :syn match htmlItem +<[^>]*>+ contained
   :syn region htmlScript start=+<script+ end=+</script[^>]*>+ contained extend

<	這裡，htmlItem 專案不擴充套件 htmlRef 專案，它只是用來高亮 <> 條目。而
	htmlScript 專案則擴充套件 htmlRef 專案。

	另一個例子: >
   :syn region xmlFold start="<a>" end="</a>" fold transparent keepend extend
<	定義使用 "keepend" 的區域，使得它的結尾不會被包含在內的專案所改變，比
	如匹配 "</a>" 以賦予不同高亮屬性的那些專案。但如果 xmlFold 區域本身嵌
	套 (自己包含自己)，則應用 "extend"，使得巢狀在內的 "</a>" 只會結束裡面
	的區域，而不是包含該區域的外層區域。

							*:syn-excludenl*
	當一個匹配專案的模式或者區域專案的結束模式包含 '$' 以匹配行尾的時候，
	包含該專案的外部區域專案會在下一行繼續。比如，使用 "\\$" (行尾出現的反
	斜槓) 的匹配專案可以使得一個通常在行尾結束的區域繼續下去。這是預設的行
	為。如果你不希望如此，有兩個解決方法:
	1. 外部專案使用 "keepend"。這會使得所有被包含的專案不能擴充套件外部的匹配
	   或區域專案。這可用於所有被包含的專案都不能擴充套件外部專案的場合。
	2. 在被包含的專案中使用 "excludenl"。這使得該匹配不能擴充套件外部的匹配或
	   區域專案。這可用於只有一些被包含的專案不需要擴充套件外部專案的場合。
	   "excludenl" 必須在它適用的模式之前給出。

							*:syn-matchgroup*
	"matchgroup" 可以用來高亮開始和/或結束模式，使之和區域本體不同。例
	如: >
  :syntax region String matchgroup=Quote start=+"+  skip=+\\"+	end=+"+
<	會使得引號本身使用 "Quote" 組高亮。而其中的文字使用 "String" 高亮組。
	"matchgroup" 用於其後所有的開始和結束模式，直到下一個 "matchgroup" 為
	止。使用 "matchgroup=NONE" 回到不使用 matchgroup 的情況。

	用 "matchgroup" 高亮的開始或結束模式的匹配文字不會用於包含在該區域內的
	專案。這樣可以避免被包含專案也能在開始或結束模式的匹配文字中匹配。
	"transparent" 選項不適用於使用 "matchgroup" 高亮的開始或結束模式的匹配
	文字。

	這裡是一個例子，它以不同的顏色高亮三層括號: >
   :sy region par1 matchgroup=par1 start=/(/ end=/)/ contains=par2
   :sy region par2 matchgroup=par2 start=/(/ end=/)/ contains=par3 contained
   :sy region par3 matchgroup=par3 start=/(/ end=/)/ contains=par1 contained
   :hi par1 ctermfg=red guifg=red
   :hi par2 ctermfg=blue guifg=blue
   :hi par3 ctermfg=darkgreen guifg=darkgreen
<
						*E849*
語法組的最大數目為 19999。

==============================================================================
6. :syntax 引數						*:syn-arguments*

定義語法專案的 :syntax 命令接受多個引數。其中，通用的部分在這裡解釋。這些引數
可以用任何順序給出，也可和模式相互間雜。

不是所有的命令都接受每個引數。下表顯示什麼引數不能在所有命令裡使用:
							*E395*
		    contains  oneline	fold  display  extend concealends~
:syntax keyword		 -	 -	 -	 -	 -	 -
:syntax match		是	 -	是	是	是	 -
:syntax region		是	是	是	是	是	是

以下引數可以在所有三個命令裡使用:
	conceal
	cchar
	contained
	containedin
	nextgroup
	transparent
	skipwhite
	skipnl
	skipempty

conceal						*conceal* *:syn-conceal*

如果給出 "conceal" 引數，本專案被標為可隱藏。實際隱藏與否取決於 'conceallevel'
選項的值。'concealcursor' 選項決定當前行的可隱藏專案是否會以正常方式顯示，以便
對本行進行編輯。
另一個隱藏文字的辦法是用 |matchadd()|。

concealends						*:syn-concealends*

如果給出 "concealends" 引數，區域的開始和結束匹配 (不包括區域內容本身) 被標為
可隱藏，實際隱藏與否取決於 'conceallevel' 選項的設定。只有這種方式，區域結束處
才可以用 "matchgroup" 來定義自己單獨的高亮隱藏方式。

cchar							*:syn-cchar*
							*E844*
"cchar" 引數定義代替可隱藏專案的字元 (只有給出 conceal 引數時設定 "cchar" 才有
意義)。如果沒有給出 "cchar"，預設的隱藏代替字元是 'listchars' 選項定義的字元。
該字元不能是控制字元，如製表符。示例: >
   :syntax match Entity "&amp;" conceal cchar=&
關於高亮，見 |hl-Conceal|。

contained						*:syn-contained*

如果給出 "contained" 引數，本專案在頂層不會被識別。只有包含在另外一個專案裡才
可以，而且那個專案必須給出 "contains" 引數且其中包含本專案。例如: >
   :syntax keyword Todo    TODO    contained
   :syntax match   Comment "//.*"  contains=Todo


display							*:syn-display*

如果給出 "display" 引數，本專案會在檢測到高亮不會顯示的時候被跳過。這樣，高亮
速度可以加快，因為只要發現要顯示的文字的語法狀態就可以跳過本專案。

通常，你使用 "display" 來匹配滿足以下條件的匹配和區域專案:
- 該專案不會跨過行尾。C 的例子: 包含 "/*" 的註釋不能使用 "display"，因為它會在
  下一行繼續。
- 該專案不包含會跨過行尾或使得本專案在下一行繼續的專案。
- 該專案不改變任何包含它在內的專案的大小。C 的例子: 預處理指令裡的匹配 "\\$"
  不能使用 "display"，因為它可以使得預處理指令的匹配變短。
- 該專案不允許其它專案匹配本來不能匹配的內容，而所擴充套件的匹配文字會走的太遠。C
  的例子: 定義 "//" 註釋的匹配不能使用 "display"，因為在該註釋裡的 "/*" 這時會
  匹配並開始一個跨越行尾的註釋。

例如，在 C 程式裡，"display" 可以用在:
- 數值的匹配
- 標籤的匹配


transparent						*:syn-transparent*

如果給出 "transparent" (透明) 引數，本專案自身不會被高亮，但會使用包含它的外層
專案的高亮屬性。這對本身不需要特殊高亮但要用來跳過一段文字的語法專案有用。

除非包含 transparent 的這個專案本身包含了 "contains" 引數，"contains="
引數會從外層的專案繼承，要避免包含不需要的專案，可使用 "contains=NONE"。例如，
高亮字串裡的單詞，但不包括 "vim": >
	:syn match myString /'[^']*'/ contains=myWord,myVim
	:syn match myWord   /\<[a-z]*\>/ contained
	:syn match myVim    /\<vim\>/ transparent contained contains=NONE
	:hi link myString String
	:hi link myWord   Comment
"myVim" 匹配出現在 "myWord" 之後，因而它是更優先的匹配 (在相同的位置上，後出
現的匹配優先於先出現的匹配)。"transparent" 引數使得 "myVim" 的匹配使用和
"myString" 相同的高亮，但它本身不再包含其它專案。如果沒有指定 "contains=NONE"
引數，那麼 "myVim" 會使用 myString 的 contains 引數，從而包含了 "myWord"，因而
被高亮為 Constant (譯者注: 應為 Comment)。這之所以會發生，是因為被包含的專案不
會在同樣的位置上匹配外層同一個語法專案，所以這裡，在最內層的 "myVim" 匹配不能
否決 "myWord" 的匹配。

如果你看有色彩的文字，它實際上是由一層層被包含的專案組成的。被包含的專案在包含
它的專案之上，因而你能看到被包含的專案。如果一個被包含的專案是透明的，你會看透
它，從而看到包含它的專案。以圖示之:

		從這裡看

	    |	|   |	|   |	|
	    V	V   V	V   V	V

	       xxxx	  yyy		被包含更深的專案
	    ....................	被包含專案 (透明)
	=============================	第一個專案

'x'、'y' 和 '=' 分別表示一種高亮的語法專案。'.' 代表透明層。

你實際看到的是:

	=======xxxx=======yyy========

這裡，你 "看穿" 了透明的 "...."。


oneline							*:syn-oneline*

"oneline" 引數指示本區域不會跨過行邊界。它必須在當前行內完整匹配。不過，如果本
區域包含跨行的專案，那麼本區域還是會從下一行繼續。被包含的專案可以用來識別續行
模式。不過，結束模式必須仍然在第一行上匹配，不然本區域根本不會開始。

如果開始模式包含 "\n" 從而匹配換行符，結束模式必須在開始模式結束處所在的同一行
上找到。該結束模式也可以包含換行符。因而，"oneline" 引數只是意味著開始模式的結
束處和結束模式的開始處必須在同一行上。這一點，即使跳過模式包含換行符也不能改
變。


fold							*:syn-fold*

"fold" 引數使得本專案的摺疊級別加 1。示例: >
   :syn region myFold start="{" end="}" transparent fold
   :syn sync fromstart
   :set foldmethod=syntax
這使得每個 {} 塊形成一個摺疊。

該摺疊從專案開始的行開始，而在專案結束之行上結束。如果開始和結束處在同一行，則
不形成摺疊。'foldnestmax' 選項限制語法摺疊的巢狀級別。
{僅當 Vim 編譯時帶 |+folding| 特性才有效}


			*:syn-contains* *E405* *E406* *E407* *E408* *E409*
contains={group-name},..

"contains" 引數跟隨語法組名的列表。這些組因而被允許包含在本專案裡 (它們可能擴
展包含它們的組的結束位置)。這使得匹配和區域的遞迴巢狀成為可能。如果沒有
"contains" 引數，本專案不能包含任何組。組名不需要在這裡的使用前定義。

contains=ALL
		如果唯一在包含列表裡出現的名字是 "ALL"，那麼本專案裡可以包含所
		有的組。

contains=ALLBUT,{group-name}...
		如果包含列表的第一個名字是 "ALLBUT"，那麼除了列出的那些以外，
		所有的組都可以出現在本專案裡。例如: >
  :syntax region Block start="{" end="}" ... contains=ALLBUT,Function

contains=TOP
		如果包含列表的第一個名字是 "TOP"，那麼所有不包含 "contained"
		引數的組都可以接受。
contains=TOP，{group-name},..
		類似於 "TOP"，但除了列出的組以外。

contains=CONTAINED
		如果包含列表的第一個名字是 "CONTAINED"，那麼所有包含
		"contained" 引數的組都可以接受。
contains=CONTAINED，{group-name},..
		類似於 "CONTAINED"，但列出的組除外。


"contains" 列表裡的 {group-name} 可以是模式。所有匹配該模式的組名都會包含進來
(或者排除出去，如果使用 "ALLBUT" 的話)。該模式不能包含空白或者 ','。例如: >
   ... contains=Comment.*,Keyw[0-3]
在執行 syntax 命令時完成該匹配。後來定義的組不會再參與匹配。另外，如果本
syntax 命令自己定義一個新組，它也不會參與匹配。小心: 在檔案裡放入 syntax 命令
的時候，你不能指望某些組_沒有_定義，因為該檔案以前可能已經執行過。而
":syn clear" 並不會刪除組名。

被包含的組也會匹配一個區域專案的開始和結束模式。如果不想如此，可以用
"matchgroup" 引數 |:syn-matchgroup|。"ms=" 和 "me=" 位移可以用來調整被包含項
目能夠匹配的區域。注意 這同時可能限制了高亮的區域。


containedin={group-name}...				*:syn-containedin*

"containedin" 引數跟隨語法組名的列表。然後，本專案就可以包含在那些組裡，就像那
些專案使用了包含本專案的 "contains=" 引數一樣。

{group-name}... 的使用方式和 "contains" 相同，見上面的解釋。

這可以用於後加的語法專案。一個專案可以告知要包含在已經存在的專案裡面，而無須修
改後者的定義。例如，要在載入 C 語法以後高亮 C 註釋裡的一個單詞:
	:syn keyword myword HELP containedin=cComment contained ~
注意 同時使用了 "contained" 引數是為了避免本專案在頂層得到匹配。

"containedin" 的匹配被加到該專案可以出現的其它地方。像平常一樣，本專案也可以使
用 "contains" 引數。不要忘記關鍵字專案不可能包含其它專案。所以把它們加在
"containedin" 裡是徒勞的。


nextgroup={group-name},..				*:syn-nextgroup*

"nextgroup" (下一個組) 引數跟隨語法組名的列表，以逗號分隔 (和 "contains" 類
似，你也可以使用模式)。

如果給出 "nextgroup" 引數，提到的語法組會在本匹配或區域結束之後嘗試匹配。如果
沒有一個組能夠匹配，高亮和平常一樣繼續。如果有匹配，則使用匹配的組高亮，即使該
組沒有在當前組的 "contains" 欄位裡提到，就像這裡的組給賦予了比其它的組更高的優
先級一樣。例如: >
   :syntax match  ccFoobar  "Foo.\{-}Bar"  contains=ccFoo
   :syntax match  ccFoo     "Foo"	    contained nextgroup=ccFiller
   :syntax region ccFiller  start="."  matchgroup=ccBar  end="Bar"  contained

會分別高亮 "Foo" 和 "Bar"，但只有在 "Bar" 跟在 "Foo" 之後才行。在下面的文字行
裡，"f" 顯示使用 ccFoo 的高亮，而 "bbb" 則是使用 ccBar 的地方。

   Foo asdfasd Bar asdf Foo asdf Bar asdf
   fff	       bbb	fff	 bbb

注意 ".\{-}" 的使用跳過儘可能少的內容以到達下一個 Bar。如果使用了 ".*"，"Bar"
和 "Foo" 之間的 "asdf" 會以 "ccFoobar" 組高亮，因為 ccBar 匹配行內第一個 "Foo"
和最後一個 "Bar" 的全部內容 (見 |pattern|)。


skipwhite						*:syn-skipwhite*
skipnl							*:syn-skipnl*
skipempty						*:syn-skipempty*

這些引數只能和 "nextgroup" 組合使用。它們可以用來指定如何跳過一些文字到達下一
個組:
	skipwhite	跳過空格和製表字元
	skipnl		跳過換行符
	skipempty	跳過空行 (意味著 "skipnl")

如果 "skipwhite" 存在，空白字元只有在沒有下一個組會匹配空白時才會跳過。

如果 "skipnl" 存在，下一個組的匹配會在第二行內尋找。這隻有在當前專案在行尾結束
時才會發生！如果 "skipnl" 不存在，下一個組只會在當前專案相同的行上尋找。

如果在尋找下一個組時跳過文字，其它組的匹配就會忽略。只有在沒有下一個組匹配時，
其它的專案才會重新嘗試被匹配。這意味著下一個組，包括跳過的空白和 <EOL>，的匹配
比其它專案的優先順序要高。

示例: >
  :syn match ifstart "\<if.*"	nextgroup=ifline skipwhite skipempty
  :syn match ifline  "[^ \t].*" nextgroup=ifline skipwhite skipempty contained
  :syn match ifline  "endif"	contained
注意 "[^ \t].*" 匹配所有的非空白文字。這樣，它也能匹配 "endif"。所以 "endif"
匹配專案必須放在最後，以取得優先權。
注意 本例子不適用於巢狀的 "if"。你需要加上 "contains" 引數才行 (本例之所以省
略，是為了簡潔起見)。

隱 含 隱 藏						*:syn-conceal-implicit*

:sy[ntax] conceal [on|off]
	指令後續的 ":syntax" 命令所定義的關鍵字、匹配或區域是否會自動帶上
	"conceal" 標誌位。":syn conceal on" 之後的所有 ":syn keyword"、
	":syn match" 或 ":syn region" 會隱含地帶上 "conceal" 標誌位。而
	":syn conceal off" 回覆到正常狀態，必須顯式給出 "conceal" 標誌位。

:sy[ntax] conceal
	顯示 "syntax conceal on" 或 "syntax conceal off" 之一 (經過翻譯)。

==============================================================================
7. 語法模式					*:syn-pattern* *E401* *E402*

在 syntax 命令裡，模式必須被兩個相同的字元包圍。這和 ":s" 命令類似。最常用的是
雙引號。但如果模式本身包含雙引號，你可以使用別的不在模式裡出現的字元。例如: >
  :syntax region Comment  start="/\*"  end="\*/"
  :syntax region String   start=+"+    end=+"+	 skip=+\\"+

關於模式的解釋，見 |pattern|。對語法模式的解釋總是假設打開了 'magic' 選項，而
與實際的 'magic' 值無關。而且也假設 'cpoptions' 裡沒有 'l' 標誌位。這些設定使
得語法檔案易移植，而獨立於 'compatible' 和 'magic' 的設定。

要避免能夠匹配空字串的模式，比如 "[a-z]*"。這會顯著減慢高亮，因為這樣的模式
會在任何地方得到匹配。

						*:syn-pattern-offset*
模式可以後跟一個字元位移。它可以用來修改高亮的部分，也可以修改匹配或區域專案的
文字區域 (只有其它專案的匹配會受影響)。兩者都是相對於已經匹配的模式的。跳過模
式的字元位移可以用來指示從哪裡開始繼續尋找結束模式。

位移的形式是 "{what}={offset}"
{what} 可以是七種字串之一:

ms	匹配開始	匹配文字開始的偏移
me	匹配結束	匹配文字結束的偏移
hs	高亮開始	高亮開始的偏移
he	高亮結束	高亮開始的偏移
rs	區域開始	區域本體開始的偏移
re	區域結束	區域本體結束的偏移
lc	引導上下文	超越模式的 "引導上下文" 的偏移

{offset} 可以是:

s	模式匹配部分的開始位置
s+{nr}	模式匹配部分的開始位置向右 {nr} 個字元
s-{nr}	模式匹配部分的開始位置向左 {nr} 個字元
e	模式匹配部分的結束位置
e+{nr}	模式匹配部分的結束位置向右 {nr} 個字元
e-{nr}	模式匹配部分的結束位置向左 {nr} 個字元
{nr}	(只用於 "lc"): 從開始處向右 {nr} 個字元開始匹配

例如: "ms=s+1"，"hs=e-2"，"lc=3"。

儘管所有的位移形式在任何模式之後都能接受，它們不都有意義。下表說明什麼樣的位移
在實際中會應用到:

		    ms	 me   hs   he	rs   re	  lc ~
匹配專案	    是   是   是   是 	-    -	  是
區域專案開始模式    是   -    是   -	是   -	  是
區域專案跳過模式    -	 是   -    -	-    -	  是
區域專案結束模式    -	 是   -    是 	-    是   是

位移可用 ',' 連線。例如: >
  :syn match String  /"[^"]*"/hs=s+1,he=e-1
<
    一些 "字串" 文字
	  ^^^^^^		高亮部分

注意:
- 模式和位移字元之間不能有空白。
- 高亮區域永遠不會超出匹配文字的範圍。
- 結束模式上的負偏移不一定總能用，因為結束模式可能在高亮本應結束的地方才檢測
  到。
- Vim 7.2 之前，位移用位元組數而不是字元數計算。這對多位元組字元不適用，所以 Vim
  7.2 版本發行時改了。
- 匹配不能從實際匹配的模式所在的行之外開始。這樣不行: "a\nb"ms=e。高亮可以從另
  一個行開始，這樣沒有問題: "a\nb"hs=e。

示例 (匹配註釋，但不高亮 /* 和 */): >
  :syntax region Comment start="/\*"hs=e+1 end="\*/"he=s-1
<
	/* 這是一個註釋 */
	  ^^^^^^^^^^^^^^	  高亮部分

一個更復雜的例子: >
  :syn region Exa matchgroup=Foo start="foo"hs=s+2,rs=e+2 matchgroup=Bar end="bar"me=e-1,he=e-1,re=s-1
<
	 abcfoostringbarabc
	    mmmmmmmmmmm	    匹配
	      ssrrrreee	    高亮 開始 (s)/區域 (r)/結束 (e)
	      			("Foo"、"Exa" 和 "Bar")

引導上下文			*:syn-lc* *:syn-leading* *:syn-context*

注意: 這是一個已經廢棄的特性，包含它只是為了和以前的 Vim 版本後向相容。現在，
我們推薦使用在模式裡使用 |/\@<=| 構造。

"lc" 位移指定引導上下文 -- 模式的一部分: 必須存在，但不包含在實際的匹配中。形
如 "lc=n" 的位移會使得 Vim 在試圖匹配模式前先後退 n 列，從而可以使得已在較早的
模式中匹配的字元仍然可以做為本匹配的引導上下文。這可用於，比如說，要求本匹配不
出現在某個前導的 "轉義" 字元之後: >

  :syn match ZNoBackslash "[^\\]z"ms=s+1
  :syn match WNoBackslash "[^\\]w"lc=1
  :syn match Underline "_\+"
<
	  ___zzzz ___wwww
	  ^^^	  ^^^	  匹配 Underline
	      ^ ^	  匹配 ZNoBackslash
		     ^^^^ 匹配 WNoBackslash

"ms" 位移自動設為與 "lc" 位移相同的值，除非你顯式地設定 "ms"。


多行模式						*:syn-multi-line*

模式裡可以包含 "\n" 匹配換行符。多數情況下，它能正常工作，但有以下一些例外。

使用帶位移的開始模式時，匹配不允許從真實匹配之後的行開始。不過，高亮不存在這樣
的問題。"\zs" 專案也同樣需要匹配的開始不能移動到另一行。

跳過模式可以包含 "\n"，但結束模式的搜尋會從下一行的第一個字元開始，即使跳過模
式匹配該字元也是如此。這是因為重畫可以從區域中間的任何一行啟動，而不會檢查跳過
模式是否從那一行之前就已經開始的緣故。例如，如果跳過模式是 "a\nb" 而結束模式為
"b"，結束模式的確會匹配下面情況的第二行: >
	 x x a
	 b x x
通常，這意味著跳過模式不應匹配 "\n" 之後的任何字元。


外部匹配						*:syn-ext-match*

以下附加的正規表示式專案可以用在區域專案的模式中:

					*/\z(* */\z(\)* *E50* *E52* *E879*
    \z(\)	標記該子表示式為 "外部的"，這意味著它可以在別的模式匹配裡訪
		問。目前，只能在語法區域的開始模式中應用。

					*/\z1* */\z2* */\z3* */\z4* */\z5*
    \z1  ...  \z9			*/\z6* */\z7* */\z8* */\z9* *E66* *E67*
		匹配和前面的開始模式匹配裡相應子表示式的匹配的相同的字串。

有時區域專案的開始和結束模式需要共享一個相同的子表示式。常見的例子是 Perl 和許
多 Unix 外殼裡的 "here" 文件。這種效果可以通過特殊的 "\z" 正規表示式專案完成。
它把子表示式標為 "外部的"，也就是說可以從定義所在的模式的外部引用。例如，here
文件的例子可以如此完成: >
  :syn region hereDoc start="<<\z(\I\i*\)" end="^\z1$"

由此可見，\z 實際上有雙重任務。在開始模式裡，它標記 "\(\I\i*\)" 子表示式為外部
的；在結束模式裡，它把 \z1 反向引用重新定義為指向開始模式裡的第一個外部子表達
式的外部引用。跳過模式裡也可以使用外部引用: >
  :syn region foo start="start \(\I\i*\)" skip="not end \z1" end="end \z1"
<
注意 普通和外部子表示式是完全不相關聯，它們分別索引。如果模式 "\z(..\)\(..\)"
應用於字串 "aabb"，\1 會指向 "bb" 而 \z1 會指向 "aa"。也要 注意，外部子表達
式不能和普通的子表示式那樣，在同一個模式裡作為反向引用來訪問。如果你需要把一個
子表示式同時作為普通和外部子表示式來使用，可以巢狀使用這兩者，形如
"\(\z(...\)\)"。

注意 這裡只能使用行內的匹配，不能從外部引用多行匹配。

==============================================================================
8. 語法簇						*:syn-cluster* *E400*

:sy[ntax] cluster {cluster-name} [contains={group-name}..]
				 [add={group-name}..]
				 [remove={group-name}..]

本命令允許你把若干語法組捆綁在一起，以便使用單個名字訪問。

	contains={group-name}..
		本簇使用此處指定的組名列表。
	add={group-name}..
		將指定的組加入本簇。
	remove={group-name}..
		將指定的組從本簇裡刪除。

用這種方式定義的簇可以在 contains=..、containedin=..、nextgroup=..、add=.. 或
者 remove=.. 的列表裡使用，只要加上 "@" 字首即可。用這種表示方式，你可以隱含地
在指定一個簇的內容之前先宣告之。

示例: >
   :syntax match Thing "# [^#]\+ #" contains=@ThingMembers
   :syntax cluster ThingMembers contains=ThingMember1,ThingMember2

如同前例所暗示的，對簇的修改追溯既往；可以說，在最後一刻才進行簇成員身份的檢
查: >
   :syntax keyword A aaa
   :syntax keyword B bbb
   :syntax cluster AandB contains=A
   :syntax match Stuff "( aaa bbb )" contains=@AandB
   :syntax cluster AandB add=B	  " 現在兩個關鍵字都在 Stuff 裡匹配

對巢狀的簇而言，這也有若干意含: >
   :syntax keyword A aaa
   :syntax keyword B bbb
   :syntax cluster SmallGroup contains=B
   :syntax cluster BigGroup contains=A,@SmallGroup
   :syntax match Stuff "( aaa bbb )" contains=@BigGroup
   :syntax cluster BigGroup remove=B	" 沒有效果，因為 B 不在 BigGroup 裡
   :syntax cluster SmallGroup remove=B	" 現在 Stuff 不再匹配 bbb
<
						*E848*
簇的最大數目是 9767。

==============================================================================
9. 包含語法檔案						*:syn-include* *E397*

一個語言的語法檔案經常需要包含相關語言的語法檔案。取決於它們實際的關係，可以用
兩種不同的方式完成:

	- 如果允許被包含的語法檔案裡的頂層的語法專案也出現在包含它的語法的頂層
	  中，可以簡單的使用 |:runtime| 命令: >

  " 在 cpp.vim 裡:
  :runtime! syntax/c.vim
  :unlet b:current_syntax

<	- 如果被包含的語法檔案裡的頂層語法專案應在包含它的語法的某區域中應用，
	  可以使用 ":syntax include" 命令:

:sy[ntax] include [@{grouplist-name}] {file-name}

	  被包含檔案裡定義所有的語法專案會自動加上 "contained" 標誌。同時，如
	  果指定了組群 (簇)，被包含檔案所有的頂層語法專案會加到該組群裡。 >

   " 在 perl.vim 裡:
   :syntax include @Pod <sfile>:p:h/pod.vim
   :syntax region perlPOD start="^=head" end="^=cut" contains=@Pod
<
	  如果 {file-name} 是絕對路徑 (以 "/"、"c:"、"$VAR" 或者 "<sfile>" 開
	  始)，則載入該檔案。如果它是是相對路徑 (例如，"syntax/pod.vim")，則先
	  在 'runtimepath' 裡搜尋該檔案，然後載入所有匹配的檔案。建議使用相對
	  路徑，因為它允許使用者用自己的版本替代被包含的檔案，而不用修改使用
	  ":syn include" 命令的檔案。

						*E847*
包含的最大數目是 999。

==============================================================================
10. 同步					*:syn-sync* *E403* *E404*

Vim 期待在文件的任何位置都能開始重畫過程。為此目的，它需要知道重畫開始所在的位
置相應的語法狀態。

:sy[ntax] sync [ccomment [group-name] | minlines={N} | ...]

有四個同步方法:
1. 總是從檔案頭開始分析。
   |:syn-sync-first|
2. 基於 C 風格的註釋。Vim 理解 C 註釋的工作方式，因而可以發現當前行是在註釋裡
   面還是外面。
   |:syn-sync-second|
3. 回跳若干行，從那裡開始分析。
   |:syn-sync-third|
4. 反向搜尋某模式的匹配文字，從那裡開始同步。
   |:syn-sync-fourth|

				*:syn-sync-maxlines* *:syn-sync-minlines*
對於後三個方法而言，開始分析所在的行範圍受到 "minlines" 和 "maxlines" 的限制。

如果給出 "minlines={N}" 引數，分析總是至少倒退給出的行數，然後才開始。這適用於
分析過程在能判斷正確之前至少需要若干行的情況、或者完全無法使用同步機制的場合。

如果給出 "maxlines={N}" 引數，反向搜尋註釋或者同步用搜索模式的行數限於 N 行之
內 (包括 "minlines" 指定的行數)。可用於同步的專案較少且機器較慢的場合。例如:
>
   :syntax sync maxlines=500 ccomment
<
						*:syn-sync-linebreaks*
使用可以匹配多行的模式時，某行的改變可以使得匹配不再能從上一行開始匹配。這意味
著同步必須從改變發生所在位置之前就進行。具體需要多少行可由 "linebreaks" 引數指
定。例如，如果模式包含一個換行符，可以這樣: >
   :syntax sync linebreaks=1
結果是，重畫至少從改變所在之前的一行開始。預設的 "linebreaks" 值為零。通常，
"minlines" 的值比 "linebreaks" 要大。


第一種同步方法:				*:syn-sync-first*
>
   :syntax sync fromstart

檔案從頭開始分析。這使得語法高亮完全準確，但對很長的檔案需時也久。Vim 預存以前
分析過的文字，所以只有第一次分析文字的時候才會緩慢。不過，如果修改了文字，其後
的部分需要重新分析 (最差情況下: 一直到檔案尾)。

使用 "fromstart" 等價於把 "minlines" 指定為很大的數字。


第二種同步方法:				*:syn-sync-second* *:syn-sync-ccomment*

第二種方法只需指定 "ccomment" 引數。示例: >
   :syntax sync ccomment

Vim 如果發現顯示開始的行出現在 C 風格註釋的內部，就使用組名為 "Comment" 的最後
一個區域語法專案。這需要組名為 "Comment" 的區域專案存在！也可指定替代的組名，
例如: >
   :syntax sync ccomment javaComment
這意味著最後出現的 "syn region javaComment" 會用來檢測 C 註釋的區域。只有該區
域確實包含了開始模式 "\/*" 和結束模式 "*\/" 的時候才能有效。

"maxlines" 引數可以用來限制搜尋的行數。"minlines" 引數用來指定至少回退若干行才
開始 (例如一些只佔用若干行，但很難同步的構造)。

注意: 如果使用跨行且包含 "*/" 的字串，C 註釋的同步方法不一定能正確工作。讓字
符串跨行是一個不好的程式設計習慣 (許多編譯器會給出警告)，而 "*/" 出現在註釋 (譯者
注: 應為字串) 的機率又相當小，一般很難注意到這個限制。


第三種同步方法:				*:syn-sync-third*

第三種同步方法只要指定 "minlines={N}" 引數。Vim 會從行號上減去 {N} 然後從那裡
開始分析。這意味著需要額外分析 {N} 行，該方法也因此較慢。例如: >
   :syntax sync minlines=50

"lines" 等價於 "minlines" (用於較老的版本)。


第四種同步方法:				*:syn-sync-fourth*

本方法試圖在若干指定區域的一端同步，稱為同步模式。因為只有區域可以跨行。所以如
果我們能找到某區域的一端，或許就可以知道現在在哪個語法專案之中。該方法中，搜尋
從重畫開始所在的上一行開始，然後在檔案中反向進行。

和非同步的語法專案類似，同步專案也可以使用 contained、matches、nextgroup 等。
但有如下區別:
- 不能使用關鍵字專案。
- 使用 "sync" 關鍵字的語法專案構成完全獨立的語法專案組。你不能混合同步組和非同
  步組。
- 匹配在緩衝區裡 (逐行) 反向進行，而不是正向。
- 可以給出續行模式，用於決定哪些行的組合可以在搜尋時當成單行。這意味著搜尋指定
  專案的匹配從包含續行模式的連續多行的第一行開始。
- "nextgroup" 或 "contains" 只適用於一行 (或者連續行構成的組合) 之內。
- 使用區域專案時，必須在同一行上 (或者連續行構成的組合) 開始和結束。否則，假定
  行尾 (或者連續行構成的組合的尾部) 會結束此專案。
- 如果找到同步模式的匹配，該行 (或者連續行構成的組合) 的其餘部分會搜尋其它匹
  配。最後發現的匹配被使用。這可以用於同時包括區域開始和結束的行 (例如，C 註釋
  /* this */，使用最後找到的 "*/")。

有兩個使用同步模式的匹配方法:
1. 高亮分析從重畫開始處開始 (也就是同步模式的搜尋起點)。必須指定在那裡出現的合
   法語法組。如果跨行的區域不會包含別的區域時，這很有效。
2. 高亮分析從匹配之後立即開始。必須指定匹配之後立即出現的合法語法組。可
   用於上述方法不適用的情形。它慢得多，因為需要分析更多的文字。
可以同時使用兩種型別的同步模式。

除了同步模式以外，還可以指定另外的匹配和區域專案，以跳過不需要的匹配。

[之所以單獨給出同步模式，是因為多數情況下，同步點的搜尋比高亮部分的確定要簡單
得多。而模式的減少意味著速度的 (大大) 加快。]

					    *syn-sync-grouphere* *E393* *E394*
    :syntax sync match {sync-group-name} grouphere {group-name} "pattern" ..

	"這裡的組"，定義用於同步的匹配。{group-name} 為匹配之後立刻出現的語法
	組名 (譯者注: 但不一定從那裡開始，尤其是同步模式本身就可以屬於該組)。
	文字的高亮分析在匹配之後立刻進行。{group-name} 至少應包含一個區域項
	目，並使用其中的第一個這樣的定義。"NONE" 用來指示匹配之後不存在語法
	組。

						*syn-sync-groupthere*
    :syntax sync match {sync-group-name} groupthere {group-name} "pattern" ..

	"那裡的組"，類似於 "grouphere"，但 {group-name} 是在同步點的搜尋起點所
	在行的行首使用的語法組名。匹配和同步點的搜尋起點之間的文字假定不會改變
	語法的高亮。例如，在 C 裡，你可以反向搜尋 "/*" 和 "*/"。如果先找到
	"/*"，你知道在註釋內部，所以 "那裡的組" 是 "cComment"。如果先找到
	"*/" ，你知道不在註釋裡，所以 "那裡的組" 是 "NONE"。(實際應用中更復
	雜，因為 "/*" 和 "*/" 可以出現在字串中。留給讀者作為練習吧……)。

    :syntax sync match ..
    :syntax sync region ..

	沒有 "groupthere" 引數。定義區域或匹配專案，在同步點搜尋過程中跳過這些
	專案 (譯者注: 注意 同步模式只能使用匹配專案，但在這裡定義的同步過程的
	"跳過" 模式可以指定區域或匹配專案。區域專案的限制上面已有敘述)。

						*syn-sync-linecont*
    :syntax sync linecont {pattern}

	如果 {pattern} 在行內匹配，本行被認為會在下一行繼續。這意味著同步點的
	搜尋會把這些行當作連線在一起的一行處理。

如果同時給出 "maxlines={N}" 引數，尋找匹配的搜尋行數限於 N 行之內。可以用於同
步專案很少且機器速度較慢的場合。例如: >
   :syntax sync maxlines=100

你可以這樣清除所有的同步設定: >
   :syntax sync clear

你也可以清除特定的同步模式: >
   :syntax sync clear {sync-group-name} ..

==============================================================================
11. 列出語法專案			*:syntax* *:sy* *:syn* *:syn-list*

本命令列出所有的語法專案: >

    :sy[ntax] [list]

要顯示單個語法組的所有語法專案: >

    :sy[ntax] list {group-name}

要列出單個簇的所有語法組:					*E392*  >

    :sy[ntax] list @{cluster-name}

":syntax" 命令的其它引數見上。

注意 ":syntax" 命令可以簡化成 ":sy"，不過 ":syn" 更常用，因為看起來更舒服點。

==============================================================================
12. Highlight 命令			*:highlight* *:hi* *E28* *E411* *E415*

有三種類型的高亮組:
- 用於特定語言的。這些組的名字以該語言的名字開始。它們中很多沒有屬性，而是連結
  到第二種型別的組。
- 用於所有語法語言的。
- 用於 'highlight' 選項的。
							*hitest.vim*
用這個命令，你可以看到當前啟用的所有組: >
    :so $VIMRUNTIME/syntax/hitest.vim
它會開啟一個新視窗，其中包含所有的高亮組名，以它們本身的顏色顯示。

						*:colo* *:colorscheme* *E185*
:colo[rscheme]		輸出當前啟用的色彩方案名。基本上等同 >
				:echo g:colors_name
<			如果 g:colors_name 沒有定義 :colo 會輸出 "default"。如
			果編譯時沒有帶 |+eval| 特性，輸出 "unknown"。

:colo[rscheme] {name}	載入色彩方案 {name}。它會在 'runtimepath' 裡搜尋
			"colors/{name}.vim"，載入第一個找到的檔案。
			也在 'packpath' 中的所有外掛裡尋找，先在 "start" 下，
			然後在 "opt" 下查詢。

			它不能遞迴呼叫，所以你不能在色彩方案腳本里使用
			":colorscheme"。

			要定製色彩方案，用新名，如 "~/.vim/colors/mine.vim"，
			並用 `:runtime` 載入原來的色彩方案: >
				runtime colors/evening.vim
				hi Statement ctermfg=Blue guifg=Blue

<			色彩方案載入後，啟用 |ColorScheme| 自動命令事件。關於
			如何編寫色彩方案檔案的資訊: >
				:edit $VIMRUNTIME/colors/README.txt

:hi[ghlight]		列出當前所有的有屬性設定的高亮組。

:hi[ghlight] {group-name}
			列出一個高亮組。

:hi[ghlight] clear	復位高亮設定為預設值。刪除所有使用者增加的組的高亮屬性。
			用當前的 'background' 的值來決定所使用的預設顏色。

:hi[ghlight] clear {group-name}
:hi[ghlight] {group-name} NONE
			遮蔽一個高亮組的所有高亮設定。並_不_復原預設的顏色。

:hi[ghlight] [default] {group-name} {key}={arg} ..
			增加高亮組，或者更改已有的組高亮設定。
			|highlight-args| 說明 {key}={arg} 的引數。
			|:highlight-default| 說明可選的 [default] 引數。

通常，在啟動時加入高亮組。它設定高亮的預設值。在這之後，你可以使用附加的
highlight 命令來修改你希望設定為非預設值的引數。也可以用 "NONE" 來撤銷某個值並
恢復預設的值。

修改顏色的簡單方式是 |:colorscheme| 命令。它載入一個檔案，裡面包含了這樣的
":highlight" 命令: >

   :hi Comment	gui=bold
<
注意 所有沒有包含在內的設定都保持原樣，只使用指定的欄位，從而和以前的設定進行
了合併。所以實際結果就像用了下面這樣的一條命令: >
   :hi Comment	term=bold ctermfg=Cyan guifg=#80a0ff gui=bold
<
							*:highlight-verbose*
如果列出高亮組時 'verbose' 非零，同時列出高亮組最近在哪裡設定。例如: >
	:verbose hi Comment
<	Comment        xxx term=bold ctermfg=4 guifg=Blue ~
	   Last set from /home/mool/vim/vim7/runtime/syntax/syncolor.vim ~

如果使用了 ":hi clear"，那麼列出預設值的同時提到使用該命令的指令碼。詳見
|:verbose-cmd|。

					*highlight-args* *E416* *E417* *E423*
用於高亮，有三種類型的終端:
term	普通的終端 (vt100、xterm)
cterm	色彩終端 (MS-DOS 控制檯、color-xterm，帶有 "Co" termcap 專案的終端)
gui	GUI

每種型別可以分別設定高亮屬性。這樣，單個語法檔案就可用於所有的終端，並使用每個
終端最優的高亮設定。

1. 普通終端的高亮引數

					*bold* *underline* *undercurl*
					*inverse* *italic* *standout*
term={attr-list}			*attr-list* *highlight-term* *E418*
	attr-list 是逗號分隔的下述專案 (不能有空格) 的列表 (任何順序都可以):
		bold
		underline
		undercurl	不一定總是可用
		reverse
		inverse		等同於 reverse
		italic
		standout
		NONE		不使用屬性 (用於復位)

	注意 這裡使用 "bold" 和使用粗體字型都可以，效果相同。
	"undercurl" 是波浪狀的下劃線。如果不能用 "undercurl"，使用 "underline"
	代替。一般，只有 GUI 才能使用 "undercurl"。顏色可用 |highlight-guisp|
	設定。

start={term-list}				*highlight-start* *E422*
stop={term-list}				*term-list* *highlight-stop*
	可以得到終端上的非標準的屬性的終端程式碼的列表。

	"start" 引數指定的轉義碼序列在高亮區域的字元之前被寫入，它可以是你希望
	給終端傳送的用於高亮區域的任何內容。"stop" 引數指定的轉義碼序列在高亮
	區域之後被寫入，它可以撤銷 "start" 引數的效果。否則螢幕會被弄亂。

	{term-list} 可有兩種形式:

	1. 轉義序列的字串。
	   可以是任何字元的序列，除了不能以 "t_" 開始而且不能有空格之外。這裡
	   識別 <> 記法。所以你可使用 "<Esc>" 和 "<Space>"。例如:
		start=<Esc>[27h;<Esc>[<Space>r;

	2. 終端程式碼的列表。
	   終端程式碼的形式是 "t_xx" ，其中 "xx" 是 termcap 專案的名字。這些程式碼
	   必須以逗號分隔，而且不允許有空格。例如:
		start=t_C1,t_BL
	   要使之工作，這些終端程式碼必須存在。


2. 色彩終端的高亮引數

cterm={attr-list}					*highlight-cterm*
	{attr-list} |attr-list| 的描述見上。"cterm" 引數可以和 "term" 不同，比
	如可以使用顏色。例如，在普通的終端上註釋可以用下劃線表示，在色彩終端上
	可以用藍色顯示。
	注意: 許多終端 (例如，DOS 控制檯) 不能混合使用顏色和這些屬性。這時，只
	用 "cterm=" 或者 "ctermfg=" 與 "ctermbg=" 兩者之一。

ctermfg={color-nr}				*highlight-ctermfg* *E421*
ctermbg={color-nr}				*highlight-ctermbg*
	{color-nr} 引數指定顏色號。其範圍從零到 termcap 專案 "Co" 給出的數字
	(不含)。實際的顏色取決於終端的型別和設定。有時，顏色也取決於 "cterm"
	的值。例如，有的系統上 "cterm=bold ctermfg=3" 給出另外一個顏色，別的系
	統上你只會得到顏色 3。

	xterm 上，它取決於你的資源，這並不容易預測。你的 xterm 文件會說明預設
	值。color-xterm 的顏色可以通過 .Xdefaults 檔案修改。不幸的是，這意味著
	每個使用者未必會得到完全相同的顏色。|xterm-color| 提供帶色彩的 xterm 的
	資訊。

	MSDOS 的標準顏色是固定的 (在控制視窗上)，所以我們用這些名字。在 X11
	上，顏色名字的含義是固定的，所以我們用這些顏色設定，以使高亮設定可移植
	(是不是很複雜？)。下面列出這些被識別的名字和所使用的顏色號:

							*cterm-colors*
	    NR-16   NR-8    顏色名 ~
	    0	    0	    Black (黑)
	    1	    4	    DarkBlue (深藍)
	    2	    2	    DarkGreen (深綠)
	    3	    6	    DarkCyan (深青)
	    4	    1	    DarkRed (深紅)
	    5	    5	    DarkMagenta (深品紅)
	    6	    3	    Brown，DarkYellow (褐、深黃)
	    7	    7	    LightGray、LightGrey，Gray，Grey (淺灰)
	    8	    0*	    DarkGray，DarkGrey (深灰)
	    9	    4*	    Blue，LightBlue (淺藍)
	    10	    2*	    Green，LightGreen (淺綠)
	    11	    6*	    Cyan，LightCyan (淺青)
	    12	    1*	    Red，LightRed (淺品紅)
	    13	    5*	    Magenta，LightMagenta (淺紅)
	    14	    3*	    Yellow，LightYellow (淺黃)
	    15	    7*	    White (白)

	"NR-16" 下的數字用於 16 色的終端 ('t_Co' 大於等於 16)。"NR-8" 下的數字
	用於 8 色終端 ('t_Co' 小於 16)。'*' 表明 ctermfg 使用的時候設定 bold
	屬性。在許多 8 色終端上 (比如，"linux")，它會顯示增亮的顏色。但這不適
	用於背景色。如果沒有 '*'，則不包含 bold 屬性。如果你想用不同的方式設定
	bold 屬性，在 "ctermfg=" 或 "ctermbg=" 引數_之後_設定 "cterm=" 引數。
	或者使用數字，而不是顏色名。

	忽略顏色名的大小寫。
	注意 16 色 ansi 風格的終端 (包括 xterm) 使用 NR-8 一列的數字。這裡，
	'*' 意味著 '加 8'，所以 Blue 成了 12，DarkGray 是 8，依此類推。

	注意 有些色彩終端下，這些名字可能會產生錯誤的顏色！

	也可用 "NONE" 來刪除顏色。

							*:hi-normal-cterm*
	Normal 組設定的 "ctermfg" 或 "ctermbg" 顏色成為非高亮文字使用的顏色。
	例如: >
		:highlight Normal ctermfg=grey ctermbg=darkblue
<	設定 Normal 組的 "ctermbg" 顏色時，假定此顏色能識別而 'background' 還
	未顯式設定過，會自動設定 'background' 選項。這使得依賴於 'background'
	的高亮組會發生改變！這意味著，你應該先設定 Normal 的顏色，然後再設定其
	它的。
	已經使用色彩方案的時候，修改 'background' 使之被重新載入，這會復位所有
	顏色 (包括 Normal)。如果你不希望如此，先刪除 "g:colors_name" 變數。

	如果你給 Normal 組設定了 "ctermfg" 或 "ctermbg"，Vim 退出時需要復位顏
	色，這通過 "op" termcap 專案 |t_op| 完成。如果不能正確工作，嘗試在你的
	.vimrc 裡設定 't_op' 選項。
							*E419* *E420*
	如果 Vim 知道 Normal 的前景和背景色，"fg" 和 "bg" 可以用做顏色名字。這
	只有在設定了 Normal 組的顏色以後和 (譯者注: 或？) 在 MS-DOS 控制檯上才
	可以。比如，設定反顯視訊: >
	    :highlight Visual ctermfg=bg ctermbg=fg
<	注意 使用的顏色必須在給出命令的時候已經合法。如果之後 Normal 組的顏色
	發生改變，"fg" 和 "bg" 顏色不會被調整。


3. GUI 的高亮引數

gui={attr-list}						*highlight-gui*
	給出 GUI 模式適用的屬性。具體描述見 |attr-list|。
	注意 這裡可以使用 "bold"，也可以使用粗體字型。效果相同。
	注意 "Normal" 組的屬性被忽略。

font={font-name}					*highlight-font*
	font-name 是字型的名字，根據 Vim 執行所在的系統而定。X11 而言，它是一
	個複雜的名字。比如: >
   font=-misc-fixed-bold-r-normal--14-130-75-75-c-70-iso8859-1
<
	字型名 "NONE" 可以用來恢復到預設字型。如果為 "Normal" 組設定字型，該字
	體成為預設字型 (直到改變了 'guifont' 選項為止；使用最後設定的那個)。
	以下說明只適用於 Motif 和 Athena，不包括其它 GUI:
	設定 "Menu" 組的字型會改變選單。設定 "Tooltip" 組的字型會改變工具提
	示。除了 Menu 和 Tooltip 的所有使用的字型必須和預設字型的字元大小相
	同。否則，重畫時會有問題。
	要用含有內嵌空格或其它特殊字元的字型名，把名字放在單引號內。因而，不能
	使用單引號本身。
	例如: >
	    :hi comment font='Monospace 10'

guifg={color-name}					*highlight-guifg*
guibg={color-name}					*highlight-guibg*
guisp={color-name}					*highlight-guisp*
	給出 GUI 使用的前景色 (guifg)、背景色 (guibg) 和特殊顏色 (guisp)。
	"guisp" 用於 undercurl。可用一些特殊的名字:
		NONE		沒有顏色 (透明)
		bg		使用 Normal 的背景色
		background	使用 Normal 的背景色
		fg		使用 Normal 的前景色
		foreground	使用 Normal 的前景色
	要使用有內嵌空格或者其它特殊字元的顏色名，把它放在單引號裡面。這時，不
	能使用單引號。例如: >
	    :hi comment guifg='salmon pink'
<
							*gui-colors*
	建議的顏色名 (可用於多數系統):
	    Red		LightRed	DarkRed
	    Green	LightGreen	DarkGreen	SeaGreen
	    Blue	LightBlue	DarkBlue	SlateBlue
	    Cyan	LightCyan	DarkCyan
	    Magenta	LightMagenta	DarkMagenta
	    Yellow	LightYellow	Brown		DarkYellow
	    Gray	LightGray	DarkGray
	    Black	White
	    Orange	Purple		Violet

	Win32 GUI 版本可以使用更多的系統顏色。見 |win32-colors|。

	你可以用紅、綠、藍的色值指定顏色。格式為 "#rrggbb"，其中
		"rr"	為紅色值
		"bb"	為藍色值
		"gg"	為綠色值
	所有的值都以十六進位制表示，範圍是 "00" 到 "ff"。例如: >
  :highlight Comment guifg=#11f0c3 guibg=#ff00ff
<
					*highlight-groups* *highlight-default*
有一些預設的高亮組。'highlight' 選項預設使用這些組。注意 高亮取決於
'background' 的值。你可以用 ":highlight" 命令看到當前的設定。
							*hl-ColorColumn*
ColorColumn	用於 'colorcolumn' 設定的列
							*hl-Conceal*
Conceal		代替隱藏文字的填充字元 (見 'conceallevel')
							*hl-Cursor*
Cursor		游標所在的字元
							*hl-CursorIM*
CursorIM	類似於 Cursor，但用於 IME 模式 |CursorIM|
							*hl-CursorColumn*
CursorColumn	置位 'cursorcolumn' 時，游標所在的螢幕列
							*hl-CursorLine*
CursorLine	置位 'cursorline' 時，游標所在的螢幕行
							*hl-Directory*
Directory	目錄名 (還有列表裡的其它特殊名字)
							*hl-DiffAdd*
DiffAdd		diff 模式: 增加的行 |diff.txt|
							*hl-DiffChange*
DiffChange	diff 模式: 改變的行 |diff.txt|
							*hl-DiffDelete*
DiffDelete	diff 模式: 刪除的行 |diff.txt|
							*hl-DiffText*
DiffText	diff 模式: 改變行裡的改動文字 |diff.txt|
							*hl-EndOfBuffer*
EndOfBuffer	緩衝區的末行之後的填充行 (~)。預設用 |hl-NonText| 類似的高亮。
							*hl-ErrorMsg*
ErrorMsg	命令列上的錯誤資訊
							*hl-VertSplit*
VertSplit	分離垂直分割視窗的列
							*hl-Folded*
Folded		用於關閉的摺疊的行
							*hl-FoldColumn*
FoldColumn	'foldcolumn'
							*hl-SignColumn*
SignColumn	顯示 |signs| 的列
							*hl-IncSearch*
IncSearch	'incsearch' 高亮；也用於被 ":s///c" 替換的文字
							*hl-LineNr*
LineNr		":number" 和 ":#" 命令與置位 'number' 或 'relativenumber' 選項
		時的行號。
							*hl-CursorLineNr*
CursorLineNr	和 LineNr 類似，置位 'cursorline' 或 'relativenumber' 時用於光
		標行。
							*hl-MatchParen*
MatchParen	如果游標所在或剛剛在它之前的字元是配對的括號一部分的話，它和它
		的配對。|pi_paren.txt|

							*hl-ModeMsg*
ModeMsg		'showmode' 訊息 (例如，"-- INSERT --")
							*hl-MoreMsg*
MoreMsg		|more-prompt|
							*hl-NonText*
NonText		視窗尾部的 '@'，'showbreak' 的字元和其它在文本里實際不存在的字
		符 (例如，代替行尾放不下的雙寬字元而顯示的 ">")。
							*hl-Normal*
Normal		普通文字
							*hl-Pmenu*
Pmenu		彈出選單: 普通專案。
							*hl-PmenuSel*
PmenuSel	彈出選單: 選中專案。
							*hl-PmenuSbar*
PmenuSbar	彈出選單: 滾動條。
							*hl-PmenuThumb*
PmenuThumb	彈出選單: 滾動條的拇指 (thumb)。
							*hl-Question*
Question	|hit-enter| 提示和 yes/no 問題
							*hl-Search*
Search		最近搜尋模式的高亮 (見 'hlsearch')。也用於 quickfix 當前行的
		高亮和其它類似的要突出顯示的專案。
							*hl-SpecialKey*
SpecialKey	":map" 列出的 Meta 和特殊鍵，也包括文本里不可顯示字元的顯示和
		'listchars'。
		一般的: 和實際內容顯示上有差異的文字。
							*hl-SpellBad*
SpellBad	拼寫檢查器不能識別的單詞。|spell|
		它會和本來應該使用的高亮進行組合。
							*hl-SpellCap*
SpellCap	應該大寫字母開頭的單詞。|spell|
		它會和本來應該使用的高亮進行組合。
							*hl-SpellLocal*
SpellLocal	拼寫檢查器能識別但只在其它區域使用的單詞。|spell|
		它會和本來應該使用的高亮進行組合。
							*hl-SpellRare*
SpellRare	拼寫檢查器能識別但很少使用的單詞。|spell|
		它會和本來應該使用的高亮進行組合。
							*hl-StatusLine*
StatusLine	當前視窗的狀態行
							*hl-StatusLineNC*
StatusLineNC	非當前視窗的狀態行
		注意: 如果等於 "StatusLine"，Vim 會使用 "^^^" 指示當前視窗的狀
		態行。
							*hl-TabLine*
TabLine		標籤頁行，非活動標籤頁標籤
							*hl-TabLineFill*
TabLineFill	標籤頁行，沒有標籤的地方
							*hl-TabLineSel*
TabLineSel	標籤頁行，活動標籤頁標籤
							*hl-Title*
Title		":set all"、":autocmd" 等輸出的標題
							*hl-Visual*
Visual		可視模式的選擇區
							*hl-VisualNOS*
VisualNOS	Vim 是 "選擇區的非擁有者" 時，可視模式的選擇區。只有 X11 GUI
		的 |gui-x11| 和 |xterm-clipboard| 才提供此支援。
							*hl-WarningMsg*
WarningMsg	警告訊息
							*hl-WildMenu*
WildMenu	'wildmenu' 補全的當前匹配

					*hl-User1* *hl-User1..9* *hl-User9*
'statusline' 語法允許在狀態行和標尺 (通過 'rulerformat') 上使用 9 種不同的高
亮。這些高亮組的名字是 User1 到 User9。

GUI 裡，你可以使用以下這些組來設定選單、滾動條和工具提示的色彩。它們沒有預設
值。這不適用於 Win32 GUI。這裡，只有三種高亮引數有效: font、guibg 和 guifg。

							*hl-Menu*
Menu		當前選單的字型、背景色和前景色。也包括工具欄。
		可用的高亮引數: font、guibg、guifg。

		注意: Motif 和 Athena 裡，font 引數在所有情況下實際上指定字型
		集 (fontset)，不管 'guifontset' 是否為空。所以，它和當前的
		|:language| 有關係。

							*hl-Scrollbar*
Scrollbar	主視窗滾動條的當前背景和前景色。
		可用的高亮引數: guibg、guifg。

							*hl-Tooltip*
Tooltip		當前工具提示的字型、背景色和前景色。也包括工具欄。
		可用的高亮引數: font、guibg、guifg。

		注意: Motif 和 Athena 裡，font 引數在所有情況下都指定字型集
		(fontset)，不管 'guifontset' 是否為空，從而在設定的時候和當前
		|:language| 相聯絡。

==============================================================================
13. 連結組			*:hi-link* *:highlight-link* *E412* *E413*

如果如果你想為幾個語法組使用相同的高亮設定，更簡單的方法是把這些組連結到一個共
同的高亮組，並且只為該組指定顏色屬性。

要設定連結:

    :hi[ghlight][!] [default] link {from-group} {to-group}

要刪除連結:

    :hi[ghlight][!] [default] link {from-group} NONE

注意:							*E414*
- 如果 {from-group} 和/或 {to-group} 不存在，先建立之。不存在的組不會給你錯誤
  資訊。
- 一旦你為被連結的組使用 ":highlight" 命令，該連結關係就不存在了。
- 如果已經有 {from-group} 的高亮設定，連結不會建立，除非你給出了 '!'。如果在載
  入的檔案裡執行 ":highlight link" 命令，你不會得到錯誤資訊。這可以用來跳過已
  有設定的組的連結。

					*:hi-default* *:highlight-default*
用 [default] 引數可以設定組的預設高亮。如果該組已經設定了高亮，或者已經存在鏈
接，忽略該命令。

這裡， [default] 對否決特定語法檔案的高亮特別有用。例如，C 語法檔案包含: >
	:highlight default link cComment Comment
如果你喜歡 C 註釋像 Question 一樣高亮，在你的 vimrc 檔案裡放入此行: >
	:highlight link cComment Question
如果沒有 "default"，執行 C 語法檔案後會覆蓋你的高亮設定。

==============================================================================
14. 清理						*:syn-clear* *E391*

如果你想為當前緩衝區清除所有的語法設定，可以使用如下命令: >
  :syntax clear

該命令應該在你想關閉語法高亮或者切換到別的語法時使用。通常，語法檔案本身不需要
它。因為載入語法檔案的自動命令會清理語法。
該命令也刪除 "b:current_syntax" 變數，因為該命令之後沒有載入的語法了。

如果想為所有的緩衝區關閉語法高亮，你需要刪除載入語法檔案的自動命令: >
  :syntax off

該命令實際執行的是命令 >
  :source $VIMRUNTIME/syntax/nosyntax.vim
詳情見 "nosyntax.vim" 檔案。注意 要使它工作，$VIMRUNTIME 必須合法。見
|$VIMRUNTIME|。

要為當前緩衝區清理特定的語法組: >
  :syntax clear {group-name} ..
它刪除了 {group-name} 裡所有的模式和關鍵字。

要為當前緩衝區清理特定的語法組群 (簇): >
  :syntax clear @{grouplist-name} ..
它把 {grouplist-name} 的內容設為空表。

						*:syntax-reset* *:syn-reset*
如果你修改了顏色並且把顏色弄亂了，使用這個命令取回預設值: >

  :syntax reset

這個名字起的不太好，因為它並不復位任何語法專案，而只對高亮有影響。

它不會改變 'highlight' 選項的顏色值。

注意 你在 vimrc 檔案裡設定的語法顏色也會復位成其 Vim 的預設值。
注意 如果你使用了色彩方案，色彩方案定義的語法高亮的色彩會丟失。

實際上，它做的是: >

	let g:syntax_cmd = "reset"
	runtime! syntax/syncolor.vim
<
注意 這裡使用了 'runtimepath' 選項。

							*syncolor*
如果想為語法高亮使用不同的色彩，你可以增加一個 Vim 指令碼來設定這些顏色。把該文
件放在 'runtimepath' 裡 $VIMRUNTIME 之後的一個目錄裡，以使你的設定覆蓋預設顏色
值。這樣，這些顏色會在 ":syntax reset" 命令之後被使用。

Unix 上你可以使用檔案 ~/.vim/after/syntax/syncolor.vim。例如: >

	if &background == "light"
	  highlight comment ctermfg=darkgreen guifg=darkgreen
	else
	  highlight comment ctermfg=green guifg=green
	endif
<
								*E679*
要確信這個 syncolor.vim 指令碼不使用 "syntax on" 命令，設定 'background' 選項或
者使用 "colorscheme" 命令，不然會導致死迴圈。

注意 如果使用了色彩方案，可能會比較混淆: 到底使用的是你自己定義的顏色還是方案
裡的顏色。這取決於色彩方案檔案，見 |:colorscheme|。

							*syntax_cmd*
載入 syntax/syncolor.vim 檔案時，"syntax_cmd" 變數設為以下這些值之一:
   "on"		":syntax on" 命令。高亮顏色被覆蓋，但是連結被保持
   "enable"	":syntax enable" 命令。只為沒有設定過高亮的組定義顏色。使用
		":syntax default"。
   "reset"	":syntax reset" 命令或者載入色彩方案。定義所有的顏色。
   "skip"	不定義顏色。用來跳過 'runtimepath' 裡較早出現的 syncolor.vim
		已經設定過的預設設定。

==============================================================================
15. 高亮標籤						*tag-highlight*

如果你想高亮檔案裡的所有標籤，可以使用如下對映。

	<F11>	-- 生成 tags.vim 檔案，並高亮標籤。
	<F12>	-- 只根據已有的 tags.vim 檔案高亮標籤。
>
  :map <F11>  :sp tags<CR>:%s/^\([^	:]*:\)\=\([^	]*\).*/syntax keyword Tag \2/<CR>:wq! tags.vim<CR>/^<CR><F12>
  :map <F12>  :so tags.vim<CR>

警 告: 標籤檔案越長，這會越慢，而 Vim 消耗的記憶體也越多。

這裡只高亮 typedef，也可以針對 union 和 struct 進行設定。為此，你需要
Exuberant ctags (可在 http://ctags.sf.net 找到)。

在你的 Makefile 裡放入以下的行:

# 建立 types 的高亮檔案。需要 Exuberant ctags 和 awk
types: types.vim
types.vim: *.[ch]
	ctags --c-kinds=gstu -o- *.[ch] |\
		awk 'BEGIN{printf("syntax keyword Type\t")}\
			{printf("%s ", $$1)}END{print ""}' > $@

在你的 .vimrc 裡放入以下的行: >

   " 載入 types.vim 高亮檔案，如果存在的話
   autocmd BufRead,BufNewFile *.[ch] let fname = expand('<afile>:p:h') . '/types.vim'
   autocmd BufRead,BufNewFile *.[ch] if filereadable(fname)
   autocmd BufRead,BufNewFile *.[ch]   exe 'so ' . fname
   autocmd BufRead,BufNewFile *.[ch] endif

==============================================================================
16. 視窗區域性語法				*:ownsyntax*

通常，同一個緩衝區對應的所有視窗共用相同的語法設定。不過，可以為某個檔案的某個
視窗設定單獨的語法設定。一個可能的例子，在一個視窗中使用普通的高亮方式編輯
LaTeX 原始碼，另一個視窗用不同的高亮方式訪問相同的程式碼 (例如隱藏控制序列，實際
對文字加粗，加斜體等等)。'scrollbind' 選項可用於此。

要使當前視窗使用語法 "foo"，而不影響緩衝區的其它視窗: >
   :ownsyntax foo
<						*w:current_syntax*
這樣做，"w:current_syntax" 變數會設為 "foo"。"b:current_syntax" 的值不變。實際
上，這是通過儲存和恢復 "b:current_syntax" 來實現的，因為語法檔案會設定
"b:current_syntax"。但語法檔案設定的值會被轉賦到 "w:current_syntax" 上。
備註: 這會復位 'spell'、'spellcapcheck' 和 'spellfile' 選項。

一旦視窗有自己的語法，同一緩衝區其它視窗執行的語法命令 (包括 :syntax clear) 就
不會有效果。相反地，此視窗執行的語法命令對同一緩衝區其它視窗也沒有效果。

帶有自己語法的視窗當載入其它緩衝區或過載檔案時，會恢復到正常行為。
分割視窗時，新視窗使用原有的語法。

==============================================================================
17. 彩色 xterm					*xterm-color* *color-xterm*

多數彩色 xterm 只有八色。如果你得不到預設設定的顏色，在 .vimrc 裡使用這些行應
該就可以了: >
   :if &term =~ "xterm"
   :  if has("terminfo")
   :	set t_Co=8
   :	set t_Sf=<Esc>[3%p1%dm
   :	set t_Sb=<Esc>[4%p1%dm
   :  else
   :	set t_Co=8
   :	set t_Sf=<Esc>[3%dm
   :	set t_Sb=<Esc>[4%dm
   :  endif
   :endif
<	[<Esc> 是真正的 escape，輸入 CTRL-V <Esc>]

你可能需要修改第一個 "if" 來匹配你的終端的名字。比如，"dtterm" 取代 "xterm"。

注意: 在 ":syntax on" 執行_之前_這些設定。否則顏色可能不正確。
							*xiterm* *rxvt*

上面提到的設定也適用於 xiterm 和 rxvt。但要在 rxvt 裡使用 16 色，可以使用
terminfo 並執行如下命令: >
	:set t_AB=<Esc>[%?%p1%{8}%<%t25;%p1%{40}%+%e5;%p1%{32}%+%;%dm
	:set t_AF=<Esc>[%?%p1%{8}%<%t22;%p1%{30}%+%e1;%p1%{22}%+%;%dm
<
							*colortest.vim*
要測試你的色彩設定，Vim 釋出版本里包含了一個檔案。要使用它，執行如下命令: >
   :runtime syntax/colortest.vim

即使顏色數定義為 8，一些版本的 xterm (還有其他終端，比如 linux 控制檯) 可以輸
出更亮的前景色。因此如果 't_Co' 為 8，Vim 為淺色的前景色設定 "cterm=bold" 屬
性。

							*xfree-xterm*
要得到 16 色或更多，需要最新的 xterm 版本 (應該包含在 Xfree86 3.3 或更新的版本
裡)。你可以在這裡得到最新的版本: >
	http://invisible-island.net/xterm/xterm.html
下面是 configure 的好方法。它使用 88 色，並開啟 termcap-query 特性。這使得 Vim
能夠詢問 xterm 可以支援多少顏色。 >
	./configure --disable-bold-color --enable-88-color --enable-tcap-query
如果你只有 8 色，檢查 xterm 的編譯設定。
(另見 |UTF8-xterm|，瞭解如何在該 xterm 裡使用 UTF-8 字元編碼)。

在你的 .vimrc 放入以下幾行，該 xterm 應該工作 (16 色): >
   :if has("terminfo")
   :  set t_Co=16
   :  set t_AB=<Esc>[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{92}%+%;%dm
   :  set t_AF=<Esc>[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{82}%+%;%dm
   :else
   :  set t_Co=16
   :  set t_Sf=<Esc>[3%dm
   :  set t_Sb=<Esc>[4%dm
   :endif
<	[<Esc> 是真正的 escape，輸入 CTRL-V <Esc>]

沒有 |+terminfo| 的話，Vim 會識別這些設定，並自動把 cterm 的第 8 色或更高的顏
色翻譯成 "<Esc>[9%dm" 和 "<Esc>[10%dm"。第 16 色以上也自動進行翻譯。

有報告說這樣可以用於 256 色: >

   :set t_AB=<Esc>[48;5;%dm
   :set t_AF=<Esc>[38;5;%dm

或者只設置 TERM 環境變數為 "xterm-color" 或 "xterm-16color"，然後試試行不行。

你也許想使用如下 X 資源 (在你的 ~/.Xdefaults 檔案裡):
	XTerm*color0:			#000000
	XTerm*color1:			#c00000
	XTerm*color2:			#008000
	XTerm*color3:			#808000
	XTerm*color4:			#0000c0
	XTerm*color5:			#c000c0
	XTerm*color6:			#008080
	XTerm*color7:			#c0c0c0
	XTerm*color8:			#808080
	XTerm*color9:			#ff6060
	XTerm*color10:			#00ff00
	XTerm*color11:			#ffff00
	XTerm*color12:			#8080ff
	XTerm*color13:			#ff40ff
	XTerm*color14:			#00ffff
	XTerm*color15:			#ffffff
	Xterm*cursorColor:		Black

[注意: 需要 cursorColor 來繞過一個漏洞。該漏洞把游標顏色設為最後顯示的文字的顏
色。在較新的版本里該問題被修正，但還不是所有人都使用新版本。]

要立刻使用，在 X 選項資料庫管理器裡重新載入 .Xdefaults 檔案 (你只須在改變
.Xdefaults 檔案的時候這麼做就可以了): >
  xrdb -merge ~/.Xdefaults
<
					*xterm-blink* *xterm-blinking-cursor*
要使游標在 xterm 上閃爍，見 tools/blink.c。或者使用 Thomas Dickey 的 xterm 補
丁號 107 以上的版本 (取得的方法見上)，使用這些資源:
	XTerm*cursorBlink:	on
	XTerm*cursorOnTime:	400
	XTerm*cursorOffTime:	250
	XTerm*cursorColor:	White

							*hpterm-color*
下面的設定 (或多或少) 在 hpterm 裡工作，它只支援 8 種前景色: >
   :if has("terminfo")
   :  set t_Co=8
   :  set t_Sf=<Esc>[&v%p1%dS
   :  set t_Sb=<Esc>[&v7S
   :else
   :  set t_Co=8
   :  set t_Sf=<Esc>[&v%dS
   :  set t_Sb=<Esc>[&v7S
   :endif
<	[<Esc> 是真正的 escape，輸入 CTRL-V <Esc>]

						*Eterm* *enlightened-terminal*
有報告稱下面的設定可以使得 Enlightened terminal emulator，或 Eterm，工作。它們
可能適用於所有的和 xterm 類似並使用 bold 屬性來取得亮色的終端。有必要的話，增
加類似於上面那樣的 ":if"。 >
       :set t_Co=16
       :set t_AF=^[[%?%p1%{8}%<%t3%p1%d%e%p1%{22}%+%d;1%;m
       :set t_AB=^[[%?%p1%{8}%<%t4%p1%d%e%p1%{32}%+%d;1%;m
<
						*TTpro-telnet*
下面的設定應該適用於 TTpro telnet。Tera Term Pro 是 MS-Windows 上一個自由軟體
/ 開源程式。 >
	set t_Co=16
	set t_AB=^[[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{32}%+5;%;%dm
	set t_AF=^[[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{22}%+1;%;%dm
要確信打開了 TTpro 的 Setup / Window / Full Color，並確信_沒有_開啟 Setup /
Font / Enable Bold。
(由 John Love-Jensen <eljay@Adobe.COM> 提供資訊)


==============================================================================
18. 語 法 太 慢 了						*:syntime*

本節主要針對語法檔案的作者。

如果語法導致重畫變慢，有一些小竅門。開啟一些通常會有干擾的特性，比如
'relativenumber' 和 |folding|，會看到是否變慢。

注意: 僅當編譯時帶 |+profile| 特性才可用。可能需要編譯 Vim 時帶 "huge" 特性
包。

要知道哪些模式花了最多時間，下面的命令序列會給出概要: >
	:syntime on
	[ 至少用 CTRL-L 重畫文字一次 ]
	:syntime report

此時會顯示使用到的語法模式的列表，按匹配文字使用的時間排序。

:syntime on		開始測量語法時間。會增加若干開銷，用來計算語法模式匹配
			的時間。

:syntime off		停止測量語法時間。

:syntime clear		把所有的計數清零，重新開始測量。

:syntime report		在當前視窗顯示 ":syntime on" 開始使用的語法專案。使用
			更寬的顯示可以看到更多輸出。

			列表按總時間排序。顯示以下諸列:
			TOTAL		用於匹配本模式的總時間，按秒計。
			COUNT		本模式使用的次數。
			MATCH		本模式實際匹配的次數。
			SLOWEST		單次匹配最長的時間。
			AVERAGE		單次匹配平均時間。
			NAME		語法專案名。注意 這未必唯一。
			PATTERN		使用的模式。

模式的匹配如果要嘗試不同的分支時會變慢。儘量包括更多的直義文字，以減少模式_不_
匹配的可能性。

如果用 "\@<=" 和 "\@<!" 專案，加入最大範圍來避免匹配本行和前行的所有可能位置。
例如，如要專案是直義文字，指明文字的長度 (以位元組計):

"<\@<=span"	匹配 "<span" 中的 "span"。會試圖在很多位置匹配 "<"。
"<\@1<=span"	相同匹配，但僅嘗試 "span" 之前的一個位元組。


 vim:tw=78:sw=4:ts=8:ft=help:norl:
