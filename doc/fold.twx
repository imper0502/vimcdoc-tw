*fold.txt*      For Vim version 8.0.  最近更新: 2017年7月


		  VIM 參考手冊    by Bram Moolenaar
		      譯者: Zimin<cranecai@users.sf.net>，tocer


摺疊						*Folding* *folding* *folds*

你可以在使用者手冊的第 28 章找到有關摺疊的序論。|usr_28.txt|

1. 摺疊方法		|fold-methods|
2. 摺疊命令		|fold-commands|
3. 摺疊選項		|fold-options|
4. 摺疊行為		|fold-behavior|

{Vi 沒有摺疊}
{僅當編譯時加入 |+folding| 特性才有效}

==============================================================================
1. 摺疊方法					*fold-methods*

可用選項 'foldmethod' 來設定摺疊方法。

設定選項 'foldmethod' 為非 "manual" 的其它值時，所有的摺疊都會被刪除並且建立新
的。如果設定成 "manual"，將不去除已有的摺疊。可以利用這一點來先自動定義摺疊，
然後手工調整。

有 6 種方法來選定摺疊:
	manual		手工定義摺疊
	indent		更多的縮排表示更高級別的摺疊
	expr		用表示式來定義摺疊
	syntax		用語法高亮來定義摺疊
	diff		對沒有更改的文字進行摺疊
	marker		對文中的標誌摺疊


手 工						*fold-manual*

使用命令來手工定義要摺疊的範圍。分析文字並發現摺疊的指令碼也可用這種方法。

摺疊的級別僅由巢狀次數來定義。要對一定行數的摺疊增加級別，可以對相同的行反覆定
義摺疊。

當你退出檔案編輯時，手工摺疊會被遺棄。要保存摺疊，使用 |:mkview| 命令。之後要
恢復可以使用 |:loadview|。


縮 進						*fold-indent*

由縮排行自動定義摺疊。

摺疊級別由行的縮排除以 'shiftwidth' (向下取整) 計算而得。連續的，有同樣或更高
的摺疊級別的行，形成一個摺疊。在其中，有更高摺疊級別的行形成巢狀的摺疊。

巢狀的級別數受 'foldnestmax' 選項限制。

某些行會被忽略並得到上一行或下一行的摺疊級別 (取較小值)。符合條件的這樣的行要
麼是空行，要麼以 'foldignore' 選項裡包含的字元開始。在查詢 'foldignore' 裡包含
的字元時，空白字元會被忽略。對於 C，該選項使用 "#" 來略過要預處理的那些行。

當你想用另一種方式來略過行時，使用 "expr" 方法。在 'foldexpr' 中 |indent()| 函
數被用來取得一行的縮排。


表 達 式						*fold-expr*

就象用 "indent" 方式一樣，表示式方式的摺疊也是由摺疊級別自動定義的。對每行，通
過計算選項 'foldexpr' 的值來並得到它的摺疊級別。如:
對所有以製表符開始的連續的幾行，建立摺疊: >
	:set foldexpr=getline(v:lnum)[0]==\"\\t\"
呼叫一函式來計算摺疊級別:   >
	:set foldexpr=MyFoldLevel(v:lnum)
用空白行分開的段落構成摺疊:   >
	:set foldexpr=getline(v:lnum)=~'^\\s*$'&&getline(v:lnum+1)=~'\\S'?'<1':1
同上:   >
	:set foldexpr=getline(v:lnum-1)=~'^\\s*$'&&getline(v:lnum)=~'\\S'?'>1':1
備註: ":set" 要特殊處理的字元必須用反斜槓轉義。(空格，反斜槓，雙引號等等，參考
|option-backslash|)

這些是表示式的計算條件:
- 當前緩衝區和視窗值依所在行而定
- 變數 "v:lnum" 被定為該行行號
- 計算結果將用以下方式解釋:
  值			代表 ~
  0			這行不折疊
  1, 2, ..		這行的摺疊級別 1，2 等
  -1			摺疊級別沒有定義，使用這行之前或之後一行的級別值，取其
  			中較小的一個。
  "="			使用上一行的摺疊級別。
  "a1", "a2", ..	上一行的摺疊級別加 1，2，..，結果適用於當前行
  "s1", "s2", ..	上一行的摺疊級別減 1，2，..，結果適用於當前行
  "<1", "<2", ..	此摺疊級別在本行結束
  ">1", ">2", ..	此摺疊級別在本行開始

不需要用 ">1" ("<1") 標誌摺疊的開始 (結束)。當這行摺疊級別高於 (低於) 上一行的
級別時，摺疊將開始 (結束)。

表示式必須沒有副作用。在緩衝區裡的文字，游標位置，查詢模式，選項等等，不能被改
動。如果你非常小心，改動並恢復這些設定還是可以的。

表示式中有錯誤或者計算結果不能識別時，Vim 不會產生錯誤訊息，而是將摺疊級別設為
0。所以當需要除錯時，可將 'debug' 選項設為 "msg"，錯誤訊息就可以被見到了。

備註: 由於每一行關於表示式的值都要被計算，這一折疊方式可能會很慢！

最好避免使用 "=" ， "a" 和 "s" 作為返回值，因為 Vim 不得不經常向後回溯以得到折
疊級別。這會降低執行速度。

使用 "a1" 和 "s1" 的一例: 用於多行 C 註釋，以 "/*" 開始的行返回 "a1" 以開始折
疊，包含 "*/" 的一行返回 "s1" 使該行之後結束摺疊: >
  if match(thisline, '/\*') >= 0
    return 'a1'
  elseif match(thisline, '\*/') >= 0
    return 's1'
  else
    return '='
  endif
不過，此程式碼不適用於單行註釋，字串等。

|foldlevel()| 計算相對於上一折疊級別的摺疊級別。但要注意，如果該級別未知，
foidlevel() 返回 -1。它返回的級別對應於該行開始的位置，儘管摺疊本身可能在該行
結束。

摺疊可能會沒有及時更新。用 |zx| 或者 |zX| 可以強制摺疊更新。


語 法						*fold-syntax*

由帶有 "fold" 引數的語法項來定義摺疊。|:syn-fold|

摺疊級別由巢狀的摺疊層數來定義。巢狀數由 'foldnestmax' 限定。

要小心指定合適的語法同步方式。如果這裡有問題，摺疊和顯示高亮可能會不一致。尤其
在使用可能跨越多行的模式時更要小心。如果有疑問，不妨嘗試如下的強制同步: >
	:syn sync fromstart
<

比 較						*fold-diff*

對沒有改動的文字或靠近改動的文字自動定義摺疊。

這個方法僅適用於當前視窗設定 'diff' 選項來顯示不同之處時才有效。不然，整個緩衝
區就是一個大的摺疊。

選項 'diffopt' 可以指定上下文。即摺疊和不被摺疊包括的改變之間相距的行數。比
如，設定上下文為 8: >
	:set diffopt=filler,context:8
預設值是 6。

當設定了 'scrollbind' 選項時，Vim 會試圖在其它比較視窗中開啟相同的摺疊，這樣這
些視窗就會顯示同一處文字。


標 志						*fold-marker*

在文字中可以加入標誌來指明摺疊開始和結束的地方。這可以讓你精確的定義摺疊。這也
讓你可以放心地刪除和複製摺疊而不用擔心錯誤包括了某些行。選項 'foldtext' 通常設
置為使摺疊行顯示摺疊標誌之前的文字。這樣做可以為摺疊命名。

標誌可以包含級別數，也可以使用匹配對。包含級別數較簡單，你無須新增結束標誌，並
可以避免標誌不配對的問題。如: >
	/* global variables {{{1 */
	int varA, varB;

	/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}

	/* funcB() {{{2 */
	void funcB() {}

摺疊開始於 "{{{" 標誌。接下去的數字決定了摺疊級別。產生的效果依當前摺疊級別和
該摺疊標誌給定的級別的大小關係而定:
1. 如果遇到級別相同的標誌，上一個摺疊結束，另一個有同樣級別的摺疊開始。
2. 如果遇到級別更高的標誌，開始一個巢狀的摺疊。
3. 如果遇到級別更低的標誌，所有大於或等於當前級別的摺疊結束，且指定級別的摺疊
   開始。

數字指定了摺疊級別。不能使用 0 (忽略級別為 0 的標誌)。你可以使用 "}}}" 帶上一
個數字來表示這個級別的摺疊結束。此行以下的摺疊級別將比當前級別小一。備註: Vim
不會回溯匹配的標誌 (這將耗費太多的時間)。如: >

	{{{1
	fold level here is 1
	{{{3
	fold level here is 3
	}}}3
	fold level here is 2

你也可以用一對匹配標誌 "{{{" 和 "}}}" 來定義摺疊。每個 "{{{" 使摺疊級別加 1，
"}}}" 使摺疊級別減 1。注意一定要使標誌匹配！如: >

	{{{
	fold level here is 1
	{{{
	fold level here is 2
	}}}
	fold level here is 1

帶數字的標誌和沒有帶數字的標誌可以混合使用。對於一個大摺疊我們可以使用帶數字的
標誌，在函式的內部我們可以使用不帶數字的。如對檔案中的 "結構定義"，"區域性變數"
和 "函式原型" 各個部分，使用級別 1 的摺疊。對定義和函式體使用級別 2 的標誌。而
在函式內部可以使用不帶數字的標誌。當你在一函式中作更改以分割摺疊時，你無須記著
標誌在哪裡。

選項 'foldmarker' 可設定所用的標誌。建議保留預設值 "{{{,}}}"。這樣在 Vim 使用者
間交換檔案時就不會出問題。有時為了要編輯的檔案必須改變該選項 (如，檔案包含了來
自另一個編輯器的摺疊標誌，或對於當前檔案的語法而言，摺疊標誌會產生歧義等)。

							*fold-create-marker*
"zf" 可通過標誌來建立一個摺疊。 Vim 將為你插入開始和結束標誌。這些標誌由
'foldmarker' 指定。標誌會被新增在行末。如果 'commentstring' 不為空，使用之。
以下情況下可能無法正常工作:
- 此行已有一個帶級別的標誌了。Vim 無法判斷該如何做。
- 在附近的摺疊裡使用了帶級別的標誌，使新增無法進行。
- 這行包含在一註釋中，且 'commentstring' 不為空，且巢狀的註釋是非法的。如，在
  C 的註釋中加入 /* {{{ */ ，這將使現有的註釋中斷。你可以在註釋之前或之後新增
  標誌，或手工新增。
總的來說，當你已有帶級別的標誌時，再讓 Vim 為你建立標誌不是個好主意。

							*fold-delete-marker*
"zd" 可用來刪除一個用標誌定義的摺疊。 Vim 將為你刪除標誌。Vim 將在摺疊的開始和
結束處根據 'foldmarker' 查詢開始和結束標誌。如果標誌周圍文字和 'commentstring'
匹配，這些文字也會被刪除。
但在以下情況下無法正確執行:
- 當一行包含有多於一個的標誌且其中一個指定了級別。Vim 不考慮結果是不是真能刪除
  摺疊，而僅刪除第一個標誌。
- 當這個標誌帶有級別且同時被用來開始或結束幾個摺疊時。

==============================================================================
2. 摺疊命令					*fold-commands* *E490*

所有的摺疊命令用 "z" 開頭。提示: 如果你從側面看 "z" 象一張疊起來的紙。


創 建 和 刪 除 折 疊 ~
							*zf* *E350*
zf{motion}  或
{Visual}zf	建立摺疊操作符。
		僅當 'foldmethod' 設為 "manual" 或 "marker" 時有效。
		用 "manual" 方式，新建的摺疊會被關閉。同時 'foldenable' 會被設
		定。
		參考 |fold-create-marker|。

							*zF*
zF		對 [count] 行建立摺疊。其餘同 "zf" 。

:{range}fo[ld]						*:fold* *:fo*
		對 {range} 內的行建立摺疊。其餘同 "zf" 。

							*zd* *E351*
zd		刪除 (delete) 在游標下的摺疊。當游標在被摺疊的行上，該摺疊被刪
		除。巢狀的摺疊上移一級。在可視模式下所選區域 (部分) 涵蓋的一層
		摺疊被刪除。
		小心: 這很容易比你想象地要刪得多，手動摺疊不能撤銷。
		僅當 'foldmethod' 設為 "manual" 或 "marker" 時有效。
		參考 |fold-delete-marker|。

							*zD*
zD		迴圈刪除 (Delete) 游標下的摺疊。在可視模式下所選區域 (部分) 涵
		蓋的摺疊和巢狀的摺疊都被刪除。
		僅當 'foldmethod' 設為 "manual" 或 "marker" 時有效。
		參考 |fold-delete-marker|。

							*zE* *E352*
zE		除去 (Eliminate) 窗口裡所有的摺疊。
		僅當 'foldmethod' 設為 "manual" 或 "marker" 時有效。
		參考 |fold-delete-marker|。


打 開 和 關 閉 折 疊 ~

一個小於 'foldminlines' 的摺疊的顯示就象它被開啟時一樣。所以，以下的命令對於小
摺疊所起的作用與描述不同。

							*zo*
zo		開啟 (open) 在游標下的摺疊。當給定計數時，相應深度的摺疊被打
		開。在可視模式下，所選區域的所有行的摺疊被開啟一級。

							*zO*
zO		迴圈開啟 (Open) 游標下的摺疊。不在游標下的摺疊不改變。
		在可視模式下，開啟所有的在選中區域裡的摺疊，包括被部分選中的。

							*zc*
zc		關閉 (close) 在游標下的摺疊。當給定計數時，相應深度的摺疊被關
		閉。在可視模式下，所選區域裡的所有行的摺疊被關閉一級。
		'foldenable' 被設定。

							*zC*
zC		迴圈關閉 (Close) 在游標下的所有摺疊。不在游標下的摺疊不改變。
		在可視模式下，關閉所有的在選中區域裡的摺疊，包括被部分選中的。
		'foldenable' 被設定。

							*za*
za		當游標位於一關閉的摺疊上時，開啟之。當摺疊巢狀時，你可能需要用
		"za" 數次。當給定計數時，開啟相應數量的被關閉的摺疊。
		當游標位於一開啟的摺疊上時，關閉之且設定 'foldenable' 。這僅關
		閉一級摺疊，因為再次使用 "za" 將再次開啟摺疊。當給定計數時，關
		閉相應數量的摺疊 (這不同於重複 "za" 許多次)。

							*zA*
zA		當處在一關閉的摺疊上時，迴圈地開啟摺疊。
		當處在一開啟的摺疊上時，迴圈地關閉摺疊且設定 'foldenable'。

							*zv*
zv		檢視 (view) 游標所在的行: 僅開啟足夠的摺疊使游標所在的行不被折
		疊。

							*zx*
zx		更新摺疊: 撤消被手工開啟和關閉的摺疊: 再次應用 'foldlevel'。
		然後使用 "zv" : 檢視游標所在行。
		同時強制重新計算摺疊。使用 "foldexpr" 並且緩衝區發生改變但摺疊
		不能正確地更新時，這會有用。

							*zX*
zX		手工恢復被開啟和關閉的摺疊: 再次應用 'foldlevel'。
		也同時強制重新計算摺疊，同 |zx|。

							*zm*
zm		折起更多 (more): 'foldlevel' 減 v:count1。如果 'foldlevel' 已
		經為 0，則不會被減小。
		'foldenable' 被設定。

							*zM*
zM		關閉所有摺疊: 'foldlevel' 設為 0。
		'foldenable' 被設定。

							*zr*
zr		減少 (reduce) 摺疊: 'foldlevel' 加 v:count1。

							*zR*
zR		開啟所有的摺疊。'foldlevel' 設為最高級別。

							*:foldo* *:foldopen*
:{range}foldo[pen][!]
		在 {range} 內開啟摺疊。當加上 [!] 時，所有的摺疊都被開啟。對查
		看在 {range} 內的所有文字很有用。沒有 [!] 時，開啟一級摺疊。

							*:foldc* *:foldclose*
:{range}foldc[lose][!]
		在 {range} 內關閉摺疊。當加上 [!] 時，所有的摺疊都被關閉。對隱
		藏在 {range} 內的所有文字很有用。沒有 [!] 時，關閉一級摺疊。

							*zn*
zn		不折疊 (none): 復位 'foldenable'。所有的摺疊被開啟。

							*zN*
zN		正常摺疊 (normal): 設定 'foldenable'。所有的摺疊都展現它們之前
		的樣子。

							*zi*
zi		翻轉 'foldenable' 的值。


在 折 疊 間 移 動 ~
							*[z*
[z		到當前開啟的摺疊的開始。如果已在開始處，移到包含這個摺疊的摺疊
		開始處。如果沒有包含它的摺疊，命令執行失敗。
		當給定計數，重複此命令 [count] 次。

							*]z*
]z		到當前開啟的摺疊的結束。如果已在結束處，移到包含這個摺疊的摺疊
		結束處。如果沒有包含它的摺疊，命令執行失敗。
		當給定計數，重複此命令 [count] 次。

							*zj*
zj		向下移動。到達下一個摺疊的開始處。關閉的摺疊也被計入。
		當給定計數，重複此命令 [count] 次。
		此命令可在 |operator| 後使用。

							*zk*
zk		向上移動到前一折疊的結束處。關閉的摺疊也被計入。
		當給定計數，重複此命令 [count] 次。
		此命令可在 |operator| 後使用。


對 折 疊 執 行 命 令 ~

:[range]foldd[oopen] {cmd}			*:foldd* *:folddoopen*
		對所有不在關閉的摺疊中的行執行 {cmd}。
		給定 [range] 時，僅對範圍內那些行起作用。
		每次命令被執行時，游標會被定位在要被操作的行上。
		就如 ":global" 命令: 首先標記出所有不在關閉的摺疊中的行。然後
		對所有標記過的行，執行 {cmd}。所以當 {cmd} 改變了文字的摺疊
		時，對命令執行的位置沒有影響 (當然，刪除行例外)。
		如: >
			:folddoopen s/end/loop_end/ge
<		使用標誌位 "e" 避免了當 "end" 不匹配時得到錯誤訊息。

:[range]folddoc[losed] {cmd}			*:folddoc* *:folddoclosed*
		對所有在關閉的摺疊裡的行，執行 {cmd}。
		其它同 ":folddoopen" 命令。

==============================================================================
3. 摺疊選項					*fold-options*

顏 色							*fold-colors*

對關閉的摺疊的顏色的設定由 Folded 高亮組 |hl-Folded| 決定。對摺疊欄的顏色的設
定由 FolderColumn 高亮組 |hl-FoldColumn| 決定。
下面是設定顏色的例子: >

	:highlight Folded guibg=grey guifg=blue
	:highlight FoldColumn guibg=darkgrey guifg=white
<

折 疊 級 別						*fold-foldlevel*

'foldlevel' 是個數值選項: 數字越大則開啟的摺疊更多。
當 'foldlevel' 為 0 時，所有的摺疊關閉。
當 'foldlevel' 為正數時，一些摺疊關閉。
當 'foldlevel' 很大時，所有的摺疊開啟。
'foldlevel' 的改變後立即生效。之後，摺疊可以被手動地開啟和關閉。
當其值增大，在新級別 (譯者注: 舊級別？) 之上的摺疊被開啟。手工開啟的摺疊不會被
關閉。
當其值減小，在新級別之上的摺疊被關閉。手工關閉的摺疊不會被開啟。


折 疊 文 本						*fold-foldtext*

'foldtext' 是個字串選項，定義了一個表示式。這個表示式被用來求得關閉摺疊所顯
示的文字。如: >

    :set foldtext=v:folddashes.substitute(getline(v:foldstart),'/\\*\\\|\\*/\\\|{{{\\d\\=','','g')

顯示了摺疊的第一行，除去其中的 "/*"、"*/" 和 "{{{" 。
備註: 使用反斜槓是為了避免一些字元被 ":set" 命令解釋。使用一個函式更簡單: >

    :set foldtext=MyFoldText()
    :function MyFoldText()
    :  let line = getline(v:foldstart)
    :  let sub = substitute(line, '/\*\|\*/\|{{{\d\=', '', 'g')
    :  return v:folddashes . sub
    :endfunction

'foldtext' 的計算是在沙盤 |sandbox| 裡完成的。其中的當前視窗設為要顯示該行的窗
口。錯誤被忽略。

預設值是 |foldtext()|。對於大多數型別的摺疊它可以返回適合的文字。如果你不喜歡
它，你可以自己指定 'foldtext' 表示式。可以使用以下這些 Vim 變數:
	v:foldstart	摺疊首行的行號
	v:foldend	摺疊末行的行號
	v:folddashes	一個含有連字元的字串，用來表示摺疊級別
	v:foldlevel	摺疊級別

在結果中，製表符被替換為空格，而不可顯示的字元被替換為可顯示的字元。

結果行被截短以適合視窗的寬度，永遠不會迴繞。
當在文字後有空餘時，用 'fillchars' 來填充。

備註: 對那些 ":set" 命令作特殊處理的字元在其前面須加上反斜槓。如: 空格，反斜槓
和雙引號。 |option-backslash|


折 疊 欄						*fold-foldcolumn*

'foldcolumn' 是個數字，它設定了在視窗的邊上表示摺疊的欄的寬度。當為 0 時，沒有
摺疊欄。一個普通值是 4 或 5。最小可用的值是 2，不過 1 仍然可以提供一些資訊。最
大是 12。

一個開啟的摺疊由一欄來表示，頂端是 '-'，其下方是 '|'。這欄在摺疊結束的地方結
束。當摺疊巢狀時，巢狀的摺疊出現在被包含的摺疊右方一個字元位置。

一個關閉的摺疊由 '+' 表示。

當摺疊欄太窄而不能顯示所有摺疊時，顯示一數字來表示巢狀的級別。

在摺疊欄點選滑鼠，可以開啟和關閉摺疊:
- 點選 '+' 開啟在這行的關閉摺疊
- 在任何其他非空字元上點選，關閉這行上的開啟摺疊


其 他 選 項

'foldenable'  'fen':	復位時開啟所有摺疊。
'foldexpr'    'fde':	用於 "expr" 摺疊的表示式。
'foldignore'  'fdi':	用於 "indent" 摺疊的字元。
'foldmarker'  'fmr':	用於 "marker" 摺疊的標誌。
'foldmethod'  'fdm':	當前摺疊方法。
'foldminlines' 'fml':	關閉摺疊的最小顯示行數。
'foldnestmax' 'fdn':	用於 "indent" 和 "syntax" 摺疊的最大巢狀層數。
'foldopen'    'fdo':	哪一種命令可以開啟關閉的摺疊。
'foldclose'   'fcl':	當游標不在摺疊上時關閉摺疊。

==============================================================================
4. 摺疊行為						*fold-behavior*

當上下移動和滾動時，游標將移至連續摺疊的行的第一行。當游標已在被摺疊的行上時，
它移動到下一個沒有被摺疊的行上，或下一個關閉的摺疊。

當游標在被摺疊的行上時，游標總是顯示在第一列。標尺顯示確切的游標位置。游標本應
也在實際位置顯示的，但因為被摺疊而無法做到。

許多移動命令處理連續被摺疊的行就象處理空行一樣。如，"w" 命令只在首列停一次。

在插入模式下，游標所在的行不會被摺疊。這讓你看得見你鍵入的內容。

當使用操作符時，一個關閉的行被作為整體處理。所以 "dl" 在游標下刪除了整個關閉的
摺疊。

作用於緩衝區行的 Ex 命令的執行範圍會被調整，使得它總是從關閉摺疊的第一行開始，
在關閉摺疊的最後一行結束。所以，命令: >
	:s/foo/bar/g
當游標在關閉的摺疊上時，它將在整個摺疊裡用 "bar" 替換 "foo"。
不過 |:folddoopen| 和 |:folddoclosed| 的操作並非如此。

編輯一個已經被編輯過的緩衝區時，上次被使用的摺疊設定會被再次使用。對手工定義折
疊方式，已經被定義的摺疊會被恢復。對所有的摺疊方式，手工開啟和關閉的摺疊會被恢
復。如果這個緩衝區曾經在這個窗口裡被編輯，過去用的值被恢復。否則，來自該緩衝區
最近一次編輯的視窗值被使用。

==============================================================================
 vim:tw=78:ts=8:ft=help:norl:
