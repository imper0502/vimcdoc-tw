*change.txt*    For Vim version 8.0.  最近更新: 2017年7月


		  VIM 參考手冊    by Bram Moolenaar
				譯者: Willis
				http://vimcdoc.sf.net


本文件描述刪除和修改文字的命令。在本文中，修改文字意味著用單個命令刪除部分文字
並將其替換成其他文字。所有本文描述的命令都可以被撤銷。其中非命令列 (Ex) 的命令
可以用 "." 命令重複。

1. 刪除文字			|deleting|
2. 刪除並插入			|delete-insert|
3. 簡單修改			|simple-change|		*changing*
4. 複雜修改			|complex-change|
   4.1 過濾命令			   |filter|
   4.2 替代			   |:substitute|
   4.3 搜尋與替代		   |search-replace|
   4.4 調整製表			   |change-tabs|
5. 複製並移動文字		|copy-move|
6. 文字排版			|formatting|
7. 文字排序			|sorting|

關於插入文字部分，參閱 |insert.txt|。

==============================================================================
1. 刪除文字						*deleting* *E470*

["x]<Del>	或					*<Del>* *x* *dl*
["x]x			刪除 [count] 個游標之下和之後的字元 [到暫存器 x 裡]
			(非 |linewise| 行動作)。和 "dl" 相同。
			<Del> 鍵不使用 [count] 計數。相反，如果有計數，它刪
			除該計數的最後一位。
			如果 <Del> 鍵的操作與你預期的不符，參見 |:fixdel|。關
			於如何刪除換行符 (連線行)，參見 |'whichwrap'|。
			{Vi 不支援 <Del>}

							*X* *dh*
["x]X			刪除 [count] 個游標之前的字元 [到暫存器 x 裡] (非
			|linewise| 行動作)。和 "dh" 相同。另見 |'whichwrap'|。

							*d*
["x]d{motion}		刪除 {motion} 動作跨越的文字 [到暫存器 x 裡]。例外見
			下。

							*dd*
["x]dd			刪除 [count] 行 [到暫存器 x 裡]，|linewise| 行動作。

							*D*
["x]D			刪除游標所在的字元到行尾及其後的 [count]-1 行 [到寄
			存器 x 裡] (非 |linewise| 行動作)。和 "d$" 同義。
			如果 'cpoptions' 裡有 '#' 標誌位，忽略計數。

{Visual}["x]x	或					*v_x* *v_d* *v_<Del>*
{Visual}["x]d   或
{Visual}["x]<Del>	刪除高亮文字 [到暫存器 x 裡] (關於 {Visual} 見
			|Visual-mode|)。{Vi 無此功能}

{Visual}["x]CTRL-H   或					*v_CTRL-H* *v_<BS>*
{Visual}["x]<BS>	在選擇模式時，刪除高亮文字 [到暫存器 x 裡]。

{Visual}["x]X	或					*v_X* *v_D* *v_b_D*
{Visual}["x]D		刪除高亮行 [到暫存器 x 裡] (關於 {Visual} 見
			|Visual-mode|)。在可視列塊模式裡，"D" 刪除高亮的文字直
			到行尾。{Vi 無此功能}

					*:d* *:de* *:del* *:delete* *:dl* *:dp*
:[range]d[elete] [x]	刪除 [range] 範圍的行 (預設: 當前行) [到暫存器 x 裡]。
			注意 這些奇異的縮寫:
			   :dl		刪除並列出 (list)
			   :dell	同上
			   :delel	同上
			   :deletl	同上
			   :deletel	同上
			   :dp		刪除並顯示 (print)
			   :dep		同上
			   :delp	同上
			   :delep	同上
			   :deletp	同上
			   :deletep	同上

:[range]d[elete] [x] {count}
			從 [range] 指定的範圍開始，刪除 {count} 行 (預設: 當前
			行 |cmdline-ranges|) [到暫存器 x 裡]。

這些命令刪除文字。你可以用 `.` 命令重複它們 (除了 `:d`)，也可以撤銷它們。用可
視模式可以刪除文字列塊。關於暫存器的解釋，參見 |registers|。

d{motion} 命令的一個特例: 如果動作不面向行，動作的開始和結束處不在同一行，開始
位置之前只有空白，並且結束位置之後沒有非空白的話，該刪除會轉為行動作。這意味著
刪除命令可能刪除你還想保留的空白行。|o_v| 操作符強制該動作面向字元。

如果 'cpoptions' 包括 'E' 標誌位，刪除文本里的空區域 (例如，在首列上 "d0") 會
報錯。

							*J*
J			連線 [count] 行，但至少包含兩行。刪除縮排，插入不多於
			兩個的空格 (見下)。在緩衝區末行此操作會失敗。[count]
			如果過多，會自行縮減至餘下可用的行。

							*v_J*
{Visual}J		連線高亮行，但至少包含兩行。刪除縮排，插入不多於兩個的
			空格 (見下)。{Vi 無此功能}。

							*gJ*
gJ			連線 [count] 行，但至少包含兩行。不插入或刪除任何空
			格。{Vi 無此功能}。

							*v_gJ*
{Visual}gJ		連線高亮行，但至少包含兩行。不插入或刪除任何空格。
			{Vi 無此功能}。

							*:j* *:join*
[range]j[oin][!] [flags]
			連線 [range] 範圍的行。和 "J" 相同，但如有 [!] 時，連
			接不插入或刪除任何空格。如果 [range] 包括相同的開始和
			結束行，該命令不做任何事。預設行為是連線當前行與下一
			行。{Vi: 沒有 !}
			[flags] 部分可參見 |ex-flags|。

:[range]j[oin][!] {count} [flags]
			連線 [range] 開始的 {count} 行 (預設: 當前行
			|cmdline-ranges|)。和 "J" 相同，但如有 [!] 時，連線不
			插入或刪除任何空格。{Vi: 沒有 !}
			[flags] 部分可參見 |ex-flags|。

這些命令刪除行間的 <EOL>，即換行符，從而實際上使多行連線成一行。除了 `:j` 之
外，你可以重複這些命令或者撤銷之。

這些命令，除了 "gJ" 以外，插入一個空格以代替 <EOL>，除非當前行的結尾已經有空白
或者下一行以 ')' 開始。這些命令，除了 "gJ" 之外，也刪除下一行所有開頭的空白。
如果 'joinspaces' 選項開啟，這些命令在 '.'、'!' 或者 '?' 之後插入兩個空格 (但
如果 'cpoptions' 包括 'j' 標誌位，只有在 '.' 之後插入兩個空格)。
'formatoptions' 裡的 'B' 和 'M' 標誌位改變在多位元組字元之前或者之後插入空格的行
為 |fo-table|。

'[ 標記指向被連線的首行之原行尾處，'] 則指向合併後的行尾。


==============================================================================
2. 刪除並插入					*delete-insert* *replacing*

							*R*
R			進入替換模式: 每個輸入的字元替代一個現有的字元，從游標
			所在的位置開始。重複輸入的文字 [count] - 1 次。參見
			|Replace-mode| 以瞭解相關詳情。

							*gR*
gR			進入虛擬替換模式: 每個輸入的字元替代螢幕位置一個現有的
			字元。因而，一個 <Tab> 可以一次替換若干個字元。重複輸
			入的文字 [count]-1 次。參見 |Virtual-Replace-mode| 以
			瞭解相關詳情。{僅當編譯時加入 |+vreplace| 特性有效}

							*c*
["x]c{motion}		將 {motion} 跨過的文字刪除 [到暫存器 x 裡] 並開始插
			入。如果 'cpoptions' 包括 'E' 標誌位並且沒有任何文字實
			際需要刪除時 (例如，"cTx" 而游標剛在 'x' 之後的時候)，
			報錯並拒絕開始插入模式 (這與 Vi 相容)。如果
			'cpoptions' 沒有 'E'，"c" 命令總是啟動插入模式，即使沒
			有文字要刪除也是如此。

							*cc*
["x]cc			刪除 [count] 行 [到暫存器 x 裡] 並開始插入。
			|linewise| 行動作。如果置位 'autoindent'，保留首行的縮
			進。

							*C*
["x]C			從當前游標位置刪除到行尾，再刪除 [count]-1 行 [到寄存
			器 x 裡]，並開始插入。和 c$ 等價 (非 |linewise| 行動
			作)。

							*s*
["x]s			刪除 [count] 個字元 [到暫存器 x 裡]，並開始插入。(s 代
			表替代 (Substitute))。和 "cl" 等價 (非 |linewise| 行動
			作)。

							*S*
["x]S			刪除 [count] 行 [到暫存器 x 裡] 並開始插入。和 "cc" 等
			價 |linewise| 行動作。

{Visual}["x]c	or					*v_c* *v_s*
{Visual}["x]s		刪除高亮文字 [到暫存器 x 裡]，並開始插入 (關於
			{Visual} 參見 |Visual-mode|)。{Vi 無此功能}。

							*v_r*
{Visual}["x]r{char}	把所有高亮的字元替換成 {char}。

							*v_C*
{Visual}["x]C		刪除高亮行 [到暫存器 x 裡] 並開始插入。在可視列塊模式
			下有所不同 |v_b_C|。{Vi 無此功能}。
							*v_S*
{Visual}["x]S		刪除高亮行 [到暫存器 x 裡] 並開始插入 (關於 {Visual}
			參見 |Visual-mode|)。{Vi 無此功能}。
							*v_R*
{Visual}["x]R		現在和 {Visual}["x]S 相同。以後的版本可能會有所改變
			{Vi 無此功能}。

注意:
- 你可以用 <Esc> 退出插入和替換模式。
- 參見 "插入和替換模式" 一節 |mode-ins-repl| 以瞭解其他這些模式下的特殊字元。
- [count] 的效果只有在 Vim 退出插入或替換模式時才會體現。
- 當 'cpoptions' 選項包含 '$' 並且所做的修改在一行之內，Vim 繼續顯示被刪除的文
  本，並在最後一個被刪除的字元之後加上一個 '$'。

關於暫存器的解釋，參見 |registers|。

替換模式和插入模式類似，除了每輸入一個字元同時刪除一個字元以外。如果到達行尾，
Vim 把其後的字元插入在行尾 (和插入模式相同)。在替換模式下，退格鍵恢復原來的文
本 (如果有的話)。(參見 "插入和替換模式" 一節 |mode-ins-repl|)。

						*cw* *cW*
特殊情況: 如果游標在單詞內部，"cw" 和 "cW" 不包含單詞後的空白而只修改到詞尾。
這是因為 Vim 把 "cw" 解釋為 修改-單詞，而單詞並不包括其後的空白。{Vi: 在其後還
有空白的空白字元上 "cw" 只修改第一個空白；這也許是一個漏洞，因為 "dw" 刪除所有
空白；用 'cpoptions' 裡的 'w' 標誌位來設定類似於 Vi 的工作方式}

如果你希望 "cw" 包括單詞之後的空格，使用如下的對映: >
	:map cw dwi
或者，用 "caw" (見 |aw|)。

							*:c* *:ch* *:change*
:{range}c[hange][!]	用另外的文字替換若干文字行。輸入只包含 "." 的行結束替
			換。如果沒有 {range}，該命令只置換當前行。
			加上 [!] 後，在本命令的執行期間切換 'autoindent'。

==============================================================================
3. 簡單修改						*simple-change*

							*r*
r{char}			把游標下的字元換成 {char}。如果 {char} 是 <CR> 或者
			<NL>，則把該字元變成換行符。要換成一個真正的 <CR>，使
			用 CTRL-V <CR>。CTRL-V <NL> 則換成 <Nul>。

			{Vi: CTRL-V <CR> 還是換成換行符。沒有辦法換成 <CR>}。

			若 {char} 為 CTRL-E 或 CTRL-Y，使用下一行或上一行的
			字元來代替，就象 |i_CTRL-E| 和 |i_CTRL-Y| 一樣。這裡
			計數也適用，所以 `10r<C-E>` 從下一行復制 10 個字元。

			如果你給出 [count]，Vim 替換 [count] 個字元為 [count]
			個 {char}。不過如果 {char} 為 <CR> 或者 <NL>，Vim 只插
			入一個換行符: "5r<CR>" 替換五個字元為一個換行符。

			當 {char} 為 <CR> 或者 <NL>，Vim 會自動縮排。這和先執
			行刪除要替換的字元在執行 "i<CR><Esc>" 類似。

			{char} 可以輸入二合字母 |digraph-arg|。

			|:lmap| 對映會應用在 {char} 上。插入模式下的 CTRL-^ 命
			令可以切換這一功能 |i_CTRL-^|。

			參見 |utf-8-char-arg| 以瞭解在 'encoding' 為 Unicode
			編碼時如果使用合成用字元。

							*gr*
gr{char}		替換游標下的虛擬字元。替換髮生在螢幕位置而不是檔案位置
			上。參見 |gR| 和 |Virtual-Replace-mode| 以瞭解相關詳
			情。和 |r| 一樣，可以使用計數。{char} 輸入的方式也相同
			{僅當編譯時加入 |+vreplace| 特性有效}。

						*digraph-arg*
普通模式下的命令，像 |r| 和 |t|，需要一個單字元的引數。如果 'cpo' 不包含 'D'
標誌位，該字元可以用 |digraphs| 那樣的方式輸入: 先鍵入 CTRL-K 然後輸入二合字母
的兩個字元 {僅當編譯時加入 |+digraphs| 特性有效}。

						*case*
下面的命令根據當前的 |locale| 改變字母的大小寫。參見 |:language|。這裡會用到
LC_CTYPE 的值。

							*~*
~			'notildeop' 選項: 切換游標下字元的大小寫，並把游標向右
			移。如果給出 [count]，應用在那麼多數目的字元上。
			{Vi: 沒有 count}

~{motion}		'tildeop' 選項: 切換 {motion} 跨越的文字的大小寫。{Vi:
			~ 不能用作操作符}

							*g~*
g~{motion}		切換 {motion} 跨越的文字的大小寫。{Vi 無此功能}

g~g~							*g~g~* *g~~*
g~~			切換當前行的大小寫。{Vi 無此功能}

							*v_~*
{Visual}~		切換高亮文字的大小寫 (關於 {Visual} 見
			|Visual-mode|)。{Vi 無此功能}

							*v_U*
{Visual}U		使高亮文字成為大寫 (關於 {Visual} 見 |Visual-mode|)。
			{Vi 無此功能}

							*gU* *uppercase*
gU{motion}		使 {motion} 跨越的文字成為大寫。{Vi 無此功能}
			例如: >
				:map! <C-F> <Esc>gUiw`]a
<			可以用在插入模式下: 按 CTRL-F 使游標之前的單詞成為大
			寫。這使得輸入大寫單詞很方便，只要輸入小寫單詞再一次轉
			換就行了。


gUgU							*gUgU* *gUU*
gUU			使得當前行成為大寫。{Vi 無此功能}

							*v_u*
{Visual}u		使高亮文字成為小寫 (關於 {Visual} 見 |Visual-mode|)。
			{Vi 無此功能}

							*gu* *lowercase*
gu{motion}		使 {motion} 跨越的文字成為小寫。{Vi 無此功能}

gugu							*gugu* *guu*
guu			使得當前行成為小寫。{Vi 無此功能}

							*g?* *rot13*
g?{motion}		用 Rot13 對 {motion} 跨越的文字進行編碼。{Vi 無此功能}

							*v_g?*
{Visual}g?		用 Rot13 對高亮文字進行編碼 (關於 {Visual} 見
			|Visual-mode|)。{Vi 無此功能}

g?g?							*g?g?* *g??*
g??			用 Rot13 對當前行進行編碼。{Vi 無此功能}

要以標題大寫 (title cap) 方式改寫一行，亦即使每個單詞的首字母大寫: >
	:s/\v<(.)(\w*)/\u\1\L\2/g


遞 增 與 遞 減 ~
							*CTRL-A*
CTRL-A			把當前游標之上或之後的數值或者字母加上 [count]。
			{Vi 無此功能}

							*v_CTRL-A*
{Visual}CTRL-A		給高亮文字內的數值或者字母加上 [count]。
			{Vi 無此功能}

							*v_g_CTRL-A*
{Visual}g CTRL-A	給高亮文字內的數值或者字母加上 [count]。如果高亮超過一
			行，每行會加上額外的 [count] (即生成 [count] 為增量的
			遞增數列)。{Vi 無此功能}
			例如，假定有如下數字的列表:
				1. ~
				1. ~
				1. ~
				1. ~
			移動至第二個 "1."，可視地選擇後三行，按 g CTRL-A 會生
			生成:
				1. ~
				2. ~
				3. ~
				4. ~

							*CTRL-X*
CTRL-X			把當前游標之上或之後的數值或者字母減去 [count]。
			{Vi 無此功能}

							*v_CTRL-X*
{Visual}CTRL-X		給高亮文字內的數值或者字母減去 [count]。
			{Vi 無此功能}

			MS-Windows 上，此鍵被對映到剪下可視文字
			|dos-standard-mappings|。要遮蔽該對映，可用: >
				silent! vunmap <C-X>
<
							*v_g_CTRL-X*
{Visual}g CTRL-X	給高亮文字內的數值或者字母減去 [count]。如果高亮超過一
			行，每行會減去額外的 [count] (即生成 [count] 為增量的
			遞減數列)。

CTRL-A 和 CTRL-X 命令可用於:
- 帶符號或無符號十進位制數
- 無符號二進位制、八進位制和十六進位制數
- 字母

這取決於 'nrformats' 選項:
- 當 'nrformats' 包括 "bin" 時，Vim 假設 '0b' 或 '0B' 開始的數值為二進位制。
- 當 'nrformats' 包括 "octal" 時，Vim 假設 '0' 開始的數值為八進位制，除非該數值
  裡包含 '8' 或 '9'。其他的數值為十進位制，並可以在開始帶一個可選的負號。
  如果游標已經在數值上，命令應用於該數值；否則，應用於游標右側的數值。
- 當 'nrformats' 包括 "alpha" 時，Vim 會改變游標之上或之後的字母。這可用於構造
  字母編號的列表。
- 當 'nrformats' 包括 "hex" 時，Vim 假設 '0x' 或者 '0X' 開始的數值為十六進位制。
  這個數值最右端的字母決定所產生十六進位制數值的大小寫。如果當前數值沒有字母，
  Vim 使用上一次檢測到的大小寫。

增減操作會考慮十進位制開始的負號。二進位制、八進位制和十六進位制值則不會。要忽略正負
號，可視地選擇數值本身。然後再應用 CTRL-A 或 CTRL-X。

對零開頭的數值 (包括八進位制和十六進位制的)，Vim 儘可能保留相同數量的字元。CTRL-A
在 "0077" 上產生 "0100"，CTRL-X 在 "0x100" 上產生 "0x0ff"。
有一個例外: 在發現某數值以零開始但不是八進位制 (包含 '8' 或 '9')，而 'noformats'
卻包含 "octal" 的時候，引導的零會被刪除，以免結果被誤認為八進位制。

注意 如果 'nrformats' 包括 "octal"，開頭有零的十進位制數會產生錯誤，因為會和八進
制數產生混淆。

同樣類似的要 注意，如果 'nrformats' 包括 "bin"，開頭有 '0x' 或 '0X' 的二進位制數
被認作十六進位制，因為 '0b' 是合法的十六進位制數字。

CTRL-A 命令在巨集命令裡很有用。例如: 使用以下的步驟構造一個數字編號的列表。

1. 建立第一個列表項。確保它以數字開始。
2. qa	     - 用暫存器 'a' 開始記錄
3. Y	     - 抽出這個列表項
4. p	     - 把該項的一個副本放置在下一行上
5. CTRL-A    - 增加計數
6. q	     - 停止記錄
7. <count>@a - 重複抽出、放置和增加計數操作 <count> 次


將 文 本 左 移 或 右 移					*shift-left-right*

							*<*
<{motion}		將 {motion} 跨越的行左移 'shiftwidth' 列。

							*<<*
<<			將 [count] 行左移 'shiftwidth' 列。

							*v_<*
{Visual}[count]<	將高亮行左移 [count] 個 'shiftwidth' 列 (關於 {Visual}
			見 |Visual-mode|)。{Vi 無此功能}

							*>*
 >{motion}		將 {motion} 跨越的行右移 'shiftwidth' 列。

							*>>*
 >>			將 [count] 行右移 'shiftwidth' 列。

							*v_>*
{Visual}[count]>	將高亮行右移 [count] 個 'shiftwidth' 列 (關於 {Visual}
			見 |Visual-mode|)。{Vi 無此功能}

							*:<*
:[range]<		將 [range] 指定的行左移 'shiftwidth' 列。多個 '<' 左移
			多個 'shiftwidth' 列。

:[range]< {count}	左移 [range] 開始的 {count} 行 'shiftwidth' 列 (預設從
			當前行 |cmdline-ranges|)。多個 '<' 左移多個
			'shiftwidth' 列。

:[range]le[ft] [indent]	左對齊 [range] 指定的行。設定縮排距離為 [indent] (預設
			為 0)。{Vi 無此功能}

							*:>*
:[range]> [flags]	將 [range] 指定的行右移 'shiftwidth' 列。多個 '>' 右移
			多個 'shiftwidth' 列。
			[flags] 部分可參見 |ex-flags|。

:[range]> {count} [flags]
			右移 [range] 開始的 {count} 行 'shiftwidth' 列 (預設從
			當前行 |cmdline-ranges| 開始)。多個 '>' 右移多個
			'shiftwidth' 列。
			[flags] 部分可參見 |ex-flags|。

">" 和 "<" 命令可以用來方便地調整程式的縮排。使用 'shiftwidth' 選項設定這些命
令增加或者減少的空白的數量。通常，'shiftwidth' 選項是 8，但你也可以設定為，比
如說，3，使得縮排更小些。如果已經沒有縮排，左移命令會停止。另一方面，右移命令
則不會影響空白行。

如果 'shiftround' 選項開啟，縮排距離被取整到 'shiftwidth' 的倍數。

如果 'smartindent' 選項開啟，或者 'cindent' 開啟並且 'cinkeys' 包含帶零值的
'#'，右移不影響 '#' 開始的行 (這些應該是 C 預處理行，它們應該保持在第一列)。

如果 'expandtab' 選項關閉 (這是預設值)， Vim 儘可能使用 <Tab> 來構成縮排。你可
以用 ">><<" 來把縮排儘可能從空格替換成同樣縮排距離的 <Tab> (如有需要，還有少量
的空格)。如果 'expandtab' 選項開啟，Vim 只使用空格。這樣你可以使用 ">><<" 把
<Tab> 替換成空格 (或者可以用 `:retab!`)。

要移動一行多個 'shiftwidth' 列，使用可視模式或者 `:` 命令。例如: >
	Vjj4>		右移三行四個縮排位
	:<<<		左移當前行三個縮排位
	:>> 5		右移五行兩個縮排位
	:5>>		右移第五行兩個縮排位

==============================================================================
4. 複雜修改						*complex-change*

4.1 過濾命令						*filter*

過濾程式是一個接受文字作為標準輸入，作某些修改，並把結果放到標準輸出的程式。你
可以用下面的命令把若干文字傳送給過濾程式，然後用過濾的輸出結果替換。一個過濾程
序的例子是 "sort"，按字母順序給行排序；還有 "indent"，排版 C 程式檔案 (你需要
一個能以過濾程式方式工作的版本，並非所有的版本都可以)。'shell' 選項指定 Vim 使
用的外殼程式，用以執行過濾程式 (另見 'shelltype' 選項)。你可以用 "." 重複過濾
命令。Vim 不會識別 `:!` 命令之後的註釋 (用 '"' 開始)。

							*!*
!{motion}{filter}	將 {motion} 跨越的行用外部程式 {filter} 過濾。

							*!!*
!!{filter}		將 [count] 行用外部程式 {filter} 過濾。

							*v_!*
{Visual}!{filter}	將高亮行用外部程式 {filter} 過濾。(關於 {Visual}
			見 |Visual-mode|)。{Vi 無此功能}

:{range}![!]{filter} [!][arg]				*:range!*
			將 {range} 指定的行用外部程式 {filter} 過濾。Vim 把可
			選的感嘆號替換成最後一次使用的命令，並附加上可選的引數
			[arg]。Vim 把過濾命令的輸出儲存到臨時檔案，並把文
			件內容讀到一個緩衝區裡 |tempfile|。Vim 使用
			'shellredir' 選項把過濾程式的結果重定向到臨時檔案。
			不過，如果關閉了 'shelltemp' 選項且可以的話，使用管道
			機制 (Unix 上)。
			如果 'cpoptions' 包含 'R' 標誌位，過濾行裡的位置標記被
			刪除，除非使用了 |:keepmarks| 命令。例如: >
				:keepmarks '<,'>!sort
<			如果過濾後的行數變少，刪去的行裡的位置標記無論如何不會
			儲存。

							*=*
={motion}		把 {motion} 跨越的行用 'equalprg' 選項指定的外部程式過
			濾。如果 'equalprg' 選項為空 (預設)，使用內部的排版機
			制 |C-indenting| 和 |'lisp'|，除非 'indentexpr' 非空，
			此時使用 |indent-expression| 機制來代替。反之，如果
			Vim 編譯時沒有包含內部排版機制，最後手段是使用外部的
			"indent" 程式。

							*==*
==			和 ={motion} 類似，過濾 [count] 行。

							*v_=*
{Visual}=		和 ={motion} 類似，過濾高亮行。{Vi 無此功能}


						*tempfile* *setuid*
Vim 使用臨時檔案來處理過濾、執行比較和用於 tempname()。Unix 上，該檔案會放在一
個私人的目錄裡 (只能被當前使用者訪問)，以防堵安全上的漏洞 (例如，符號連結攻擊或
檔案被其他使用者讀取等)。Vim 退出時，自動刪除該目錄及之下的所有檔案。如果 Vim 本
身設定了 setuid 位，這樣或許會有問題。臨時檔案由 setuid 使用者擁有，但過濾程式以
原來使用者的許可權執行。
MS-DOS 和 OS/2 上，使用以下目錄中首個可用者: $TMP、$TEMP、c:\TMP、c:\TEMP。
Unix 上，使用的目錄依次為: $TMPDIR、/tmp、當前目錄、$HOME。
MS-Windows 上，使用 GetTempFileName() 系統函式。
其它系統上使用 tmpnam() 庫函式。


4.2 替代						*:substitute*
							*:s* *:su*
:[range]s[ubstitute]/{pattern}/{string}/[flags] [count]
			對 [range] 指定的行把 {pattern} 的匹配替代成
			{string}。
			關於 {pattern}，參見 |pattern|。
			{string} 可以是按字面意義的，也可以包含特殊字元。
			參見 |sub-replace-special|。
							*E939*
			如果不指定 [range] 和 [count]，僅在當前行進行替代。
			如果指定 [count]，在 [range] 最後一行開始的 [count]
			行進行替代。如果不指定 [range] ，則從當前行開始。
			[count] 必須為正數。
			另見 |cmdline-ranges|。

			關於 [flags]，參見 |:s_flags|。

:[range]s[ubstitute] [flags] [count]
:[range]&[&][flags] [count]					*:&*
			使用最後一次 :substitute 相同的模式和替代字串，但不
			包括相同的標誌位。你可以另加 [flags] (見 |:s_flags|)。
			注意 在 `:substitute` 之後，不能使用 '&' 標誌位。它被
			認為是一個模式分隔符。
			`:substitute` 和 'c'、'g'、'i'、'I' 和 'r' 標誌位之間
			的空格不是必需的，但在腳本里為了避免混淆起見，最好保留
			它。

:[range]~[&][flags] [count]					*:~*
			使用最後一次 :substitute 相同的替代字串，但使用最近
			使用的搜尋模式作為匹配模式。這類似於 `:&r`。
			關於 [flags]，參見 |:s_flags|。

								*&*
&			等價於 `:s` (重複上次的 substitute)。注意 這裡不記住標
			志位，所以實際工作方式可能不盡相同。你可以用 `:&&` 來
			保持相同的標誌位。

								*g&*
g&			等價於 `:%s//~/&` (在所有行上重複上次的 substitute 並
			使用相同的標誌位，但使用前次的匹配模式)。
			例如，如果先用了替代 `:s/pattern/repl/flags` 然後
			`/search` 搜尋了其他模式，`g&`  會執行
			`:%s/search/repl/flags`。
			助記: 全域性 (global) 替代 (substitute)。{Vi 無此功能}

						*:snomagic* *:sno*
:[range]sno[magic] ...	和 `:substitute` 相同，但總使用 'nomagic'。
			{Vi 無此功能}

						*:smagic* *:sm*
:[range]sm[agic] ...	和 `:substitute` 相同，但總使用 'magic'。
			{Vi 無此功能}

							*:s_flags*
你可以在 substitute 命令裡使用以下標誌位:

							*:&&*
[&]	必須是首個使用的標誌位: 保留和上次 substitute 相同的標誌位。例如: >
		:&&
		:s/this/that/&
<	注意 `:s` 和 `:&` 不保留標誌位。
	{Vi 無此功能}

[c]	確認每個替代。Vim 高亮匹配的字串 (如果使用了 |hl-IncSearch|)。你可以
	輸入:						*:s_c*
	    'y'	    來替代這次匹配
	    'l'	    來替代這次匹配並退出 (助記: "last"，最後)
	    'n'	    來跳過這次匹配
	    <Esc>   來退出替代過程
	    'a'	    來替代這次和以後所有的匹配
	    'q'	    來退出替代過程 {Vi 無此功能}
	    CTRL-E  來上卷螢幕 {Vi 無此功能，僅當編譯時加入 |+insert_expand|
			特性才有此功能}
	    CTRL-Y  來下卷螢幕 {Vi 無此功能，僅當編譯時加入 |+insert_expand|
			特性才有此功能}
	如果 'edcompatible' 選項開啟，Vim 記住 [c] 標誌位並在每次使用它時切換
	是否確認，但在給出一個新的匹配模式時復位。
	{Vi 沒有高亮匹配部分和除了 'y' 和 'n' 之外的選擇}

[e]     如果模式搜尋不成功，不給出錯誤資訊。因為沒產生錯誤，對映的過程得以繼
	續。這主要用來防止在對映執行過程的無匹配 ("No match") 錯誤中斷對映。
	不過，Vim 不會抑制以下的錯誤資訊:
		Regular expressions can't be delimited by letters (正規表示式
			不能以字母分隔)
		\ should be followed by /, ? or & (\ 必須後面跟 /、? 或者 &)
		No previous substitute regular expression (沒有上次的替代正規
			表示式)
		Trailing characters (結尾有多餘的字元)
		Interrupted (中斷)
	{Vi 無此功能}

[g]	對行內所有的匹配進行替代。如果沒有這個引數，替代只對每行的第一個匹配進
	行。如果 'edcompatible' 選項開啟，Vim 記住這個標誌並在你每次使用該標誌
	時切換，但在給出一個新的匹配模式時復位。如果 'gdefault' 選項開啟，這個
	標誌預設開啟，而 [g] 引數關閉之。

[i]	忽略模式的大小寫。不使用 'ignorecase' 和 'smartcase' 選項。
	{Vi 無此功能}

[I]	不忽略模式的大小寫。不使用 'ignorecase' 和 'smartcase' 選項。
	{Vi 無此功能}

[n]	報告匹配的次數，並不實際進行替代。忽略 [c] 標誌位。匹配報告的發生就像
	'report' 總是為零那樣。可用於 |count-items|。
	如果使用 \= |sub-replace-expression|，該表示式對每一個匹配的執行都在
	|sandbox| 裡進行。

[p]	顯示包含最後一次替代的行。

[#]	類似 [p]，且在前面加上行號。

[l]	類似 [p]，但顯示的方式類似於 |:list|。

[r]	僅對於不帶引數的 `:&` 和 `:s` 有用。`:&r` 和 `:~` 工作的方式相同: 如果
	匹配模式為空，使用上一次使用的搜尋模式，而不是上一次的 substitute 或者
	`:global` 所使用的模式。如果最近一次使用搜索的命令就是 substitute 或者
	`:global`，那就沒有區別了。如果最近的命令的是 "/" 那樣的搜尋命令，使用
	那個命令的搜尋模式。
	帶引數的 `:s`，則不論如何，總是如此: >
		:s/blue/red/
		/green
		:s//red/   或  :~   或  :&r
<	最後的命令把 "green" 替代成 "red"。 >
		:s/blue/red/
		/green
		:&
<	最後的命令把 "blue" 替代成 "red"。
	{Vi 無此功能}

注意這裡沒有標誌位可以改變模式的 "魔術性" (magicness)。你可以用別的命令或
|/\v| 之類。原因是標誌位只能在跳過模式之後才能找到，而要跳過模式，必須先知道模
式的 "魔術性"。第二十二條軍規！

如果 substitute 命令所用的 {pattern} 為空，該命令使用上次的 substitute 或者
`:global` 命令用過的模式。如果不存在，但有上次搜尋模式，使用之。如果有 [r] 標
志位，該命令使用上次 substitute、 `:global` 或者搜尋命令使用的模式。

如果 {string} 省略，替代命令假定它為空。這樣就把匹配文字刪除了。這時，
{pattern} 之後的分隔符也可省略。例如: >
	:%s/TESTING
刪除所有行上的 "TESTING"，但每行只刪一個。

為了和 Vi 的相容性，有兩個例外:
"\/{string}/" 和 "\?{string}?" 等同於 "//{string}/r"。
"\&{string}&" 等同於 "//{string}/"。
							*E146*
除了用 '/' 來包圍模式和替代字串之外，你可以使用任何其他的單位元組字元，除了
字母、數字、'\'、'"' 或 '|' 之外。這可以用於 '/' 是搜尋模式或替代字串一部
分的場合。例如: >
	:s+/+//+

關於模式的定義，參見 |pattern|。在可視列塊模式下，如果模式中使用了 |/\%V|，那
麼替代只在列塊內進行，否則它作用於整行。

					*sub-replace-special* *:s\=*
{string} 以 "\=" 開始時，它被作為表示式來執行，參見 |sub-replace-expression|。
你可以用此功能實現複雜替換，也可用來使用特殊字元。

否則，{string} 字串裡的字元有如下的特殊含義:
								*:s%*
如果 {string} 等於 "%"，且 'cpoptions' 選項包含 '/'，重複使用上次替代命令的
{string}，見 |cpo-/|

magic	nomagic	  動作    ~
  &	  \&	  替代為完整的匹配				     *s/\&*
 \&	   &	  替代為 &
      \0	  替代為完整的匹配			 	   *\0* *s/\0*
      \1	  替代為匹配的第一個 () 裡面的內容		     *s/\1*
      \2	  替代為匹配的第二個 () 裡面的內容		     *s/\2*
      ..	  ..						     *s/\3*
      \9	  替代為匹配的第九個 () 裡面的內容		     *s/\9*
  ~	  \~	  替代為前一個 substitute 的替代字串		     *s~*
 \~	   ~	  替代為 ~					     *s/\~*
      \u	  下一個字元成為大寫				     *s/\u*
      \U	  其後字元成為大寫，直到 \E 出現		     *s/\U*
      \l	  下一個字元成為小寫				     *s/\l*
      \L	  其後字元成為小寫，直到 \E 出現		     *s/\L*
      \e	  結束 \u、\U、\l 和 \L (注意: 不是 <Esc>!)	     *s/\e*
      \E	  結束 \u、\U、\l 和 \L				     *s/\E*
      <CR>	  把該行在此位置一分為二
		  (<CR> 以 CTRL-V <Enter> 方式輸入)		     *s<CR>*
      \r	  同上						     *s/\r*
      \<CR>	  插入一個回車 (CTRL-M)
		  (<CR> 以 CTRL-V <Enter> 方式輸入)		     *s/\<CR>*
      \n	  插入一個 <NL> (檔案裡的 <NUL>)
		  (此處並不是換行)				     *s/\n*
      \b	  插入一個 <BS>					     *s/\b*
      \t	  插入一個 <Tab>				     *s/\t*
      \\	  插入單個反斜槓				     *s/\\*
      \x	  其中 x 是上面沒提到的任何一個字元:
		  保留作將來的擴充套件

這裡的特殊含義也用於 |substitute()| 函式的第三個引數 {sub}，除了若干例外:
  - % 總是插入百分號，與 'cpoptions' 無關。
  - 總是假定有魔術性，與 'magic' 無關。
  - ~ 總是插入波浪符。
  - <CR> 和 \r 插入回車 (CTRL-M)。
  - \<CR> 沒有特殊意義，只是 \x 之一。

示例: >
  :s/a\|b/xxx\0xxx/g		 修改 "a b"	 為 "xxxaxxx xxxbxxx"
  :s/\([abc]\)\([efg]\)/\2\1/g	 修改 "af fa bg" 為 "fa fa gb"
  :s/abcde/abc^Mde/		 修改 "abcde"    為 "abc"、"de" (兩行)
  :s/$/\^M/			 修改 "abcde"    為 "abcde^M"
  :s/\w\+/\u\0/g		 修改 "bla bla"  為 "Bla Bla"
  :s/\w\+/\L\u\0/g		 修改 "BLA bla"  為 "Bla Bla"

注意: "\L\u" 可用於使單詞的首個字母變大寫。此行為和 Vi 以及舊版 Vim 不相容，那
裡 "\u" 會抵消 ”\L"。"\U\l" 亦然。

注意: 在以前的版本里，CTRL-V 以特殊的方式處理。因為和 Vi 不相容，該功能已經被
去掉了，現在用反斜槓來替代。

命令		文字	結果 ~
:s/aa/a^Ma/	aa	a<line-break>a
:s/aa/a\^Ma/	aa	a^Ma
:s/aa/a\\^Ma/	aa	a\<line-break>a

(你需要輸入 CTRL-V <CR> 來得到這裡的 ^M)

"\1"，"\2" 等裡的數字是基於模式裡 "\(" 出現的順序 (從左到右)。如果一個括號組匹
配多次，最後一次的匹配被使用在 "\1"，"2" 等裡。例如: >
  :s/\(\(a[a-d] \)*\)/\2/      修改 "aa ab x" 為 "ab x"
"\2" 對應 "\(a[a-d] \)"。第一次匹配 "aa "，第二次匹配 "ab "。

如果括號和 '|' 組合使用，如 \([ab]\)\|\([cd]\)，兩者有一個會不匹配，所以 \1 或
者 \2 會為空。例如: >
  :s/\([ab]\)\|\([cd]\)/\1x/g   修改 "a b c d" 為 "ax bx x x"

<
		*:sc* *:sce* *:scg* *:sci* *:scI* *:scl* *:scp* *:sg* *:sgc*
		*:sge* *:sgi* *:sgI* *:sgl* *:sgn* *:sgp* *:sgr* *:sI* *:si*
		*:sic* *:sIc* *:sie* *:sIe* *:sIg* *:sIl* *:sin* *:sIn* *:sIp*
		*:sip* *:sIr* *:sir* *:sr* *:src* *:srg* *:sri* *:srI* *:srl*
		*:srn* *:srp*
2-字母和 3-字母的 :substitute 命令 ~

     :substitute 命令列表
     |      c    e    g    i    I    n    p    l    r
     | c  :sc  :sce :scg :sci :scI :scn :scp :scl  ---
     | e
     | g  :sgc :sge :sg  :sgi :sgI :sgn :sgp :sgl :sgr
     | i  :sic :sie  --- :si  :siI :sin :sip  --- :sir
     | I  :sIc :sIe :sIg :sIi :sI  :sIn :sIp :sIl :sIr
     | n
     | p
     | l
     | r  :src  --- :srg :sri :srI :srn :srp :srl :sr

例外:
     :scr  是  `:scriptnames`
     :se   是  `:set`
     :sig  是  `:sign`
     :sil  是  `:silent`
     :sn   是  `:snext`
     :sp   是  `:split`
     :sl   是  `:sleep`
     :sre  是  `:srewind`


以表示式方式替代				*sub-replace-expression*
						*sub-replace-\=* *s/\=*
當替代字串以 "\=" 開始時，其餘部分被解釋為一個表示式。

除了 "<CR>" 以外，|sub-replace-special| 提到的字元的特殊含義這裡不適用。<NL>
字元被用作換行符，雙引號字串 "\n" 也可以。在 <NL> 之前加上反斜槓得到一個真正
的 <NL> 字元 (在檔案裡成為 NUL)。

"\=" 記法也可用於 |substitute()| 函式的第三個引數 {sub} 之內，這時，
|sub-replace-special| 指出的特殊含義完全不適用。具體說，<CR> 和 <NL> 不用作換
行，而分別是回車和新行。

如果結果是 |List|，連線其中的專案並以換行符分隔。這樣，每個專案單獨成為一行，
當然本身就包含換行符的除外。

完整的匹配可以用 "submatch(0)" 得到。首個括號裡的匹配可以用 "submatch(1)"，餘
者類似。

小心: 分隔符不能出現在表示式裡！可以考慮使用 "@" 或者 ":" 那樣的字元。執行結果
裡出現分隔符不成問題。

例如: >
	:s@\n@\="\r" . expand("$HOME") . "\r"@
把換行符替代為包含 $HOME 值的一個新行。 >

	s/E/\="\<Char-0x20ac>"/g
把所有的 'E' 字元替代為歐元符號。詳見 |<Char->|。


4.3 搜尋與替代						*search-replace*

							*:pro* *:promptfind*
:promptf[ind] [string]
			彈出搜尋對話方塊。如果給出 [string]，它被用作初始的搜尋
			字串。
			{僅適用於 Win32、Motif 和 GTK GUI 環境}

						*:promptr* *:promptrepl*
:promptr[epl] [string]
			彈出搜尋/替代對話方塊。如果給出 [string]，它被用作初始的
			搜尋字串。
			{僅適用於 Win32、Motif 和 GTK GUI 環境}

4.4 改變製表						*change-tabs*
							*:ret* *:retab* *:retab!*
:[range]ret[ab][!] [new_tabstop]
			把所有包含 <Tab> 的空白序列替代成由新的製表位
			[new_tabstop] 確定的空白序列。如果你不指定新的製表位，
			或者它為 0，Vim 使用原來的製表位 'tabstop'。
			已有的 Tab 的寬度總是用 'tabstop' 的當前值來計算。
			如果有 !，Vim 也在合適的時候，把只包含正常空格的字串
			換成 Tab。
			如果置位了 'expandtab'，Vim 把所有的 Tab 換成相當的空
			格。
			該命令把 'tabstop' 設為新值。如果按照預設的情況，在全
			檔案上進行處理，視覺上應該不會有任何改變。
			小心: 該命令修改 C 程式中的字串裡的任何 <Tab> 字元。
			要避免這一點，用 "\t" (無論如何，應該養成這個好的習
			慣)。
			`:retab!` 也把空格序列換成 <Tab>，這可能會使 printf()
			引起混淆。
			{Vi 無此功能}

							*retab-example*
下面的例子使用自動命令和 ":retab" 來編輯使用製表位為 8 的檔案，但在編輯時製表
位設定為 4。警告: 字串裡的空格會被改變。另見 'softtabstop' 選項。 >

  :auto BufReadPost	*.xx	retab! 4
  :auto BufWritePre	*.xx	retab! 8
  :auto BufWritePost	*.xx	retab! 4
  :auto BufNewFile	*.xx	set ts=4

==============================================================================
5. 複製並移動文字					*copy-move*

							*quote*
"{a-zA-Z0-9.%#:-"}	指定下次的刪除、抽出和放置命令使用的暫存器
			{a-zA-Z0-9.%#:-"} (大寫字元使得刪除和抽出命令附加到該
			暫存器) ({.%#:} 只能用於放置命令)。

							*:reg* *:registers*
:reg[isters]		顯示所有編號和命名暫存器的內容。但不列出用於 |:redir|
			目的地的暫存器。
			{Vi 無此功能}

:reg[isters] {arg}	顯示 {arg} 裡提到的編號和命名暫存器的內容。例如: >
				:reg 1a
<			顯示暫存器 '1' 和 'a'。{arg} 裡可以用空格。
			{Vi 無此功能}

							*:di* *:display*
:di[splay] [arg]	和 :registers 相同。{Vi 無此功能}

							*y* *yank*
["x]y{motion}		抽出 {motion} 跨越的文字 [到暫存器 x]。如果沒有字元被
			抽出 (例如，在第一列執行 "y0") 並且 'cpoptions' 裡包括
			'E' 標誌位，這是一個錯誤。

							*yy*
["x]yy			抽出 [count] 行 [到暫存器 x] |linewise| 行動作。

							*Y*
["x]Y			抽出 [count] 行 [到暫存器 x] (等同於 yy，|linewise| 行
			動作)。如果你想要 "Y" 執行從游標到行尾的操作 (更合乎邏
			輯，但是與 Vi 不相容)，用 ":map Y y$"。

							*v_y*
{Visual}["x]y		抽出高亮文字 [到暫存器 x] (關於 {Visual} 見
			|Visual-mode|)。{Vi 無此功能}

							*v_Y*
{Visual}["x]Y		抽出高亮行 [到暫存器 x] (關於 {Visual} 見
			|Visual-mode|)。{Vi 無此功能}

							*:y* *:yank* *E850*
:[range]y[ank] [x]	抽出 [range] 所指定的行 [到暫存器 x]。僅當包含
			|+clipboard| 特性時才可以抽出到 "* 或 "+ 暫存器。

:[range]y[ank] [x] {count}
			從 [range] 的最後一行開始 (預設: 當前行
			|cmdline-ranges|) 抽出 {count} 行 [到暫存器 x]。

							*p* *put* *E353*
["x]p			放置文字 [從暫存器 x] 在游標之後 [count] 次。{Vi: 沒有
			計數}

							*P*
["x]P			放置文字 [從暫存器 x] 在游標之前 [count] 次。{Vi: 沒有
			計數}

							*<MiddleMouse>*
["x]<MiddleMouse>	從一個暫存器放置文字在游標之前 [count] 次。除非另外指
			定，否則用 "* 暫存器。
			游標停留在新文字的尾部。
			只有在 'mouse' 包含 'n' 或者 'a' 時滑鼠才會工作。
			{Vi 無此功能}
			如果你有滾輪滑鼠而且經常不小心貼上了文字，你可以使用以
			下對映來關閉滑鼠中鍵貼上的功能: >
				:map <MiddleMouse> <Nop>
				:imap <MiddleMouse> <Nop>
<			你也許還想要關閉多鍵擊的功能。參見 |double-click|。

							*gp*
["x]gp			如同 "p"，但游標停留在新文字之後。{Vi 無此功能}

							*gP*
["x]gP			如同 "P"，但游標停留在新文字之後。{Vi 無此功能}

							*:pu* *:put*
:[line]pu[t] [x]	放置文字 [從暫存器 x] 在行號 [line] (預設為當前行) 之
			後。它總是 |linewise| 行動作，因而這個命令可以用來把抽
			出的塊放置在新行上。
			如果未指定暫存器，則取決於 'cb' 選項: 如果 'cb' 包含
			"unnamedplus"，則從 + 暫存器 |quoteplus| 取出，否則如
			果 'cb' 包含 "unnamed"，則從 * 暫存器 |quotestar| 取
			出，否則，從無名暫存器 |quote_quote| 取出。
			暫存器也可以是 '='，跟隨一個可選的表示式。表示式繼續到
			該命令結束為止。你需要在 '|' 和 '"' 字元前加上反斜槓不
			讓它們終止你的命令列。例如: >
				:put ='path' . \",/test\"
<			如果 '=' 之後沒有表示式，Vim 使用前一個表示式。用
			":dis =" 你可以看到它。

:[line]pu[t]! [x]	放置文字 [從暫存器 x] 在行號 [line] (預設為當前行) 之
			前。

["x]]p		    或					*]p* *]<MiddleMouse>*
["x]]<MiddleMouse>	類似 "p"，但調整當前行的縮排。只有在 'mouse' 包含 'n'
			或者 'a' 時滑鼠才會工作。{Vi 無此功能}

["x][P		    或					*[P*
["x]]P		    或					*]P*
["x][p		    或					*[p* *[<MiddleMouse>*
["x][<MiddleMouse>	類似 "P"，但調整當前行的縮排。只有在 'mouse' 包含 'n'
			或者 'a' 時滑鼠才會工作。{Vi 無此功能}

你可以用這些命令把文字從一個地方複製到另一個地方。首先，把文字用抽出、刪除或者
修改命令取到一個暫存器裡，然後用放置命令把暫存器的內容插入。你可以用這些命令把
文字從一個檔案移動到另一個檔案，因為 Vim 在切換緩衝區時保留所有的暫存器
(CTRL-^ 命令可用來快捷地切換檔案)。

				*linewise-register* *characterwise-register*
除了 :put 以外，你可以用 "." 重複放置命令，你也可以撤銷它們。如果儲存到暫存器
文字的命令是 |linewise| 行動作，Vim 把文字插入在游標所在的行之下 ("p") 或之上
("P")。不然，Vim 把文字插入在游標的之後 ("p") 或之前 ("P")。":put" 命令使得
Vim 總是把文字放在下一行。你可以用命令序列 "xp" 來交換兩個字母。你可以用 "ddp"
命令序列來交換兩行。你還可以用 "deep" 命令交換兩個單詞 (游標在第一個單詞之前的
空白上)。你更可以在放置命令之後用 "']" 或者 "`]" 命令把游標移動到插入文字之
後，或者用 "'[" 或 "`[" 把游標移動到文字的開始處。

						*put-Visual-mode* *v_p* *v_P*
在可視模式下使用如 |p| 或者 |P| 之類的放置命令時，Vim 試圖把選擇的文字替換成寄
存器的內容。是否工作如你所願決定於選擇的型別和暫存器裡文字的型別。對於列塊選擇
而言，它也決定於列塊的大小，和頭尾是否在已存在的字元上。(實現細節: 實際上，它
先把暫存器的內容放到選擇區之後，再刪除選擇區的內容。)
前次選擇的文字被放在無名暫存器中。如果希望把相同的文字重複放入可視選擇區多次，
請選用其它暫存器。例如，先抽出要複製的文字，再視覺化選擇要替換的文字，然後使用
"0p。重複任意多次均可，而每次無名暫存器都會被改變。

應用面向列塊的可視模式命令抽出單行到暫存器時，貼上該暫存器到某一可視選擇的區域
會把該行復制到選擇的每一行上 (也即，把選擇的列塊區域替代為被複制行的列塊)。

							*blockwise-register*
如果你使用面向列塊的可視模式命令把文字存到暫存器裡，文字列塊會被插入在當前和其
後的行的當前列之前 ("P") 或之後 ("p")。Vim 使得整個文字列塊從同一列開始。這
樣，插入的文字看上去和抽出或刪除時看起來一樣。為了使之可能，Vim 可能需要把一些
<Tab> 字元替換成空格。不過，如果列塊的寬度不是 <Tab> 寬度的整數倍並且插入列塊
之後文本里包含 <Tab> 的時候，那些文字可能就不會那麼整齊。

注意 在一個面向字元的抽出命令之後，Vim 把游標停留在最接近緩衝區開頭的第一個被
抽出的字元之上。這意味著 "yl" 不會移動游標，但是 "yh" 把游標向左移一格。
邏輯:		在 Vi 裡 "y" 命令跟一個反向的動作有時不會把游標移動到第一個被
		抽出的字元之上，因為螢幕沒有重新整理。Vim 符合 Posix 的規範，總是
		把游標移動到第一個字元之上。
在一個面向行的抽出命令之後，游標放在第一行上，但是列保持不變，所以不必然在第一
個抽出的字元上。

共有十種型別的暫存器:					*registers* *E354*
1. 無名暫存器 ""
2. 10 個編號暫存器 "0 到 "9
3. 行內刪除暫存器 "-
4. 26 個命名的暫存器 "a 到 "z 或者 "A 到 "Z
5. 三個只讀暫存器 ":、". 和 "%
6. 輪換緩衝區暫存器 "#
7. 表示式暫存器 "=
8. 選擇和拖放暫存器 "*、"+ 和 "~ 
9. 黑洞暫存器暫存器 "_
10. 最近搜尋模式暫存器 "/

1. 無名暫存器 ""				*quote_quote* *quotequote*
用 "d"、"c"、"s"、"x" 等命令刪除或者用 "y" 等抽出命令複製的文字都被 Vim 用來填
充該暫存器，不管是否用到別的專門暫存器 (例如 "xdd)。這就好像無名暫存器是指向最
近使用的那個暫存器的指標一樣。使用大寫暫存器進行新增時，無名暫存器包含和命名寄
存器相同的文字。'_' 暫存器是一個特例。"_dd 不把刪除的文字存在任何暫存器裡。
不指定暫存器的放置命令 (p 或 P) 使用無名暫存器的內容。你也可以用 '"' 作為名字
來訪問該暫存器。這意味著要輸入兩個連續的雙引號。寫入 "" 暫存器將實際寫到暫存器
"0 上。
{Vi: 暫存器內容在更換檔案時丟失，沒有 '"'}

2. 編號暫存器 "0 到 "9			*quote_number* *quote0* *quote1*
					*quote2* *quote3* *quote4* *quote9*
Vim 把抽出和刪除命令的文字儲存在這些暫存器裡。
   編號暫存器 0 包含最近抽出的文字，除非該命令用 ["x] 指定了別的暫存器。
   編號暫存器 1 包含了最近刪除或者修改的文字，除非該命令用 ["x] 指定了別的寄存
器或者該文字小於一行 (該情況下使用行內刪除暫存器)。以下移動命令在應用刪除操作
符時例外: |%|、|(|、 |)|、|`|、|/|、|?|、|n|、|N|、|{| 和 |}|。它們總是使用寄
存器 "1 (為了和 Vi 相容)。如果文字小於一行，同時使用 "- 暫存器。
注意 這些字元可能會被對映。例如，matchit 外掛會對映 % 字元。
   每來一次新的刪除和修改，Vim 把前一次的暫存器 1 的內容複製到暫存器 2，2 到
3，依此類推。而暫存器 9 的內容就丟失了。
{Vi: 編號暫存器的內容在更換檔案時丟失；暫存器 0 不存在}

3. 行內刪除暫存器 "-					*quote_-* *quote-*
該暫存器儲存刪除不到一行內容的命令的文字，除非該命令用 ["x] 指定了暫存器。
{Vi 無此功能}

4. 命名暫存器 "a 到 "z 或者 "A 到 "Z			*quote_alpha* *quotea*
Vim 只有在你指定的時候才使用這些暫存器。指定為小寫字母時替換原來的內容，指定為
大寫字母時附加到原來的內容。如果 'cpoptions' 裡有 '>' 標誌位，在附加文字前插入
一個換行符。


5. 只讀暫存器 ":、". 和 "%
它們是 '%'、'#' (譯者注: 原文如此)、':' 和 '.'。你只能在 "p"、"P"、":put" 命令
和 CTRL-R 的時候使用它們。{Vi 無此功能}
						*quote_.* *quote.* *E29*
	".	包含最近插入的文字 (和插入模式命令 CTRL-A 和 CTRL-@ 插入的一
		樣)。注意: 它不適用於 CTRL-R 在命令列上的操作。它的工作方式稍
		有不同，例如，文字是被插入而不是放置的 ('textwidth' 和其它選項
		影響插入的內容)。
							*quote_%* *quote%*
	"%	包含當前檔名。
						*quote_:* *quote:* *E30*
	":	包含最近執行過的命令列。例如: 用 "@:" 重複上次執行過的命令列命
		令。只有當一個命令列中至少一個字元是鍵入的，該暫存器才會儲存命
		令行的內容。所以，如果命令列完全來自對映，該暫存器保持不變。
		{僅當編譯時加入 |+cmdline_hist| 特性才有效}
							*quote_#* *quote#*
6. 輪換檔案暫存器 "#
包含當前視窗輪換檔案的名字。它影響 CTRL-^ 的命令的工作方式。
該暫存器是可寫的，主要用來幫助外掛在改變其值後恢復原值。接受緩衝區號: >
    let altbuf = bufnr(@#)
    ...
    let @# = altbuf
如果傳遞了不存在的緩衝區號，會報錯 |E86|。
也可接受現有緩衝區名的匹配: >
    let @# = 'buffer_name'
如果有多於一個緩衝區匹配該名，報錯 |E93|，如果沒有緩衝區匹配該名，也會報錯
|E94|。

7. 表示式暫存器 "=				*quote_=* *quote=* *@=*
其實並沒有這麼一個暫存器可以儲存文字，但是這是用來在使用暫存器的命令中使用表達
式的一個方式。表示式暫存器是可讀寫的。

" 之後輸入 '=' 或者輸入 CTRL-R 時，游標移到命令列上，這時你可以輸入任何的表達
式 (見 |expression|)。所有普通的命令列編輯命令都可以使用，還有一個表示式專門的
歷史表。當你按回車結束命令列時，Vim 計算表示式的結果。如果你用 <Esc> 結束，Vim
終止表示式。如果你不輸入表示式，Vim 使用最近的表示式 (和 "/" 命令的處理相似)。

表示式的計算結果必須是一個字串。數值結果會自動轉化為字串。對 "p" 和 ":put"
命令而言，浮點數結果也會被轉化為字串。如果結果為列表，每個成員被轉成字串，
然後被單獨放在一行上。字典、函式引用型別的結果則產生錯誤資訊 (通過 string() 轉
化)。

如果 "= 暫存器被 "p" 命令使用，該字串會在 <NL> 字元處斷開。如果該字串以
<NL> 結尾，則它被視為一個面向行的暫存器。{Vi 無此功能}

8. 選擇和拖放暫存器 "*、"+ 和 "~ 
用這些暫存器來儲存和取得 GUI 介面選擇的文字。參見 |quotestar| 和 |quoteplus|。
如果剪貼簿不存在或者不工作，使用無名暫存器。Unix 上，僅當 |+xterm_clipboard|
特性存在時剪貼簿才可用。{Vi 無此功能}

注意 "* 和 "+ 在 X11 系統上有分別。關於該差別的解釋，參見 |x11-selection|。在
MS-Windows 上，"* 和 "+ 的使用實際上是等價的，可見 |gui-clipboard|。

						*quote_~* *quote~* *<Drop>*
只讀的 "~ 暫存器儲存最近一次拖放操作放下的文字。如果有什麼東西被放到 Vim 上，
"~ 暫存器被填充，<Drop> 虛擬鍵被啟用。如果你需要，你可以重定義該鍵的對映；預設
的動作 (適用於所有模式) 是把 "~ 暫存器的內容插入到當前游標位置。{Vi 無此功能}
{僅當編譯時加入 |+dnd| 特性才有效，當前只適用於 GTK GUI 版本}

注意: "~ 暫存器僅用於在 Vim 上拖放普通文字。拖放 URI 列表在內部處理。

9. 黑洞暫存器 "_				*quote_*
當寫到這個暫存器時，什麼都不會發生。這可以用來刪除文字，而不影響任何正常的寄存
器。從該暫存器讀時，什麼都不會返回。{Vi 無此功能}

10. 最近搜尋模式暫存器	"/			*quote_/* *quote/*
含有最近搜尋的模式。它被 "n" 和 'hlsearch' 使用。可以用 `:let` 來修改。你可以
改變它使得 'hlsearch' 不經過實際的搜尋直接高亮某些匹配。你不能把抽出或者刪除命
令的內容放到該暫存器上。搜尋方向則可從 |v:searchforward| 得到。
注意 從函式返回時該值被複原 |function-search-undo|。
{Vi 無此功能}

							*@/*
你可以用 `:let` 命令寫到一個暫存器 |:let-@|。例如: >
	:let @/ = "the"

如果你用放置命令而不指定暫存器，Vim 使用上次填充的暫存器 (這也是無名暫存器的內
容)。如果你弄糊塗了，用 `:dis` 命令看看 Vim 會放置什麼內容 (該命令顯示所有的有
名和無名的暫存器；無名暫存器被標為 '"')。

下面三個命令總是針對整行工作。

:[range]co[py] {address}				*:co* *:copy*
			把 [range] 指定的行復制到 {address} 給出的行之下。

							*:t*
:t			和 :copy 等價。

:[range]m[ove] {address}			*:m* *:mo* *:move* *E134*
			把 [range] 指定的行移動到 {address} 給出的行之下。

==============================================================================
6. 文字排版						*formatting*

:[range]ce[nter] [width]				*:ce* *:center*
			在 [range] 指定範圍的行和 [width] 限定的列 (預設為
			'textwidth'，如其為 0，則取 80) 範圍內的文字居中對齊。
			{Vi 無此功能}

:[range]ri[ght] [width]					*:ri* *:right*
			在 [range] 指定範圍的行和 [width] 限定的列 (預設為
			'textwidth'，如其為 0，則取 80) 範圍內的文字靠右對齊。
			{Vi 無此功能}

							*:le* *:left*
:[range]le[ft] [indent]
			在 [range] 指定範圍的行的文字靠左對齊。其縮排的距離可
			由 [indent] 設定 (預設為 0)。
			{Vi 無此功能}

							*gq*
gq{motion}		對 {motion} 動作跨越的行進行排版。
			排版使用如下三種方式之一:
			1. 如果 'formatexpr' 不為空，計算該表示式。每個緩衝區
			   的值可以不同。
			2. 如果 'formatprg' 不為空，使用外部程式。
			3. 否則，使用內部排版機制。

			第三種方式使用 'textwidth' 選項控制所有待排版行的行寬
			(見下)。
			如果 'textwidth' 選項為 0，則排版行寬設為螢幕的寬度
			(但最大寬度不超過 79)。
			'formatoptions' 選項控制排版的方式 |fo-table|。
			游標停留在排版行末行的第一個非空白處。
			注意: "Q" 命令以前執行此項功能。如果你還想繼續用 "Q"
			來排版，執行如下對映命令: >
				:nnoremap Q gq

gqgq							*gqgq* *gqq*
gqq			排版當前行。如帶計數排版相應多行。{Vi 無此功能}

							*v_gq*
{Visual}gq		排版高亮文字 ({Visual} 的部分參見 |Visual-mode|)。
			{Vi 無此功能}

							*gw*
gw{motion}		對 {motion} 動作跨越的行進行排版。和 |gq| 類似，但排版
			後游標恢復原位。而且不使用 'formatprg' 和 'formatexpr'
			選項。
			{Vi 無此功能}

gwgw							*gwgw* *gww*
gww			對當前行排版，其它和 "gw" 類同。{Vi 無此功能}

							*v_gw*
{Visual}gw		排版高亮文字，其它和 "gw" 類同。({Visual} 可見
			|Visual-mode|)。{Vi 無此功能}

例如: 要排版當前段落，可用: 					*gqap*  >
	gqap

"gq" 命令後，游標隨著指定的移動命令移動。這使得用 "." 進行連續排版成為可能。例
如，"gqj" (對當前行和下一行排版) 和 "gq}" (排版到段落尾) 便可如此。注意: 如果
設定了 'formatprg'，"gq" 把游標留在排版後的首行 (如同過濾命令那般)。

如果你想對當前段落排版後留在原來的位置，可用: >
	gwap
如果你想使段落自動排版，可以在 'formatoptions' 里加入 'a' 標誌位。參見
|auto-format|。

如果 'autoindent' 選項開啟，Vim 用首行的縮排距離排版其後的所有行。

排版不會改變空行 (但會改變只有空白字元的行！)。

如果有連線行的操作，應用 'joinspaces' 選項。

你可以設定 'formatexpr' 選項為某表示式或設定 'formatprg' 選項為外部程式名，Vim
會用之進行文字排版。'textwidth' 等選項對外部程式的排版不起作用。

							*right-justify*
Vim 沒有靠右控制對齊 (right justify) 文字的命令。你可以用 "par" 這樣的外部命令
來實現 (例如， "!}par" 對到段落尾的文字排版)，或者設定 'formatprg' 為 "par"。

							*format-comments*
使用者手冊的 |30.6| 一節給出註釋排版的總覽。

Vim 可以自動對註釋的插入和排版進行特殊處理。Vim 把以特定字串開頭 (忽略空白)
的行識別為註釋。以下是三種不同型別的註釋:

- 在每行的開頭都出現的註釋字串。例如，外殼指令碼使用的註釋行都以 "#" 開頭。
- 只在首行出現的註釋字串。使用連字元 "-" 的本列表就是這樣的一個例子，
- 由三部分組成的註釋，包括起始字串，結尾字串，和兩者之間可選的行的起始字元
  串。三種字串可分別指定。如下 C 風格的註釋就是如此:
	/*
	 * this is a C comment
	 */

'comments' 選項是一個由逗號分隔的列表。每個部分定義一種型別的註釋字串。每個
部分的組成方式是:
	{flags}:{string}

{string} 是必須出現的字串 (不作轉義)。

{flags}:
  n	可巢狀的註釋: 允許多個部分間的巢狀。例如，'comments' 為 "n:),n:>"。則
	以 "> ) >" 開始的行視為註釋。

  b	在 {string} 之後必須有空白字元 (<Space>、<Tab> 或 <EOL>)。

  f	該註釋字串只在首行出現。下一行不重複註釋，但保留相同的縮排 (例如，帶
  	符號的列表 (bullet-list))。

  s	三段式註釋的起始字串

  m	三段式註釋的中間字串

  e	三段式註釋的結尾字串

  l	左對齊。和 's' 或 'e' 一起使用。起始或結尾字串的最左字元和中間字串
	的最左字元對齊。
	這是預設值，可以省略。詳情見下。

  r	右對齊。同上，不過不是最左字元而是最右字元。詳情見下。

  O	"O" 命令不把它當作註釋。

  x	允許三段式註釋用以下方式結束: 在中間字串自動提供的情況下，在新行第一
	個動作是輸入結尾字串的最後一個字元。詳情見下。

  {digits}
	在和 's' 或 'e' 一起使用時: 對自動插入的中間或結尾字串增加 {digit}
	單位的位移。該位移以左對齊的位置為基準。詳情見下。

  -{digits}
	和 {digits} 類似，但減少縮排。這隻對開始或結尾部分至少有相當數量的縮排
	時才有效。

如果一個字串沒有 'f'、's'、'm' 或 'e' 任何一個標誌位，Vim 假設註釋字串在每
行都重複出現。標誌位部分可以為空。

在 {string} 之前或之後的任何空白都是 {string} 的一部分，所以不要隨便留出開頭或
結尾的空白，除非空白的確是註釋字串的一部分。

如果某個註釋字串是另一個字串的一部分，先指定完整的，再指定部分的。例如，要
包含 "-" 和 "->"，用 >
	:set comments=f:->,f:-

三段式註釋必須以開始、中間和結尾三部分給出，而且不能間雜其它的部分。一個三段式
C 註釋的例子是 >
	sr:/*,mb:*,ex:*/
為了避免形如 "*ptr" 的內容被識別為註釋，這裡的中間字串包含了 'b' 標誌位。對
三段式註釋而言，Vim 從開始和中間字串之後查詢結尾字串。如果找到，註釋就不會
再從下一行繼續。三段式註釋必須要有一箇中間字串，不然 Vim 無法識別中間的那些
行。

注意 上述三段式註釋定義裡的 "x" 標誌位。當你在一個 C-註釋裡按回車時，Vim 會自
動在新行後插入中間字串: " * "。要結束註釋，你只需要在新行裡首先鍵入 "/"。這
樣就把中間字串替換成結尾字串並應用指定的對齊方式，成為了 " */"。從而省卻了
先按退格鍵的麻煩。

如果同時匹配中間部分和結尾部分但結尾部分更長，使用結尾部分。這樣 C 風格註釋就
不需要中間部分後加空格了。

這裡是一個關於用於對齊的標誌位的例子，使得註釋看起來很突出 (也很像一個 1 字)。
考慮註釋字串: >
	:set comments=sr:/***,m:**,ex-2:******/
<
                                   /*** ~
                                     **<--右對齊，來自 "r" 標誌位 ~
                                     ** ~
  2 個單位的位移，來自 "2" 標誌位--->** ~
                                   ******/ ~
該例中，第一行註釋是鍵入的，然後按回車四次，最後按 "/" 以結束註釋。

這裡是三部分註釋的一些細節。有三個時間點應用對齊和位移標誌位: 輸入起始字串後
開啟新行、在結尾字串前開啟新行、三部分註釋的自動結束。而結尾部分的對齊標誌位
要反過來看；這樣，相同的對齊標誌位在分別用於 "s" 和 "e" 時才會使起始和結尾部分
有相同的縮排。每個註釋部分只應用一種對齊方式，但位移優先於 "r" 和 "l" 標誌位。

開啟 'cindent' 在很多情況下會覆蓋對齊標誌位。使用其它方法，如 |gq| 或 |=| 來重
新縮排也不會參考對齊標誌位。這些其它的排版選擇可以定義類似的行為。一個擔心是
'cindent' 雖然有眾多附加的選項來對註釋進行基於上下文的縮排，但不能再現三部分注
釋的縮排對齊。但 'indentexpr' 應該有能力很好地處理三部分註釋。

其它示例: >
   "b:*"	包含 "*" 開頭的行，但 "*" 後面不是空白的除外。這樣避免指標取值
		操作 "*str" 被識別為註釋。
   "n:>"	包含形如 ">"、">>"、">>>" 等開頭的行。
   "fb:-"	包含 "- " 開頭的列表，可用來自動排版。

該選項的預設值是 "b:#"。這意味著 "#include" 開頭的行不會被認為是註釋，但
"# define" 是。這是個不得不然的妥協。

{僅當編譯時加入 |+comments| 特性才有效}

							*fo-table*
你可以使用 'formatoptions' 選項來控制 Vim 如何對文字進行排版。'formatoptions'
是一個字串，它可以包含下列字元。預設設定是 "tcq"。為了提高可讀性，你可以用逗
號分隔選項字元。

字元	 在 'formatoptions' 裡代表的含義   ~

t	使用 'textwidth' 自動迴繞文字
c	使用 'textwidth' 自動迴繞註釋，自動插入當前註釋前導符。
r	在插入模式按回車時，自動插入當前註釋前導符。
o	在普通模式按 'o' 或者 'O' 時，自動插入當前註釋前導符。
q	允許 "gq" 排版時排版註釋。
	注意 排版不會影響空行或者只有註釋前導符的行。這樣的行開啟一個新段落，
	註釋前導符的改變也是如此。
w	拖尾的空格指示下一行繼續同一個段落。而以非空白字元結束的行結束一個段
	落。
a	自動排版段落。每當文字被插入或者刪除時，段落都會自動進行排版。參見
	|auto-format|。
	如果 'c' 標誌位存在，該設定只對識別的註釋有效。
n	在對文字排版時，識別編號的列表。實際上，這裡使用了 'formatlistpat' 選
	項，所以可以使用任何型別的列表。出現在數字之後的文字縮排距離被應用到後
	面的行。數字之後可以有可選的 '.'、 ':'、')'、']' 或者 '}'。
	注意 'autoindent' 也必須置位。不要和 "2" 一起使用，效果不好。
	示例: >
		1. 第一項
		   迴繞文字
		2. 第二項
2	在對文字排版時，將段落第二行而非第一行的縮排距離應用到其後的行上。這適
	用於第一行有特殊縮排需要的段落。注意 'autoindent' 也必須置位。
	示例: >
			first line of a paragraph
		second line of the same paragraph
		third line.
<	也適用於註釋內部，並忽略註釋前導符。
v	Vi-相容的插入模式自動迴繞: 只有在當前輸入命令鍵入的空白上才會分行。
	(注意: 這並不能 100% Vi 相容。Vi 在這方面有些 "意想不到的特性"，換而言
	之，漏洞。它使用螢幕列而非實際的列。)
b	和 'v' 類似，但只有在鍵入空白時還沒抵達或者剛到迴繞邊界的時候才會自動
	迴繞。如果一行在開始插入之前已經超過 'textwidth' 指定的長度，或者在到
	達 'textwidth' 之時沒有輸入過空白，Vim 不會自動迴繞。
l	插入模式不分行: 當一行已經超過 'textwidth' 時，插入命令不會自動排版。
m	可以在任何值高於 255 的多位元組字元上分行。這對亞洲文字尤其有用，因為每
	個字元都是單獨的單位。
M	在連線行時，不要在多位元組字元之前或之後插入空格。優先於 'B' 標誌位。
B	在連線行時，不要在兩個多位元組字元之間插入空格。有 'M' 標誌位時無效。
1	不要在單字母單詞後分行。如有可能，在它之前分行。
j	在合適的場合，連線行時刪除註釋前導符。例如，連線:
		int i;   // the index ~
		         // in the list ~
	結果是:
		int i;   // the index in the list ~


't' 和 'c' 不同組合方式決定 Vim 何時進行自動迴繞:
值	行為	~
""	沒有自動排版 (你可以用 "gq" 進行手工排版)
"t"	自動排版文字，不包括註釋
"c"	自動排版註釋，不包括文字 (對 C 程式適用)
"tc"	自動排版文字和註釋

注意 如果 'textwidth' 為 0，Vim 不會做任何自動排版 (但是會根據 'comments' 選項
自動插入註釋前導符)。但 'a' 標誌位存在時有例外。|auto-format|

注意 如果 'paste' 開啟，Vim 也不會做任何排版。

注意 即使 Vim 不做自動迴繞，仍然可以把 'textwidth' 設為非零。'textwidth' 對
"gq" 的排版依然有用。

如果 'comments' 選項包含 "/*"、"*" 和/或 "*/"，Vim 有一套處理這些註釋更加聰明
的內嵌方法。在 "/*" 或 "*/" 之前或之後開始一個新行 (在 'formatoptions' 裡有
'r' 或者 'o' 的情況下)，會自動給出正確的開始部分。排版或者自動迴繞也會有相同的
處理。在以 "/*" 或者 "*" 開始幷包含 "*/" 的行之後開啟新行，就不會插入註釋前導
符，而且新行的縮排由註釋起始行決定。
例如: >
    /* ~
     * 你的任何註釋。
     */ ~
    該行的縮排和以上註釋的起始行相同。

上述這些應該已經十分夠用了，尤其在與新的 :autocmd 命令協同使用時，可以為不同文
件型別提供不同的設定。

一些例子:
  適用於 C 程式碼 (只對註釋排版): >
	:set fo=croq
< 適用於郵件/新聞 (排版所有文字，"o" 命令不開始註釋): >
	:set fo=tcrq
<

自動排版					*auto-format* *autoformat*

如果 'formatoptions' 裡包含 'a' 標誌位，在插入或者刪除文字時會自動進行排版。這
對編輯文字段落很好用。以下對如何使用這一功能提供一些提示:

- 你需要正確定義何謂段落。最簡單的方式是以空行分隔的為段落。如果沒有分隔的空
  行，考慮用 'w' 標誌位並在段落中除了最後一行以外，每行結尾加上一個空格。

- 你可以根據檔案型別 |filetype|， 或者用 |modeline| 指定特定檔案的方式，設定不
  同的 'formatoptions'。

- 將 'formatoptions' 設為 "aw2tq" 使得文字以如下方式縮排:

	    bla bla foobar bla 
	bla foobar bla foobar bla
	    bla bla foobar bla 
	bla foobar bla bla foobar

- 如果只想自動排版註釋，加上 'c' 標誌位。可用於原始碼。

- 設定 'textwidth' 為你希望的寬度。如果為零，使用 79 或螢幕寬度中較小的那個。

還有一些警告:

- 如果段落沒有正確分隔，任何改變都會使得所有相連的文字自動排版。考慮 >

	:set fo-=a

- 如果用 'w' 標誌位 (行尾的空格意味著段落的繼續) 並且用 |dd| 刪除了段落的末
  行，這段落自動和下一個段落合併為一個段落。

- 改變的文字被儲存以備可能的撤銷之用。排版也是改變的一種。所以每次排版都會為撤
  銷儲存文字。這會有相當的記憶體開銷。

- 排版一個很長的段落和/或複雜的縮排也許會相當慢。

==============================================================================
7. 文字排序						*sorting*

Vim 有排序函式和排序命令。排序函式可見: |sort()|，|uniq()|。

							*:sor* *:sort*
:[range]sor[t][!] [b][f][i][n][o][r][u][x] [/{pattern}/]
			給 [range] 裡的行排序。如果沒有給出行範圍，給所有行排
			序。

			帶 [!] 則反向排序。

			帶 [i] 則忽略大小寫。

			選項 [n][f][x][o][b] 互斥。

			帶 [n] 則排序基於每行的第一個十進位制數 (在 {pattern} 匹
			配之後或之內)。
			數值包含前導的 '-'。

			帶 [f] 則排序基於每行內的浮點數。浮點值相當於在文字
			({pattern} 匹配的之後或之內) 上呼叫 str2float() 函式的
			結果。僅當 Vim 編譯時加入浮點數支援時該標誌位才有效。

			帶 [x] 則排序基於每行的第一個十六進位制數 (在 {pattern}
			匹配之後或之內)。忽略引導的 "0x" 或 "0X"。
			數值包含前導的 '-'。

			帶 [o] 則排序基於每行的第一個八進位制數 (在 {pattern} 匹
			配之後或之內)。

			帶 [b] 則排序基於每行的第一個二進位制數 (在 {pattern} 匹
			配之後或之內)。

			帶 [u] (u 代表 unique 唯一) 則只保留完全相同的行的第一
			行 (如果帶 [i]，忽略大小寫的區別)。
			沒有這個標誌位，完全相同的行的序列會按照它們原來的順序
			被保留下來。
			注意 引導和拖尾的空白差異會導致不相同的行。

			如果指定 /{pattern}/ 並且沒有 [r] 標誌位，跳過匹配
			{pattern} 的文字，使得排序在匹配之後的內容上進行。
			除了斜槓以外，任何非字母的字元都可以。
			例如，要按第二個逗號分隔的欄位排序: >
				:sort /[^,]*,/
<			按虛擬第 10 列的文字排序 (從而忽略製表和空格的區別): >
				:sort /.*\%10v/
<			按每行的第一個數值排序，不管它前面有什麼: >
				:sort /.\{-}\ze\d/
<			(說明: ".\{-}" 匹配任何文字，"\ze" 設定匹配結束位置，
			\d 匹配單個數位。)
			帶 [r] 則排序在匹配 {pattern} 的文字上進行，而不是如上
			所述的用它之後的文字。
			例如，要按每行的前三個字母排序且只看這三個字母: >
				:sort /\a\a\a/ r

<			如果使用 {pattern}，不匹配 {pattern} 的行按照它們原來
			的順序被保留，但和匹配 {pattern} 的行分開。如果反向排
			序，它們會以反向順序出現，並在排序好的行之後。否則它們
			會以原有順序出現，在排序好的行之前。

			如果 {pattern} 為空 (例如指定 //)，則使用最近使用的搜
			索模式。這樣你可以先試好模式，然後在執行。

注意 `:sort` 和 `:global` 一起使用並不能對匹配的行進行排序，這樣做沒有意義。

排序的細節取決於使用的庫函式。不能保證排序依賴於當前的 locale。你要自己試試才
知道。Vim 保證 "穩定" 排序。

排序可以被中斷，但在整個過程裡如果中斷得太晚，最後可能會出現重複的行。這取決於
使用的系統庫函式。

 vim:tw=78:ts=8:ft=help:norl:
