*if_perl.txt*   For Vim version 8.0.  最近更新: 2017年7月


		  VIM 參考手冊    by Sven Verdoolaege
					 and Matt Gerassimof
			    譯者: foolstone@ustc.edu，Willis，tocer
			    http://vimcdoc.sf.net


Perl 與 Vim						*perl* *Perl*

1. 編輯 Perl 文件		|perl-editing|
2. 編譯帶 Perl 介面的 Vim	|perl-compiling|
3. Perl 介面的使用		|perl-using|
4. 動態調入			|perl-dynamic|

{Vi 沒有上述這些功能}
Perl 介面只有在編譯 Vim 時加入 |+perl| 才能使用。

==============================================================================
1. 編輯 Perl 檔案					*perl-editing*

Vim 語法高亮顯示支援 Perl 和 POD 檔案。Vim 假設字尾為 .pl 和 .pm 的檔案是 Perl
檔案。Vim 同時不管檔案字尾而測試檔案的首行來檢查一個檔案是否為 Perl 指令碼 (參見
Vim 的 syntax 目錄下的 scripts.vim)。Vim 假設帶字尾 .POD 的檔案是 POD 文字。

要使用 Perl 標籤，你需要 Exuberant ctags 的最新版本。在這裡可以找到它:
	http://ctags.sourceforge.net

當然，作為選擇你還可以用一個叫 pltags.pl 的 Perl 指令碼，它和 Vim 一起發行的，位
於 $VIMRUNTIME/tools 目錄下。這個指令碼比 Exuberant ctags 的 Perl 支援具備更多的
功能。

==============================================================================
2. 編譯帶 Perl 介面的 Vim				*perl-compiling*

為了編譯帶 Perl 介面的 Vim，需要 Perl 5.004 (或者更新) 的版本。Perl 必須在你編
譯 Vim 前安裝。 Vim 的 Perl 介面_不能_和官方發行的 Perl 5.003 一起正常工作！它
也許能和 Perl 5.003_05 或者更新版本一起正常工作。
_[譯者注]到翻譯的時候，這個問題已經不會是大問題了_

Vim 的 Perl 補丁由
	Sven Verdoolaege<skimo@breughel.ufsia.ac.be> 和
	Matt Gerassimof
製作。

Perl 的 MS-Windows 版本可以在下面這個網址找到: http://www.perl.com/
ActiveState 的版本應該可用。

==============================================================================
3. Perl 介面的使用					*perl-using*

							*:perl* *:pe*
:pe[rl] {cmd}		執行 Perl 命令 {cmd}。當前包是 "main"。測試 `:perl` 是
			否可用的簡單例子: >
				:perl VIM::Msg("Hello")

:pe[rl] << {endpattern}
{script}
{endpattern}
			執行 Perl 指令碼 {script}。
			{endpattern} _不能_有任何前導空格。如果忽略了
			{endpattern}，就會像 |:append| 和 |:insert| 命令那樣，
			預設為點 '.'。在函式內使用時，最好指明 '.'，因為 "$i;"
			看起來像 Vim 的 |:insert| 命令的開始。
			|:perl| 命令的這種形式主要是用來在 vim 腳本里麵包含
			perl 程式碼。
			備註: 當 Perl 特性沒有被編譯進 vim 時這條命令不能工
			作。為了避免出錯，請參考 |script-here|。
vim 指令碼示例: >

	function! WhitePearl()
	perl << EOF
		VIM::Msg("pearls are nice for necklaces");
		VIM::Msg("rubys for rings");
		VIM::Msg("pythons for bags");
		VIM::Msg("tcls????");
	EOF
	endfunction
<
要看執行的 Perl 的版本: >
	:perl print $^V
<

							*:perldo* *:perld*
:[range]perld[o] {cmd}  對 [range] 中的每行執行 Perl 命令 {cmd}，同時 $_ 依次
			被賦值為每行的文字，但不包括行尾的 <EOL>。改變 $_ 會改
			變每行的內容，但注意不能用這個命令新增或者刪除行。
			[range] 的預設值是整個檔案: "1，$"。

可以試一下下面的程式碼: >

  :perl $a=1
  :perldo $_ = reverse($_);1
  :perl VIM::Msg("hello")
  :perl $line = $curbuf->Get(42)
<

							*E299*
在沙盤 |sandbox| 裡執行 Perl 命令是受限制的。":perldo" 根本就不能執行。如果可
能，":perl" 會在安全環境下被執行。

							*perl-overview*
下面是在 Perl 下可用的函式概要: >

  :perl VIM::Msg("Text")		# 顯示資訊
  :perl VIM::Msg("Error", "ErrorMsg")	# 顯示錯誤資訊
  :perl VIM::Msg("remark", "Comment")	# 顯示高亮的資訊
  :perl VIM::SetOption("ai")		# 設定一個 vim 選項
  :perl $nbuf = VIM::Buffers()		# 返回緩衝區的個數
  :perl @buflist = VIM::Buffers()	# 返回所有緩衝區的陣列
  :perl $mybuf = (VIM::Buffers('qq.c'))[0] # 返回一個 'qq.c' 的緩衝區物件
  :perl @winlist = VIM::Windows()	# 返回所有視窗的陣列
  :perl $nwin = VIM::Windows()		# 返回視窗的個數
  :perl ($success, $v) = VIM::Eval('&path') # $v: 'path' 選項值，$success: 1
  :perl ($success, $v) = VIM::Eval('&xyz')  # $v: '' 而 $success: 0
  :perl $v = VIM::Eval('expand("<cfile>")') # 展開檔案 <cfile>
  :perl $curwin->SetHeight(10)		# 設定視窗高度
  :perl @pos = $curwin->Cursor()	# 返回座標 (row，col) 陣列
  :perl @pos = (10, 10)
  :perl $curwin->Cursor(@pos)		# 把游標位置設為 @pos
  :perl $curwin->Cursor(10,10)		# 把游標位置設為第 10 行第 10 列
  :perl $mybuf = $curwin->Buffer()	# 返回視窗的緩衝區物件
  :perl $curbuf->Name()			# 返回緩衝區名字
  :perl $curbuf->Number()		# 返回緩衝區編號
  :perl $curbuf->Count()		# 返回行數
  :perl $l = $curbuf->Get(10)		# 返回第 10 行
  :perl @l = $curbuf->Get(1 .. 5)	# 返回第 1 到第 5 行
  :perl $curbuf->Delete(10)		# 刪除第 10 行
  :perl $curbuf->Delete(10, 20)		# 刪除第 10－20 行
  :perl $curbuf->Append(10, "Line")	# 新增一行
  :perl $curbuf->Append(10, "Line1", "Line2", "Line3") # 新增三行
  :perl @l = ("L1", "L2", "L3")
  :perl $curbuf->Append(10, @l)		# 新增 L1，L2 和 L3
  :perl $curbuf->Set(10, "Line")	# 替換第 10 行
  :perl $curbuf->Set(10, "Line1", "Line2")      # 替換第 10 行和第 11 行
  :perl $curbuf->Set(10, @l)		# 分別用 L1，L2 和 L3 替換 10－12 行
<
							*perl-Msg*
VIM::Msg({msg}, {group}?)
			顯示訊息 {msg}。可選 {group} 引數指定用來顯示這個訊息
			的高亮方式。

							*perl-SetOption*
VIM::SetOption({arg})
			設定一個 vim 選項。{arg} 可以是任何 ":set" 命令能接受
			的引數。這就意味著引數裡面不允許有空格！見 |:set|。

							*perl-Buffers*
VIM::Buffers([{bn}...]) 沒有引數的時候，在陣列上下文裡面返回所有緩衝區的列表，
			在標量上下文裡返回緩衝區的個數。對於一個緩衝區名字或者
			編號的列表 {bn}，返回匹配 {bn} 的緩衝區列表，與 Vim 內
			部函式 |bufname()| 使用同樣的規則。
			警告: 使用 |:bwipe| 後，該列表就不合法了。如果要強行使
			用會使 Vim 崩潰。

							*perl-Windows*
VIM::Windows([{wn}...]) 沒有引數的時候，在陣列上下文裡面返回所有視窗的列表，在
			標量上下文裡返回視窗的個數。對於一個視窗編號的列表
			{wn}，返回匹配 {wn} 的視窗列表。
			警告: 視窗關閉後，該列表就不合法了。如果要強行使用會使
			Vim 崩潰。

							*perl-DoCommand*
VIM::DoCommand({cmd})   執行 Ex 命令 {cmd}。

							*perl-Eval*
VIM::Eval({expr})       對 {expr} 求值並在列表上下文返回 (success，value)，在
			標量上下文則只返回 value。
			success=1 表示 val 包含 {expr} 的值。success=0 表示表
			達式求值失敗。 '@x' 返回暫存器 x 的內容， '&x' 返回選
			項 x 的值，'x' 返回內部變數 x 的值，'$x' 等價於 perl
			中的 $ENV{x}。所有在命令列可以訪問的函式都可用於
			{expr}。
			列表 |List| 通過連線專案並在專案間插入換行符來轉化為字
			符串。

							*perl-SetHeight*
Window->SetHeight({height})
			把視窗的高度設定為 {height}，不超過螢幕範圍。

							*perl-GetCursor*
Window->Cursor({row}?, {col}?)
			在沒有引數的情況下，返回視窗游標所處位置的座標 (row，
			col) 陣列。當有引數 {row} 和 {col} 的情況下，把視窗光
			標的位置設為 {row} 和 {col}。注意 {col} 是按 Perl 風格
			從0 數起的，比 Vim 的尺度小 1。

Window->Buffer()					*perl-Buffer*
			返回給定視窗的緩衝區物件。

							*perl-Name*
Buffer->Name()		返回緩衝區的檔名。

							*perl-Number*
Buffer->Number()	返回緩衝區的編號。

							*perl-Count*
Buffer->Count()		返回緩衝區中的行數。

							*perl-Get*
Buffer->Get({lnum}, {lnum}?, ...)
			對每個指定的 {lnum}，返回緩衝區中第 {lnum} 行的文字字
			符串。通過指定一個 {lnum} 列表可以傳遞一個數組。

							*perl-Delete*
Buffer->Delete({lnum}, {lnum}?)
			刪除緩衝區的第 {lnum} 行。當有第二個引數 {lnum} 時，刪
			除由第一個 {lnum} 到第二個 {lnum} 指定的範圍。

							*perl-Append*
Buffer->Append({lnum}, {line}, {line}?, ...)
			把每個 {line} 字串新增到緩衝區的第 {lnum} 行後面。
			{line} 列表可以是一個數組。

							*perl-Set*
Buffer->Set({lnum}, {line}, {line}?, ...)
			替代緩衝區從第 {lnum} 行開始，由 {line} 指定的一行或者
			多行。 {line} 列表可以是一個數組。如果引數無效，就不作
			替代。
$main::curwin
			當前視窗物件。
$main::curbuf
			當前緩衝區物件。

							*script-here*
當使用嵌入式指令碼語言時，你可能想在語言不支援時跳過這些語言的程式碼。但是以下機制
不能工作: >
   if has('perl')
     perl << EOF
       this will NOT work!
   EOF
   endif
相反，應把 Perl / Python / Ruby 等的命令放在一個函式裡面並呼叫它: >
    if has('perl')
      function DefPerl()
	perl << EOF
	  this works
    EOF
      endfunction
      call DefPerl()
    endif
備註: "EOF" 必須在行首 (前面不能有前導空格)。

==============================================================================
4. 動態調入						*perl-dynamic*

MS-Windows 和 Unix 上，可以動態調入 Perl 庫。|:version| 輸出這時應包括
|+perl/dyn|。

這意味著 Vim 只有在必要時才尋找 Perl DLL 或共享庫檔案。如果不使用 Perl 介面，
你就不需要它。這樣，即使沒有該檔案，你也可使用 Vim。


MS-Windows ~

你可以從 http://www.perl.org 下載 Perl。用於編譯 Vim 的是 ActiveState 提供的版
本。

要使用 Perl 介面，Perl DLL 必須在搜尋路徑上。
如果 Vim 報告找不到 perl512.dll，確保 $PATH 包含該檔案所在的路徑。Perl 安裝程
序通常會做好這一點。
控制檯窗口裡輸入 "path" 可以看到 (搜尋路徑) 當前使用的目錄。也可以用 'perldll'
選項指定 Perl DLL。

DLL 名必須匹配 Vim 編譯時所使用的 Perl 版本。目前，該名字為 "perl512.dll"，也
就是 Perl 5.12。要確信這一點，編輯 "gvim.exe" 檔案並查詢 "perl\d*.dll\c"。


Unix ~

'perldll' 選項可用來指定 Perl 共享庫檔案，而不用編譯時指定的 DYNAMIC_PERL_DLL
檔案。共享庫的版本必須和 Vim 編譯使用的 Perl 版本保持一致。

==============================================================================
 vim:tw=78:ts=8:ft=help:norl:
