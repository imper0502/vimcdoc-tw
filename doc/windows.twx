*windows.txt*	For Vim version 8.0.  最近更新: 2017年8月


		  VIM 參考手冊    by Bram Moolenaar
				      譯者: Dasn
				      http://vimcdoc.sf.net


使用多個視窗和緩衝區進行編輯				*windows* *buffers*

本章我們看一下操作多個視窗和緩衝區的命令。另外有些命令在操作多個視窗的時候不同
於單個視窗，這些命令也會在本章被介紹。

一些基本的內容在使用者手冊的第 7、8 兩個章節裡 |usr_07.txt| |usr_08.txt| 已經介
紹過了。

1.  簡介					|windows-intro|
2.  啟動 Vim					|windows-starting|
3.  開啟和關閉視窗				|opening-window|
4.  把游標移動到另一個視窗			|window-move-cursor|
5.  移動視窗					|window-moving|
6.  改變視窗大小				|window-resize|
7.  引數和緩衝區列表的命令			|buffer-list|
8.  在所有的緩衝區和窗口裡執行命令		|list-repeat|
9.  當前游標處的標籤和檔名			|window-tag|
10. 預覽視窗					|preview-window|
11. 使用隱藏緩衝區				|buffer-hidden|
12. 特殊型別緩衝區				|special-buffers|

{Vi 沒有這些命令}
{僅當編譯時加入 |+windows| 特性才能使用多視窗功能}
{僅當編譯時加入 |+vertsplit| 特性才能使用垂直分割視窗功能}

==============================================================================
1. 簡介						*windows-intro* *window*

小結:
   緩衝區是記憶體中的檔案文字。
   視窗是緩衝區的視窗。
   標籤頁是視窗的集合。

"視窗" 被用來檢視緩衝區裡的內容。你可以用多個視窗觀察同一個緩衝區，也可以用多
個視窗觀察不同的緩衝區。

"緩衝區" 是一塊記憶體區域，裡面儲存著正在編輯的檔案。如果沒有把緩衝區裡的檔案存
盤，那麼原始檔案不會被更改。

緩衝區的狀態可以是下述三種情況之一:

							*active-buffer*
啟用: 	  緩衝區的內容在窗口裡顯示。如果該緩衝區是針對某一個檔案建立的，那麼該
	  檔案已經被讀入緩衝區。如果緩衝區被更改過，其內容便會與原檔案不同。
							*hidden-buffer*
隱藏: 	  緩衝區的內容不被顯示。如果該緩衝區是針對某一個檔案建立的，那麼該檔案
	  已經被讀入緩衝區。除此以外，與啟用狀態一樣，只是你看不見它。
							*inactive-buffer*
非啟用:   緩衝區的內容不被顯示，也不包含任何資料。如果曾經載入過檔案，與該緩衝
	  區相關的選項會被記住。它可以包括來自 |viminfo| 檔案的位置標記，但是
	  這種緩衝區不包含文字。

用一個表來說明:

狀態		在視窗顯示	檔案載入	":buffers" 命令顯示 ~
啟用		    是		   是		  'a'
隱藏		    否		   是		  'h'
非啟用		    否		   否		  ' '

備註: 所有的 CTRL-W 命令都可以用 |:wincmd| 執行，當我們不能輸入普通模式命令，
或者輸入不方便時可以試一下。

主 Vim 視窗可以容納多個分割的視窗。此外還有標籤頁 |tab-page|，每個標籤頁能容納
多個視窗。
					*window-ID* *winid* *windowid*
每個視窗有唯一的識別符號，稱為視窗 ID。此識別符號在同一 Vim 會話中不會改變。
|win_getid()| 和 |win_id2tabwin()| 函式可用於在視窗/標籤頁號和此識別符號間轉換。
同時也有視窗號，它在每次視窗開啟或關閉時會改變，見 |winnr()|。

每個緩衝區有唯一的編號而在同一 Vim 會話中此編號不會改變。|bufnr()| 和
|bufname()| 函式可用於在緩衝區名和緩衝區號間轉換。

==============================================================================
2. 啟動 Vim						*windows-starting*

在預設情況下，與 Vi 類似，Vim 啟動後只打開一個視窗。

引數 "-o" 和 "-O" 可以讓 Vim 為引數列表裡的每一個檔案開啟一個視窗。引數 "-o"
水平分割視窗；引數 "-O" 垂直分割視窗。如果 "-o" 和 "-O" 都用了，那麼最後一個參
數決定分割的方向。例如，下面的例子開啟三個水平分割的視窗: >
	vim -o file1 file2 file3

引數 "-oN"，這裡的 N 是一個十進位制數，用這個引數可以開啟 N 個水平分割的視窗。
如果檔名的個數多於視窗數目，則只打開 N 個視窗，這樣有一些檔案就得不到視窗來
顯示。如果指定的視窗數多於檔案的個數，那麼後面的幾個視窗會編輯空的緩衝區。同
樣， "-ON"  開啟 N 個垂直分割的視窗，相應的規則與 "-oN" 相同。

如果你打開了很多的檔案，每個視窗都會便得很小。你可能需要設定 'winheight' 和
'winwidth' 選項來建立一個適合工作的環境。

Buf/Win Enter/Leave 等自動命令 |autocommand| 不會在開啟視窗或讀取檔案時執行，
只有在真正進入緩衝區後才會執行。

							*status-line*
狀態行用來分割視窗。選項 'laststatus' 用來設定最後一個視窗在什麼時候可以有狀態
欄:
	'laststatus' = 0	永遠不會有狀態行
	'laststatus' = 1	視窗數多於一個的時候
	'laststatus' = 2	總是顯示狀態行

你可以通過設定 'statusline' 選項來改變狀態行的內容。此選項可以區域性於視窗，所以
你可以為每個視窗設定不同的狀態行。

通常狀態行用反色顯示。你可以通過修改 'highlight' 選項中的 's' 字元來改變。例
如，"sb" 設定為粗體字。如果狀態行沒有啟用高亮 ("sn")，那麼字元 '^' 表示當前窗
口，字元 '=' 表示其它視窗。如果支援滑鼠並且已經通過設定 'mouse' 選項使之啟動，
那麼你可以用滑鼠拖動狀態行以改變視窗的大小。

備註: 如果你想讓狀態行以反色顯示，但是沒有效果。檢視一下 'highlight' 選項是否
包含了 "si"。在 3.0 版本里，這意味著逆轉 (invert) 狀態行。但是現在應該使用
"sr"，反轉 (reverse) 狀態行，因為 "si" 現在表示斜體 (italic)！如果你的終端不支
持斜體，那麼狀態行還是會以反色顯示；這種問題只會出現在有斜體的 termcap 碼的終
端上。

==============================================================================
3. 開啟和關閉視窗					*opening-window* *E36*

CTRL-W s						*CTRL-W_s*
CTRL-W S						*CTRL-W_S*
CTRL-W CTRL-S						*CTRL-W_CTRL-S*
:[N]sp[lit] [++opt] [+cmd] [file]			*:sp* *:split*
		把當前視窗分割成兩個，結果是兩個視窗顯示同一個檔案。

		新開啟的視窗高度為 N (預設值是當前視窗高度的一半)。減少當前窗
		口的高度，空出地方給新的視窗 (如果你置位了 'equalalways' 選項
		，並且 'eadirection' 沒有設定為 "hor"，並且其它視窗中的一個高
		於當前或新視窗的話，其它視窗也被影響)。

		如果給出 [file]，在新視窗中編輯該檔案。如果還未在任何緩衝區中
		載入，先讀入該檔案。否則新視窗會使用已載入的緩衝區。

		備註: 不是在所有的終端都能使用 CTRL-S，並且可能導致不能繼續輸
		入，遇到這種情況，用 CTRL-Q 繼續。參見 |++opt| 和 |+cmd|。

CTRL-W CTRL-V						*CTRL-W_CTRL-V*
CTRL-W v						*CTRL-W_v*
:[N]vs[plit] [++opt] [+cmd] [file]			*:vs* *:vsplit*
		與 |:split| 類似，但垂直分割視窗。滿足以下條件的話，視窗會被均
		勻地水平鋪開:
		1. 沒有指定寬度，
		2. 打開了 'equalalways' 選項，
		3. 'eadirection' 不是 "ver"，且
		4. 其它視窗中的一個寬於當前或新視窗。
		備註: 在其它地方 CTRL-Q 與 CTRL-V 相同，但是在這裡不是！

CTRL-W n						*CTRL-W_n*
CTRL-W CTRL_N						*CTRL-W_CTRL-N*
:[N]new [++opt] [+cmd]					*:new*
		建立一個新視窗並且開始編輯一個空檔案。新視窗的高度為 N (預設值
		為現存高度的一半)。減少當前視窗的高度，為新視窗留出空間 (如果
		你打開了 'equalalways' 選項，並且 'eadirection' 沒有設定為
		"hor"，其它視窗也會被影響)。
		參見: |++opt| and |+cmd|。
		如果設定了 'fileformats' 選項，那麼新緩衝區會使用其中的第一個
		格式。如果 'fileformats' 為空，那麼使用當前緩衝區的
		'fileformat' 值。這個值可以被 |++opt| 引數覆蓋。
		自動命令以如下順序被執行:
		1. 在當前視窗執行 WinLeave
		2. 在新窗口裡執行 WinEnter
		3. 在當前緩衝區執行 BufLeave
		4. 在新緩衝區執行 BufEnter
		這跟先執行 ":split"，再執行一個 ":enew" 命令的效果差不多。

:[N]vne[w] [++opt] [+cmd] [file]			*:vne* *:vnew*
		與 |:new| 命令相似，但是它垂直分割視窗，如果打開了
		'equalalways' 選項，並且選項 'eadirection' 沒有設定為 "ver"，
		視窗會被均勻地水平鋪開，除非你給出了指定視窗寬度的引數。

:[N]new [++opt] [+cmd] {file}
:[N]sp[lit] [++opt] [+cmd] {file}			*:split_f*
		建立一個新的視窗，並且開始編輯檔案 {file}。這跟先執行
		":split"，再執行一個 ":e" 命令的效果差不多。
		如果使用了 [+cmd] 引數，檔案載入完畢後會執行命令 |+cmd|。
		也參見: |++opt|。
		新視窗的高度為 N (預設值為現存高度的一半)。減少當前視窗的高
		度，為新視窗留出空間 (如果你打開了 'equalalways' 選項，其它窗
		口也會被影響)。

:[N]sv[iew] [++opt] [+cmd] {file}		*:sv* *:sview* *splitview*
		與 ":split" 命令相同，但是會給緩衝區置位 'readonly' 選項。

:[N]sf[ind] [++opt] [+cmd] {file}		*:sf* *:sfind* *splitfind*
		與 ":split" 命令相同，但是會在 'path' 裡尋找 {file}，就像
		|:find| 那樣。如果找不到，就不會分割視窗。

CTRL-W CTRL-^					*CTRL-W_CTRL-^* *CTRL-W_^*
CTRL-W ^	執行 ":split #" 命令，把視窗分成兩個，並且編輯輪換檔案。如果指
		定了計數，就變成了 ":split #N"，分割視窗，並且編輯第 N 個緩衝
		區。

注意 'splitbelow' 和 'splitright' 選項會影響新視窗的位置。

						*:vert* *:vertical*
:vert[ical] {cmd}
		執行 {cmd}。如果包含一個分割視窗的命令，那麼將垂直分割視窗。
		不能用於 |:execute| 和 |:normal|。

:lefta[bove] {cmd}				*:lefta* *:leftabove*
:abo[veleft] {cmd}				*:abo* *:aboveleft*
		執行 {cmd}。如果包含一個分割視窗的命令，那麼將從當前視窗的左
		(垂直分割) 或者上方 (水平分割) 分割視窗，而忽略 'splitbelow'
		和 'splitright' 的設定。
		不能用於 |:execute| 和 |:normal|。

:rightb[elow] {cmd}				*:rightb* *:rightbelow*
:bel[owright] {cmd}				*:bel* *:belowright*
		執行 {cmd}。如果包含一個分割視窗的命令，那麼將從當前視窗的右
		(垂直分割) 或者下方 (水平分割) 分割視窗，而忽略 'splitbelow'
		和 'splitright' 的設定。
		不能用於 |:execute| 和 |:normal|。

						*:topleft* *E442*
:to[pleft] {cmd}
		執行 {cmd}。如果包含一個分割視窗的命令，那麼該窗口出現在頂部，
		並且佔據最大寬度。當垂直分割視窗時，窗口出現在最左邊，並且佔據
		最大高度。
		不能用於 |:execute| 和 |:normal|。

						*:bo* *:botright*
:bo[tright] {cmd}
		執行 {cmd}。如果包含一個分割視窗的命令，那麼該窗口出現在底部，
		並且佔據最大寬度。當垂直分割視窗時，窗口出現在最右邊，並且佔據
		最大高度。
		不能用於 |:execute| 和 |:normal|。

這些修飾符可以結合使用來開啟一個垂直分割的並且佔據最大高度的視窗: >
	:vertical topleft split tags
在 Vim 視窗最左邊開啟一個垂直分割的、最大高度的視窗，用來編輯 tags 檔案。


關閉視窗
----------------

:q[uit]
:{count}q[uit]
CTRL-W q						*CTRL-W_q*
CTRL-W CTRL-Q						*CTRL-W_CTRL-Q*
		沒有 {count}: 退出當前視窗。如果給出 {count}，退出第 {count}
		個視窗。

		如果退出的是最後一個視窗 (不包括幫助視窗)，就會退出 Vim。

		如果置位了 'hidden' 並且只有此一個視窗監視當前緩衝區，那麼該緩
		衝區被隱藏。如果沒有置位 'hidden'，並且只有當前這一個視窗監視
		該緩衝區，而且緩衝區被修改了，那麼該命令失敗。

		(注意: CTRL-Q 不是在所有的終端下都好用)。

		如果 [count] 大於最後一個視窗號，關閉最後一個視窗: >
		    :1quit  " 退出第一個視窗
		    :$quit  " 退出最後一個視窗
		    :9quit  " 如果開啟少於 9 個視窗，退出最後一個視窗
		    :-quit  " 退出上一個視窗
		    :+quit  " 退出下一個視窗
		    :+2quit " 退出下面第二個視窗
<
:q[uit]!
:{count}q[uit]!
		沒有 {count}: 退出當前視窗。如果給出 {count}，退出第 {count}
		個視窗。

		如果這是緩衝區的最後一個視窗，那麼對於此緩衝區的改動將全部丟
		失。如果退出的是最後一個視窗 (不包括幫助視窗)，就會退出 Vim。
		緩衝區裡的全部內容將丟失。即使置位了 'hidden' 選項也是如此。

:clo[se][!]
:{count}clo[se][!]
CTRL-W c					*CTRL-W_c* *:clo* *:close*
		沒有 {count}: 退出當前視窗。如果給出 {count}，退出第 {count}
		個視窗。

		如果置位了 'hidden'，或者改動了緩衝區但是命令裡用了 [!]，緩衝
		區會被隱藏 (除非還有一個視窗在編輯該緩衝區)。

		如果當前標籤頁只有一個視窗而且有其它標籤頁，關閉當前標籤頁。
		|tab-page|。

		該命令在下述情況下會失敗: 			*E444*
		- 螢幕上只剩下最後一個視窗的時候。
		- 當 'hidden' 沒有置位，也沒有用 [!]，並且緩衝區也已經被修改，
		  而且也沒有其它視窗監視該緩衝區的時候。
		對緩衝區的改動既不寫入檔案，也不會丟失，所以這是個 "安全" 的命
		令。

CTRL-W CTRL-C						*CTRL-W_CTRL-C*
		你可能會認為 CTRL-W CTRL-C 關閉當前視窗，但是這不行，因為
		CTRL-C 會撤消整個命令。

							*:hide*
:hid[e]
:{count}hid[e]
		除非是螢幕上的最後一個視窗，退出當前視窗，關於 {count} 可見
		|:quit| 命令。

		緩衝區被隱藏起來 (除非還有另一個視窗正在編輯它，或者
		'bufhidden' 設定為 "unload"、"delete" 或 "wipe")。
		如果這是當前標籤頁的最後一個視窗，關閉此標籤頁。|tab-page|

		此命令不受 'hidden' 的值影響。對緩衝區的改動既不寫入檔案，也不
		會丟失，所以這是個 "安全" 的命令。

:hid[e] {cmd}	執行 {cmd}，其間置位 'hidden' 選項。{cmd} 執行完畢後，先前的
		'hidden' 選項會被恢復。
		例如: >
		    :hide edit Makefile
<		編輯 "Makefile" 檔案，如果當前緩衝區有改動的話，隱藏之。

:on[ly][!]
:{count}on[ly][!]
CTRL-W o						*CTRL-W_o* *E445*
CTRL-W CTRL-O					*CTRL-W_CTRL-O* *:on* *:only*
		使當前視窗成為螢幕上唯一的視窗。其它視窗都關閉。關於 {count}
		可見 |:quit| 命令。

		如果置位了 'hidden' 選項，被關閉窗口裡的所有緩衝區變成隱藏。

		如果沒有置位 'hidden'，但是置位了 'autowrite' 選項，那麼已經更
		改的緩衝區被寫入檔案。否則，除非使用 [!] 強制關閉，那些包含修
		改過的緩衝區的視窗不被刪除，它們轉入隱藏狀態。因為修改過的緩衝
		區永遠不會被放棄，緩衝區的改動也永遠不會丟失。

==============================================================================
4. 把游標移動到另一個視窗			*window-move-cursor*

CTRL-W <Down>					*CTRL-W_<Down>*
CTRL-W CTRL-J					*CTRL-W_CTRL-J* *CTRL-W_j*
CTRL-W j	把游標向下移動 N 個視窗。用游標的位置在若干視窗之間做出選擇。

CTRL-W <Up>					*CTRL-W_<Up>*
CTRL-W CTRL-K					*CTRL-W_CTRL-K* *CTRL-W_k*
CTRL-W k	把游標向上移動 N 個視窗。用游標的位置在若干視窗之間做出選擇。

CTRL-W <Left>					*CTRL-W_<Left>*
CTRL-W CTRL-H					*CTRL-W_CTRL-H*
CTRL-W <BS>					*CTRL-W_<BS>* *CTRL-W_h*
CTRL-W h	把游標向左移動 N 個視窗。用游標的位置在若干視窗之間做出選擇。

CTRL-W <Right>					*CTRL-W_<Right>*
CTRL-W CTRL-L					*CTRL-W_CTRL-L* *CTRL-W_l*
CTRL-W l	把游標向右移動 N 個視窗。用游標的位置在若干視窗之間做出選擇。

CTRL-W w					*CTRL-W_w* *CTRL-W_CTRL-W*
CTRL-W CTRL-W	如果沒有新增計數，則將游標移動到當前視窗的右/下方的視窗。如果
		右/下方沒有視窗，就移動到左上角的視窗。
		要是添加了計數，就移動到第 N 個視窗 (從左上方到右下方依次計
		數)。視窗號可以通過 |bufwinnr()| 和 |winnr()| 來獲得。如果 N
		大於視窗總數，跳到最後一個視窗。

						*CTRL-W_W*
CTRL-W W	如果沒有新增計數，則將游標移動到當前視窗的左/上方的視窗。如
		果左/上方沒有視窗，就移動到右下角的視窗。
		要是添加了計數，就移動到第 N 個視窗，類似於 CTRL-W w。

CTRL-W t					*CTRL-W_t* *CTRL-W_CTRL-T*
CTRL-W CTRL-T	把游標移動到左上角的視窗。

CTRL-W b					*CTRL-W_b* *CTRL-W_CTRL-B*
CTRL-W CTRL-B	把游標移動到右下角的視窗。

CTRL-W p					*CTRL-W_p* *CTRL-W_CTRL-P*
CTRL-W CTRL-P	移動到前一個 (previous) (上次訪問的) 視窗。

						*CTRL-W_P* *E441*
CTRL-W P	移動到預覽視窗。如果沒有預覽視窗就會出錯。
		{僅當編譯時加入 |+quickfix| 特性才有效}

在可視模式下，如果新視窗編輯的是同一個緩衝區，則設定游標位置使得相同的區域被選
擇。如果不是同一個緩衝區，則終止可視模式。

						*:winc* *:wincmd*
這些命令也可以用 ":wincmd" 來執行:

:[count]winc[md] {arg}
		與 CTRL-W [count] {arg} 相同。例如: >
			:wincmd j
<		把游標移動到當前視窗下面的視窗。
		這個命令在普通模式不可用的時候 (比如在 |CursorHold| 自動命令執
		行的時候)，或者在啟用普通模式不方便時，特別好用。
		計數也可以是一個視窗號。例如: >
			:exe nr . "wincmd w"
<		這會切換到視窗 "nr"。

==============================================================================
5. 移動視窗						*window-moving*

CTRL-W r				*CTRL-W_r* *CTRL-W_CTRL-R* *E443*
CTRL-W CTRL-R	向右/下方向旋轉視窗。第一個視窗變成第二個，第二個變成第三個……
		最後一個變成第一個。游標保留在相同窗口裡。
		本操作只在和當前視窗同行或同列的視窗間移動。

						*CTRL-W_R*
CTRL-W R	向左/上方向旋轉視窗。第二個視窗變成第一個，第三個變成第二個……
		第一個變成最後一個。游標保留在相同窗口裡。
		本操作只在和當前視窗同行或同列的視窗間移動。

CTRL-W x					*CTRL-W_x* *CTRL-W_CTRL-X*
CTRL-W CTRL-X	若沒有計數: 交換當前視窗與下一個視窗。如果沒有下一個視窗，則
		與前一個視窗交換。
		若有計數: 交換當前視窗與第 N 個視窗 (第一個視窗為 1)。游標被放
		置在那個窗口裡。
		如果既有垂直分割又有水平分割，那麼只能與當前視窗同行或者同列的
		視窗進行交換。

下面的幾個命令可以被用來改變視窗的佈局。例如，CTRL-W K 可以把兩個垂直分割的窗
口變成水平分割的視窗。CTRL-W H 則正好相反。

						*CTRL-W_K*
CTRL-W K	把當前視窗放到最頂端，並且是最大寬度。這很像在關閉當前視窗之
		後，再用 ":topleft split" 開啟一個新的視窗，不過新視窗會包含當
		前視窗的內容。

						*CTRL-W_J*
CTRL-W J	把當前視窗放到最底部，並且是最大寬度。這很像在關閉當前視窗之
		後，再用 ":botright split" 開啟一個新的視窗，不過新視窗會包含
		當前視窗的內容。

						*CTRL-W_H*
CTRL-W H	把當前視窗放到最左邊，並且是最大高度。這很像在關閉當前視窗之
		後，再用 ":vert topleft split" 開啟一個新的視窗，不過新視窗會
		包含當前視窗的內容。
		{僅當編譯時加入 |+vertsplit| 特性才有效}

						*CTRL-W_L*
CTRL-W L	把當前視窗放到最右邊，並且是最大高度。這很像在關閉當前視窗之
		後，再用 ":vert botright split" 開啟一個新的視窗，不過新視窗會
		包含當前視窗的內容。
		{僅當編譯時加入 |+vertsplit| 特性才有效}

						*CTRL-W_T*
CTRL-W T	把當前視窗移到一個新的標籤頁上。如果當前標籤頁只有一個視窗，此
		命令失敗。
		如果給出計數，開啟的新標籤頁會出現在該索引給出的標籤頁之前。否
		則，它出現在當前標籤頁之後。

==============================================================================
6. 改變視窗大小						*window-resize*

						*CTRL-W_=*
CTRL-W =	使得所有視窗 (幾乎) 等寬、等高，但當前視窗使用 'winheight' 和
		'winwidth'。
		置位 'winfixheight' 的視窗保持它們的高度，而置位 'winfixwidth'
		的視窗保持它們的寬度。

:res[ize] -N					*:res* *:resize* *CTRL-W_-*
CTRL-W -	使得當前視窗高度減 N (預設值是 1)。
		如果在 'vertical' 之後使用，則使得寬度減 N。

:res[ize] +N					*CTRL-W_+*
CTRL-W +	使得當前視窗高度加 N (預設值是 1)。
		如果在 'vertical' 之後使用，則使得寬度加 N。

:res[ize] [N]
CTRL-W CTRL-_					*CTRL-W_CTRL-_* *CTRL-W__*
CTRL-W _	設定當前視窗的高度為 N (預設值為最大可能高度)。

z{nr}<CR>	設定當前視窗的高度為 {nr}。

						*CTRL-W_<*
CTRL-W <	使得當前視窗寬度減 N (預設值是 1)。

						*CTRL-W_>*
CTRL-W >	使得當前視窗寬度加 N (預設值是 1)。

:vertical res[ize] [N]			*:vertical-resize* *CTRL-W_bar*
CTRL-W |	設定當前視窗的寬度為 N (預設值為最大可能寬度)。

你也可以用滑鼠上下拖動狀態行來改變視窗的高度，或者左右拖動垂直分割線來改變視窗
寬度。這些功能只有在支援滑鼠的版本里，並且設定了 'mouse' 選項才可以用。

選項 'winheight' ('wh') 用來設定當前視窗的最小高度。每當其它視窗變為當前視窗的
時候，這一選項就會生效。如果設定為 0，則禁用。把 'winheight' 設一個很大的值，
例如，'9999'，就使得當前視窗永遠佔據儘可能大的空間。儘量設定成一個編輯時比較舒
服的值，比如說，'10' 就是一個合理的值。

同樣，'winwidth' ('wiw') 選項設定了當前視窗的最小寬度。

如果置位了 'equalalways' ('ea') 選項，在分割或者關閉視窗之後，所有視窗都會變為
相同大小。如果你不置位這個選項，分割視窗時會減少當前視窗的大小，而其它視窗保持
不變。當關閉視窗時，多出來的行會被上面的窗口占用。

選項 'eadirection' 用來限制 'equalalways' 的作用方向。預設值是 "both"，兩個方
向都改變。當設定為 "ver" 時，只限制所有視窗的高度必須相同，這樣你可以自己調節
視窗的寬度。而垂直分割視窗的大小如果經過手工調整，其寬度也不會被破壞。同樣，
"hor" 使得視窗的寬度都相等。

選項 'cmdheight' ('ch') 用來設定命令列的高度。如果你對 |hit-enter| 的提示資訊
感到厭煩，可以將它設定為 2 或 3。

如果只有一個視窗，那麼改變該視窗大小的同時也會改變命令列的高度。如果有多個窗
口，那麼改變當前視窗的大小也會改變它下面的視窗 (有時是上面的視窗) 的高度。

一個視窗的最小高度和最小寬度可以用 'winminheight' 和 'winminwidth' 設定。這是
硬性值，一旦設定，視窗的高度 (或寬度) 將不能小於該值。

==============================================================================
7. 引數和緩衝區列表的命令				*buffer-list*

      引數列表		      緩衝區列表	   含義 ~
1. :[N]argument [N]	11. :[N]buffer [N]	切換至第 N 號引數/緩衝區
2. :[N]next [file ..]	12. :[N]bnext [N]	切換至向後第 N 個引數/緩衝區
3. :[N]Next [N]		13. :[N]bNext [N]	切換至向前第 N 個引數/緩衝區
4. :[N]previous	[N]	14. :[N]bprevious [N]	切換至向前第 N 個引數/緩衝區
5. :rewind / :first	15. :brewind / :bfirst	切換至第一個引數/緩衝區
6. :last		16. :blast		切換至最後一個引數/緩衝區
7. :all			17. :ball		編輯所有的引數/緩衝區
			18. :unhide		編輯所有已載入的緩衝區
			19. :[N]bmod [N]	切換至第 N 個已修改的緩衝區

  分割 & 引數列表	 分割 & 緩衝區列表	   含義 ~
21. :[N]sargument [N]   31. :[N]sbuffer [N]	分割並至第 N 號引數/緩衝區
22. :[N]snext [file ..] 32. :[N]sbnext [N]      分割並至向後第 N 個引數/緩衝區
23. :[N]sNext [N]       33. :[N]sbNext [N]      分割並至向前第 N 個引數/緩衝區
24. :[N]sprevious [N]   34. :[N]sbprevious [N]  分割並至向前第 N 個引數/緩衝區
25. :srewind / :sfirst	35. :sbrewind / :sbfirst 分割並至第一個引數/緩衝區
26. :slast		36. :sblast		分割並至最後一個引數/緩衝區
27. :sall		37: :sball		編輯所有的引數/緩衝區
			38. :sunhide		編輯所有已載入的緩衝區
			39. :[N]sbmod [N]	分割並至第 N 個已修改的緩衝區

40. :args		顯示引數列表
41. :buffers		顯示緩衝區列表

上述命令中的 [N] 的含義取決於你使用的命令:
 [N] 在命令 ?2、?3 和 ?4 中是向前/向後的緩衝區個數。
 [N] 在命令 1 和 21      中是引數號，預設值是當前引數。
 [N] 在命令 11 和 31     中是緩衝區號，預設值是當前緩衝區。
 [N] 在命令 19 和 39     中是計數。

備註: ":next" 是一個例外，因為它必須以檔名列表為引數，這是為了和 Vi 相容。


引數列表和多視窗
--------------------------------------

每一個視窗所編輯的檔案可能位於引數列表的不同位置。記住！用 ":e file" 編輯檔案
後，你在引數列表中的位置沒有變化，但你並不是在編輯處於那個位置的檔案。為了說明
這一點，檔案訊息 (和標題欄，如果有的話) 會顯示 "(file (N) of M)"，"(N)" 是當前
檔案在列表中的位置，"M" 是列表中檔案的數量。

所有引數列表中的條目都被載入到緩衝區列表中，這樣你也可以用緩衝區列表的命令進行
操作，比如 ":bnext"。

:[N]al[l][!] [N]				*:al* *:all* *:sal* *:sall*
:[N]sal[l][!] [N]
		重新整理螢幕，為每一個引數開啟一個視窗。其它視窗統統關閉。如果
		使用了計數，則其數值為視窗數目的最大值。
		如果帶 |:tab| 修飾符，為每個引數開啟一個標籤頁。如果引數數目多
		於 'tabpagemax'，多餘引數成為最後一個標籤頁的分割視窗。
		如果設定了 'hidden'，所有要關閉的視窗變為隱藏。
		如果沒有設定 'hidden'，但是設定了 'autowrite'，那麼所有改動
		的緩衝區被寫入檔案。否則，包含更改過的緩衝區的視窗不會被刪除，
		除非你用 [!] 使它們隱藏。更改過的緩衝區永遠不會被丟棄，所以改
		動不會丟失。
		[N] 是最大可以開啟的視窗數。'winheight' 也限制開啟的視窗數。
		(如果前加了 |:vertical| 的話 'winwidth')。
		Buf/Win Enter/Leave 自動命令不會被這裡的新視窗執行，只有在它
		們真正進入時才會執行。

:[N]sa[rgument][!] [++opt] [+cmd] [N]			*:sa* *:sargument*
		這是 ":split | argument [N]" 命令的簡寫。分割視窗並切換至第 N
		號引數。但是如果該引數不存在，視窗不會分割。參見 |++opt| 和
		|+cmd|。

:[N]sn[ext][!] [++opt] [+cmd] [file ..]			*:sn* *:snext*
		這是 ":split | [N]next" 命令的簡寫。分割視窗並切換到向後第 N
		個引數。但是如果該引數不存在，視窗不會分割。參見 |++opt| 和
		|+cmd|。

:[N]spr[evious][!] [++opt] [+cmd] [N]			*:spr* *:sprevious*
:[N]sN[ext][!] [++opt] [+cmd] [N]			*:sN* *:sNext*
		這是 ":split | [N]Next" 命令的簡寫。分割視窗並切換到向前第 N
		個引數。但是如果該引數不存在，視窗不會分割。參見 |++opt| 和
		|+cmd|。

						*:sre* *:srewind*
:sre[wind][!] [++opt] [+cmd]
		這是 ":split | rewind" 命令的簡寫。分割視窗並切換到第一個參
		數。但是如果沒有引數列表，視窗不會分割。參見 |++opt| 和
		|+cmd|。

						*:sfir* *:sfirst*
:sfir[st] [++opt] [+cmd]
		與 ":srewind" 相同。

						*:sla* *:slast*
:sla[st][!] [++opt] [+cmd]
		這是 ":split | last" 命令的簡寫。分割視窗並切換到最後一個參
		數。但是如果沒有引數列表，視窗不會分割。參見 |++opt| 和
		|+cmd|。
						*:dr* *:drop*
:dr[op] [++opt] [+cmd] {file} ..
		在一個視窗內編輯第一個 {file}。
		- 如果該檔案已經被開啟，切換至該檔案所在視窗。
		- 如果該檔案尚未被開啟，在當前視窗內開啟該檔案。如果當前視窗
		   無法被放棄 |abandon|，視窗會先被分割。
		- 如果可能的話，關閉不在引數列表裡或不是全寬的視窗。
		引數列表 |argument-list| 會被象使用 |:next| 命令一樣被設定。
		此命令的目的在於: 允許 debugger 之類的程式裡讓 Vim 編輯另一個
		檔案。
		如果使用 |:tab| 修飾符，為每個引數開啟一個標籤頁。如果為空，使
		用最後一個視窗。
		另見 |++opt| 和 |+cmd|。
		{僅當編譯時有 GUI 才可用}

==============================================================================
8. 在所有的緩衝區或窗口裡執行命令				*list-repeat*

							*:windo*
:[range]windo {cmd}	在每一個窗口裡執行 {cmd}，如果給出 [range]，只對視窗號
			在 [range] 內的視窗執行。這就像是: >
				CTRL-W t
				:{cmd}
				CTRL-W w
				:{cmd}
				等等……
<			只在當前標籤頁進行操作。
			如果在一個窗口裡檢測到錯誤，餘下的視窗不再訪問。
			最後一個視窗 (或者出錯的那個視窗) 成為當前視窗。
			{cmd} 可以包含 '|' 來連線多個命令。
			{cmd} 不能開啟或關閉視窗，也不能更換它們的順序。
			{Vi 無此功能} {僅在編譯時加入 |+listcmds| 特性才有效}
			也參見 |:tabdo|、|:argdo|、|:bufdo|、|:cdo|、|:ldo|、
			|:cfdo| 和 |:lfdo|

							*:bufdo*
:[range]bufdo[!] {cmd}	在緩衝區列表的每一個緩衝區裡執行 {cmd}，如果給出
			[range]，只對緩衝區號在 [range] 內的緩衝區執行。
			就像是: >
				:bfirst
				:{cmd}
				:bnext
				:{cmd}
				等等……
<			如果當前檔案不能被丟棄 |abandon|，並且沒有使用 [!]，命
			令失敗。
			當在一個緩衝區裡檢測到錯誤，剩下的緩衝區不再訪問。
			跳過列表外緩衝區。
			最後一個緩衝區 (或者出錯的那個緩衝區) 成為當前緩衝區。
			{cmd} 可以包含 '|' 來連線多個命令。
			{cmd} 不能刪除或新增緩衝區到緩衝區列表。
			備註: 此命令執行時，通過把 Syntax 加入 'eventignore'
			來遮蔽此自動命令事件。這樣大大加快了每個緩衝區的編輯速
			度。
			{Vi 無此功能} {僅在編譯時加入 |+listcmds| 特性才有效}
			也參見 |:tabdo|、|:argdo|、|:windo|、|:cdo|、|:ldo|、
			|:cfdo| 和 |:lfdo|

例子: >

	:windo set nolist nofoldcolumn | normal zn

這個命令會復位 'list' 選項並在所有的窗口裡關閉摺疊功能。 >

	:bufdo set fileencoding= | update

此命令在每個緩衝區裡復位 'fileencoding' 選項的值，並將改動的緩衝區存檔。結果是
所有的緩衝區都會用 'encoding' 編碼 (如果能夠正確轉換的話)。

==============================================================================
9. 當前游標處的標籤和檔名				*window-tag*

							*:sta* *:stag*
:sta[g][!] [tagname]
		執行 ":tag[!] [tagname]" 並且分割視窗開啟新的標籤。參見
		|:tag|。

CTRL-W ]					*CTRL-W_]* *CTRL-W_CTRL-]*
CTRL-W CTRL-]	把當前視窗一分為二，把游標所在的識別符號當作標籤，並在上面的新窗
		口跳轉至標籤所指向的地方。
		可視模式下把可視選擇的文本當作標籤。
		新視窗的高度為 N。

							*CTRL-W_g]*
CTRL-W g ]	把當前視窗一分為二，把游標所在的識別符號當作標籤，並在上面的新窗
		口裡執行 ":tselect"。
		可視模式下把可視選擇的文本當作標籤。
		新視窗的高度為 N。

							*CTRL-W_g_CTRL-]*
CTRL-W g CTRL-]	把當前視窗一分為二，把游標所在的識別符號當作標籤，並在上面的新窗
		口裡執行 ":tjump"。
		可視模式下把可視選擇的文本當作標籤。
		新視窗的高度為 N。

CTRL-W f					*CTRL-W_f* *CTRL-W_CTRL-F*
CTRL-W CTRL-F	把當前視窗一分為二。編輯游標下的檔名。
		類似 ":split gf"，但是找不到檔案或者檔案不存在時，不會分割窗
		口。
		此操作在 'path' 變數所定義的目錄和當前檔案所在的目錄裡尋找文
		件。
		如果是一個類似 "type://machine/path" 的超連結，那麼只使用
		"/path"。
		如果指定了計數 N，那麼編輯第 N 個匹配的檔案。
		{僅在編譯時加入 |+file_in_path| 特性才有效}

CTRL-W F						*CTRL-W_F*
		把當前視窗一分為二。編輯游標下的檔名並跳轉到檔名之後的行號
		上。|gF| 詳細說明該行號如何獲取。
		{僅在編譯時加入 |+file_in_path| 特性才有效}

CTRL-W gf						*CTRL-W_gf*
		開啟新標籤頁，並編輯游標下的檔名。類似於 "tab split" 和
		"gf"，但如果檔案不存在，不建立新標籤頁。
		{僅在編譯時加入 |+file_in_path| 特性才有效}

CTRL-W gF						*CTRL-W_gF*
		開啟新標籤頁，編輯游標下的檔名，並跳轉到檔名之後的行號上。
		類似於 "tab split" 然後 "gF"，但如果檔案不存在，不建立新標籤
		頁。
		{僅在編譯時加入 |+file_in_path| 特性才有效}

另見 |CTRL-W_CTRL-I|: 為包含當前游標下的關鍵字的標頭檔案開啟視窗。

==============================================================================
10. 預覽視窗					*preview-window*

預覽視窗是顯示 (預覽) 其它檔案的特殊視窗。它通常是一個用來檢視包含檔案或者函式
定義的小視窗。{僅當編譯時加入 |+quickfix| 特性才有效}

(每個標籤頁) 只能有一個預覽視窗，可以用如下命令之一建立。另外，'previewheight'
選項可以用來指定預覽視窗的高度；預覽視窗設定 'previewwindow' 選項以便區分。
'winfixheight' 選項也被設定用來保持該視窗的高度，不受其它視窗開關的影響。

						*:pta* *:ptag*
:pta[g][!] [tagname]
		執行 ":tag[!] [tagname]" 並且在預覽窗口裡顯示標籤所指向的內
		容，不改變當前緩衝區和游標的位置。如果預覽視窗已經開啟，則會被
		重用 (類似於幫助視窗)。新預覽視窗的高度由 'previewheight' 決
		定。另見 |:tag|。
		參考下面的例子。|CursorHold-example|
		與 |:tag| 有細小的差別: 當 [tagname] 與當前顯示的標籤相同時，
		該命令不會重新設定標籤匹配表的當前位置。這使 |:ptnext| 執行完
		後，|CursorHold-example| 仍可以執行。

CTRL-W z				*CTRL-W_z*
CTRL-W CTRL-Z				*CTRL-W_CTRL-Z* *:pc* *:pclose*
:pc[lose][!]	關閉當前開啟的預覽視窗。如果置位了 'hidden'，或者更改了緩衝區
		並且使用了 [!]，則緩衝區變為隱藏 (除非還有其它視窗正在編輯該
		緩衝區)。如果預覽視窗的緩衝區不能關閉，此命令失敗。也參見
		|:close|。

							*:pp* *:ppop*
:[count]pp[op][!]
		在預覽視窗執行 ":[count]pop[!]"。參見 |:pop| 和 |:ptag|。
		{Vi 無此功能}

CTRL-W }						*CTRL-W_}*
		使用當前游標所處位置的識別符號作為標籤，執行 :ptag。生成預覽視窗
		(如果需要的話)，視窗的高度為 N，如果沒指定高度，就使用
		'previewheight' 的值。

CTRL-W g }						*CTRL-W_g}*
		使用當前游標所處位置的識別符號作為標籤，執行 :ptjump。生成預覽窗
		口 (如果需要的話)，視窗的高度為 N，如果沒指定高度，就使用
		'previewheight' 的值。

							*:ped* *:pedit*
:ped[it][!] [++opt] [+cmd] {file}
		在預覽窗口裡編輯檔案 {file}。預覽視窗開啟的方式和 |:ptag| 類
		似。當前視窗和游標的位置都不改變。可用例項: >
			:pedit +/fputc /usr/include/stdio.h
<
							*:ps* *:psearch*
:[range]ps[earch][!] [count] [/]pattern[/]
		與 |:ijump| 命令很像，只是找到的匹配在預覽視窗顯示。預覽視窗用
		|:ptag| 開啟。當前視窗和游標的位置都不改變。有用的例子: >
			:psearch popen
<		這很像 |:ptag| 命令，你可以用它自動顯示游標所在單詞的相關信
		息。這個命令雖然不如 |:ptag| 強大，但是你可以不使用標籤檔案，
		而同樣可以找到系統的標頭檔案。例如: >
  :au! CursorHold *.[ch] nested exe "silent! psearch " . expand("<cword>")
<		警告: 可能會很慢。

例子						*CursorHold-example*  >

  :au! CursorHold *.[ch] nested exe "silent! ptag " . expand("<cword>")

如果游標停留達到至少 'updatetime' 指定的時間，這條命令以當前游標位置處的關鍵字
為引數，執行 ":ptag" 命令。"nested" 使得其它自動命令得以執行，這樣可以在預覽窗
口裡啟用語法高亮。"silent!" 遮蔽了在找不到標籤時產生的錯誤資訊。也參見
|CursorHold|。要禁用此功能: >

  :au! CursorHold

更好的改進是能高亮找到的標籤，游標處沒有單詞時不執行 ":ptag"，還能處理一些其它
細節，見下: >

  :au! CursorHold *.[ch] nested call PreviewWord()
  :func PreviewWord()
  :  if &previewwindow			" 不要在預覽窗口裡執行
  :    return
  :  endif
  :  let w = expand("<cword>")		" 在當前游標位置抓詞
  :  if w =~ '\a'			" 如果該單詞包括一個字母
  :
  :    " 在顯示下一個標籤之前，刪除所有現存的語法高亮
  :    silent! wincmd P			" 跳轉至預覽視窗
  :    if &previewwindow		" 如果確實轉到了預覽視窗……
  :      match none			" 刪除語法高亮
  :      wincmd p			" 回到原來的視窗
  :    endif
  :
  :    " 試著顯示當前游標處匹配的標籤
  :    try
  :       exe "ptag " . w
  :    catch
  :      return
  :    endtry
  :
  :    silent! wincmd P			" 跳轉至預覽視窗
  :    if &previewwindow		" 如果確實轉到了預覽視窗……
  :	 if has("folding")
  :	   silent! .foldopen		" 展開摺疊的行
  :	 endif
  :	 call search("$", "b")		" 到前一行的行尾
  :	 let w = substitute(w, '\\', '\\\\', "")
  :	 call search('\<\V' . w . '\>')	" 定位游標在匹配的單詞上
  :	 " 給在此位置的單詞加上匹配高亮
  :      hi previewWord term=bold ctermbg=green guibg=green
  :	 exe 'match previewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'
  :      wincmd p			" 返回原來的視窗
  :    endif
  :  endif
  :endfun

==============================================================================
11. 使用隱藏緩衝區					*buffer-hidden*

隱藏的緩衝區不會在窗口裡顯示，但仍然載入記憶體，這使得 Vim 可以在檔案間切換，而
無需每次在一個窗口裡讀入另一個緩衝區時讀寫檔案。
{僅當編譯時加入 |+listcmds| 特性才有效}

							*:buffer-!*
如果置位了 'hidden' ('hid') 選項，":edit"、":next"、":tag" 等編輯其它檔案的命
令會保留被丟棄的緩衝區。有時雖然沒有置位 'hidden'，一些在緩衝區列表中穿梭的命
令還是會把當前視窗變為隱藏。這種情況發生在: 你試圖用 '!' 從窗口裡強制刪除修改
過的緩衝區。但 'autowrite' 選項關閉或者緩衝區無法寫回，

你可以用任何啟動編輯的命令使隱藏的緩衝區不再隱藏。或者用 ":bdelete" 命令將其刪
除。

'hidden' 是全域性選項，它作用於所有的緩衝區。'bufhidden' 選項可以作用於指定的緩
衝區，該選項可以是下面的值:

	<empty>		使用全域性 'hidden' 的值。
	hide		隱藏該緩衝區，'hidden' 沒有置位也是如此。
	unload		不隱藏，而是解除安裝該緩衝區，'hidden' 置位也是如此。
	delete		刪除該緩衝區。

							*hidden-quit*
如果存在一個隱藏且修改過的緩衝區，退出 Vim 會得到一條錯誤資訊，並且 Vim 會把該
緩衝區變為當前的緩衝區。你可以決定是儲存 (":wq") 還是退出 ( ":q!")。注意: 可
能不止一個這樣的緩衝區！

緩衝區也可能是列表外的 (unlisted)，這意味著此緩衝區存在，但是從緩衝區列表中看
不到。|unlisted-buffer|


:files[!] [flags]				*:files*
:buffers[!] [flags]				*:buffers* *:ls*
:ls[!] [flags]
		顯示所有緩衝區。示例:

			1 #h   "/test/text"		line 1 ~
			2u     "asdf"			line 0 ~
			3 %a + "version.c"		line 1 ~

		如果使用了 [!]，將顯示所有的緩衝區，包括列表外緩衝區
		(此時，"列表外" (unlisted) 這一術語多少有點兒彆扭……)。

		每一個緩衝區都有唯一的號碼與之對應。這個編號是不會改變的，所以
		你可以一直使用 ":buffer N" 或 "N CTRL-^" (N 是緩衝區編號) 來選
		擇特定的緩衝區。

		識別符號號 (同一列上的符號不可能同時出現):
		u	列表外緩衝區 (只有使用 [!] 才能看到) |unlisted-buffer|
		 %	當前窗口裡的緩衝區
		 #	用 ":e #" 或 CTRL-^ 可切換到的輪換緩衝區
		  a	啟用緩衝區: 已載入記憶體並且可見
		  h	隱藏緩衝區: 已載入記憶體但是沒有視窗顯示它
			|hidden-buffer|
		   -	不可更改的緩衝區，選項 'modifiable' 被關閉。
		   =	只讀緩衝區
		    +	已經更改的緩衝區
		    x   有讀錯誤的緩衝區

		[flags] 可以是下面字元的組合，用來限制列出的緩衝區:
		     +   修改過的緩衝區
		     -   'modifiable' 關閉的緩衝區
		     =   只讀緩衝區
		     a   啟用的緩衝區
		     u   列表外緩衝區 (覆蓋 "!")
		     h   隱藏緩衝區
		     x   有讀入錯誤的緩衝區
		     %   當前緩衝區
		     #   輪換緩衝區
		標誌位的組合意味著它們被 "與" 在一起，例如:
		     h+   修改過的隱藏緩衝區
		     a+   修改過的啟用的緩衝區

		|:filter| 的模式匹配顯示的緩衝區名，例如: >
			filter /\.vim/ ls
<
						*:bad* *:badd*
:bad[d]	[+lnum] {fname}
		在緩衝區列表裡新增檔名 {fname}，但是不把該檔案載入記憶體。
		如果指定了 "lnum"，那麼第一次進入緩衝區時，游標會停留在那一
		行。注意 其它 + 後面的命令將被忽略。

:[N]bd[elete][!]			*:bd* *:bdel* *:bdelete* *E516*
:bd[elete][!] [N]
		解除安裝緩衝區 [N] (預設: 當前緩衝區) 並且從緩衝區列表裡刪除該緩衝
		區。如果緩衝區被改動過，那麼該命令將失敗，除非使用 [!]，但是這
		樣所有的改動都會丟失，檔案不受影響。該緩衝區的所有視窗都會關
		閉。如果緩衝區 [N] 是當前的緩衝區，那麼 Vim 會顯示另一個緩衝區
		來代替。具體來說，Vim 會選擇跳轉表裡最新且已經載入的緩衝區。
		實際上，該緩衝區還沒有被完全刪除，但是緩衝區列表把它除名
		|unlisted-buffer|，而且該緩衝區中選項的值、變數、對映和縮寫被
		清空。例如: >
		    :.,$-bdelete    " 刪除從當前開始到倒數第二個的緩衝區
		    :%bdelete	    " 刪除所有緩衝區
<

:bdelete[!] {bufname}						*E93* *E94*
		類似 ":bdelete[!] [N]"，但是使用名字指定緩衝區。
		注意 如果緩衝區名字是一個數字，不能使用名字來訪問；而應用其編
		號代替。如果名字裡含有空格，在空格前插入反斜槓。

:bdelete[!] N1 N2 ...
		對緩衝區 N1、N2、…… 執行 ":bdelete[!]"。引數可以是緩衝區名或號
		(但不能是本身為數字的緩衝區名)。如果名字裡含有空格，在空格前插
		入反斜槓。

:N,Mbdelete[!]	對 N 到 M 號 (包含 N 和 M |inclusive|) 緩衝區執行
		":bdelete[!]"。

:[N]bw[ipeout][!]			*:bw* *:bwipe* *:bwipeout* *E517*
:bw[ipeout][!] {bufname}
:N,Mbw[ipeout][!]
:bw[ipeout][!] N1 N2 ...
		類似 ":bdelete"，但真正刪除緩衝區。所有和緩衝區相關的資訊都丟
		失了。所有位置標記失效，選項丟失，諸如此類。除非你確切地知道自
		己正在做什麼，否則不要使用這個命令。例如: >
		    :.+,$bwipeout   " 真正刪除當前緩衝區之後的所有緩衝區
		    :%bwipeout	    " 真正刪除所有緩衝區
<

:[N]bun[load][!]				*:bun* *:bunload* *E515*
:bun[load][!] [N]
		解除安裝緩衝區 [N] (預設: 當前緩衝區)。原來佔用的記憶體將被釋放。該
		緩衝區還保留在緩衝區列表裡。
		如果緩衝區被改動過，那麼該命令將失敗，除非使用 [!]，但是這樣所
		有的改動都會丟失。
		該緩衝區的所有視窗都會關閉。如果緩衝區 [N] 是當前的緩衝區，那
		麼 Vim 會顯示另一個緩衝區來代替。具體來說，Vim 會選擇跳轉表裡
		最新且已經載入的緩衝區。

:bunload[!] {bufname}
		類似 ":bunload[!] [N]"，但是使用名字指定緩衝區。
		注意 如果緩衝區名字是一個數字，不能使用名字來訪問；而應用其編
		號代替。如果名字裡含有空格，在空格前插入反斜槓。

:N,Mbunload[!]	對 N 到 M 號 (包含 N 和 M |inclusive|) 緩衝區執行
		":bunload[!]" 。

:bunload[!] N1 N2 ...
		對緩衝區 N1、N2、…… 執行 ":bunload[!]"。引數可以是緩衝區名或號
		(但不能是本身為數字的緩衝區名)。如果名字裡含有空格，在空格前插
		入反斜槓。

:[N]b[uffer][!] [+cmd] [N]		*:b* *:bu* *:buf* *:buffer* *E86*
		編輯緩衝區列表中第 [N] 個緩衝區，如果沒指定 [N]，就編輯當前的
		緩衝區。關於 [!] 參見 |:buffer-!|。這個命令同樣可以編輯不在列
		表裡的緩衝區，'buflisted' 不會因而被置位。
		另見 |+cmd|。

:[N]b[uffer][!] [+cmd] {bufname}
		編輯緩衝區列表中 {bufname} 對應的緩衝區。關於 [!] 參見
		|:buffer-!|。這個命令同樣可以編輯不在列表裡的緩衝區，
		'buflisted' 不會因而被置位。
		另見 |+cmd|。

:[N]sb[uffer] [+cmd] [N]				*:sb* *:sbuffer*
		分割視窗並編輯緩衝區列表中第 [N] 個緩衝區，如果沒指定 [N]，就
		編輯當前的緩衝區。分割時，適用 'switchbuf' 的 "useopen" 設定。
		這個命令同樣可以編輯不在列表裡的緩衝區，'buflisted' 不會因而被
		置位。
		另見 |+cmd|。

:[N]sb[uffer] [+cmd] {bufname}
		分割視窗並編輯緩衝區列表中 {bufname} 對應的緩衝區。這個命令同
		樣可以編輯不在列表裡的緩衝區，'buflisted' 不會因而被置位。
		備註: 如果你想做的是分割緩衝區並在另一個名字下建立備份，可以這
		麼做: >
			:w foobar | sp #
<		另見 |+cmd|。

:[N]bn[ext][!] [+cmd] [N]				*:bn* *:bnext* *E87*
		至緩衝區列表裡往後第 [N] 個緩衝區。[N] 預設是 1。如果到了緩衝
		區列表的末尾，則從頭迴圈。
		關於 [!] 參見 |:buffer-!|。
		另見 |+cmd|。
		如果你在幫助緩衝區裡，這條命令讓你跳到後面的幫助緩衝區 (如果有
		的話)。同樣，你在一個正常 (非幫助) 緩衝區裡，就會使你跳到後面
		的正常緩衝區。這樣是為了在開啟幫助的時候不會影響到瀏覽正常的代
		碼或文字。下面三個命令都是如此。

							*:sbn* *:sbnext*
:[N]sbn[ext] [+cmd] [N]
		分割視窗並至緩衝區列表往後第 [N] 個緩衝區。如果到了緩衝區列表
		的末尾，則從頭迴圈。使用 'switchbuf'
		另見 |+cmd|。

:[N]bN[ext][!] [+cmd] [N]		*:bN* *:bNext* *:bp* *:bprevious* *E88*
:[N]bp[revious][!] [+cmd] [N]
		至緩衝區列表往前第 [N] 個緩衝區。[N] 預設是 1。如果到了緩衝區
		列表的頂端，則從末尾往前迴圈。
		關於 [!] 參見 |:buffer-!| 和 'switchbuf'。
		另見 |+cmd|。

:[N]sbN[ext] [+cmd] [N]			*:sbN* *:sbNext* *:sbp* *:sbprevious*
:[N]sbp[revious] [+cmd] [N]
		分割視窗並至緩衝區列表往前第 [N] 個緩衝區。如果到了緩衝區列表
		的頂端，則從末尾往前迴圈。
		使用 'switchbuf'
		另見 |+cmd|。

:br[ewind][!] [+cmd]					*:br* *:brewind*
		至緩衝區列表中的第一個緩衝區。如果列表為空，則轉到第一個列表外
		緩衝區。
		對於 [!] 參見 |:buffer-!|

:bf[irst] [+cmd]					*:bf* *:bfirst*
		與 ":brewind" 相同。
		另見 |+cmd|。

:sbr[ewind] [+cmd]					*:sbr* *:sbrewind*
		分割視窗並至緩衝區列表中的第一個緩衝區。如果列表為空，則轉到第
		一個列表外緩衝區。
		還需考慮 'switchbuf' 選項。
		另見 |+cmd|。

:sbf[irst] [+cmd]					*:sbf* *:sbfirst*
		與 ":sbrewind" 相同。

:bl[ast][!] [+cmd]					*:bl* *:blast*
		至緩衝區列表中的最後一個緩衝區。如果列表為空，則轉到最後一個列
		表外緩衝區。
		對於 [!] 參見 |:buffer-!|

:sbl[ast] [+cmd]					*:sbl* *:sblast*
		分割視窗並至緩衝區列表中的最後一個緩衝區。如果列表為空，則轉到
		最後一個列表外緩衝區。
		還需考慮 'switchbuf' 選項。

:[N]bm[odified][!] [+cmd] [N]			*:bm* *:bmodified* *E84*
		至往後第 [N] 個修改過的緩衝區。備註: 這一命令同樣也能找到列表
		外緩衝區。如果沒有修改的緩衝區，此命令失敗。

:[N]sbm[odified] [+cmd] [N]				*:sbm* *:sbmodified*
		分割視窗並至往後第 [N] 個修改過的緩衝區。
		還需考慮 'switchbuf' 選項。
		備註: 這個命令也能找到不在列表裡的緩衝區。

:[N]unh[ide] [N]			*:unh* *:unhide* *:sun* *:sunhide*
:[N]sun[hide] [N]
		重新排列螢幕，給緩衝區列表中的每一個載入的緩衝區開啟一個視窗。
		如果給出計數，則計數為開啟視窗的最多數目。

:[N]ba[ll] [N]					*:ba* *:ball* *:sba* *:sball*
:[N]sba[ll] [N]	重新排列螢幕，給緩衝區列表中的每一個緩衝區開啟一個視窗。如果給
		出計數，則計數為開啟視窗的最多數目。''winheight' 也限制了開啟
		視窗的數目 (當前綴 |:vertical| 時則為 'winwidth')。
		Buf/Win Enter/Leave 不會在新視窗執行，只有真正進入這些視窗時才
		會。
		如果使用 |:tab| 修飾符，新視窗在新標籤頁上開啟，直到用完
		'tabpagemax' 個標籤頁為止。

備註: 上面所有開始編輯另一個緩衝區的命令維持 'readonly' 的原值。這和 ":edit"
命令不同，它每次讀入檔案時都會設定 'readonly' 標誌位。

==============================================================================
12. 特殊型別緩衝區				*special-buffers*

除了用來存放文字，緩衝區也可以用於其它目的。一些選項可以改變緩衝區的行為:
	'bufhidden'	緩衝區不再在窗口裡顯示時的行為
	'buftype'	緩衝區的型別
	'swapfile'	緩衝區是否需要交換檔案
	'buflisted'	緩衝區是否在緩衝區列表中出現

有用的緩衝區型別:

quickfix	用來存放錯誤列表和位置列表。參見 |:cwindow| 和 |:lwindow|。這
		些命令設定 'buftype' 的值為 "quickfix"。你不應該修改它！
		'swapfile' 為關。

help		包含幫助檔案。只能用 |:help| 命令建立，緩衝區的幫助標誌是內建
		的，不能被更改。選項 'buflisted' 在幫助緩衝區裡被複位。

directory	顯示目錄內容。可用於檔案探索器外掛。該緩衝區由以下設定建立: >
			:setlocal buftype=nowrite
			:setlocal bufhidden=delete
			:setlocal noswapfile
<		緩衝區的名字就是目錄的名字，並且在使用 |:cd| 命令時會作出相應
		的調整。

scratch		該緩衝區包含的文字可以被隨時扔掉。在關閉視窗時，緩衝區被儲存下
		來，要刪除緩衝區必須顯式進行。
		設定如下: >
			:setlocal buftype=nofile
			:setlocal bufhidden=hide
			:setlocal noswapfile
<		如果你能起個有意義的名字，緩衝區的名字可以用來標識該緩衝區。

						*unlisted-buffer*
unlisted	該緩衝區不在緩衝區列表裡。它不能用來編輯，但是可以顯示幫助文
		件、記住檔名或標記。":bdelete" 命令也會設定這個選項，這樣就
		不會完全地刪除該緩衝區。設定如下: >
			:setlocal nobuflisted
<

 vim:tw=78:ts=8:ft=help:norl:
