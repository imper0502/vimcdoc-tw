*usr_28.txt*	For Vim version 8.0.  最近更新: 2013年8月

		     VIM 使用者手冊 - by Bram Moolenaar
		     譯者: Chimin Yen http://vimcdoc.sf.net

				   摺疊


結構化的文字可以分為許多節。而一節之內可以再分小節。摺疊允許你將一節顯示為一
行，並提供文字的概覽。本章將解釋各種實現摺疊的方法。

|28.1|	什麼是摺疊？
|28.2|	手動摺疊
|28.3|	對摺疊的操作
|28.4|	儲存和恢復摺疊
|28.5|	依縮排摺疊
|28.6|	依標誌摺疊
|28.7|	依語法摺疊
|28.8|	依表示式摺疊
|28.9|	摺疊未被改動的行
|28.10|	使用哪種摺疊辦法呢？

       下一章: |usr_29.txt|  在程式碼間移動
       前一章: |usr_27.txt|  查詢命令及模式
         目錄: |usr_toc.txt|

==============================================================================
*28.1*	什麼是摺疊？

摺疊用於把緩衝區內某一範圍內的文字行顯示為螢幕上的一行。就像一張紙，要它縮短
些，可以把它摺疊起來:

	+------------------------+
	| 行 1		 |
	| 行 2		 |
	| 行 3		 |
	|_______________________ |
	\			 \
	 \________________________\
	 / 被摺疊的行		  /
	/________________________/
	| 行 12		 |
	| 行 13		 |
	| 行 14		 |
	+------------------------+

那些文字仍然在緩衝區內而沒有改變。受到摺疊影響的只是文字行顯示的方式。

摺疊的好處是，通過把多行的一節摺疊成帶有摺疊提示的一行，會使你更好地瞭解對文字
的巨集觀結構。

==============================================================================
*28.2*	手動摺疊

試一試: 把游標置於某一段落內，並鍵入: >

	zfap

你將會看到該段落被一行高亮的文字所代替。你已經建立了一個摺疊了。|zf| 是個操作
符，而 |ap| 是一個文字物件。你可以將 |zf| 操作符跟任何一個移動命令聯用，為所經
之處的文字建立一個摺疊。 |zf| 也能在可視模式下使用。

若要再閱讀那些文字，可以鍵入以下命令以開啟該摺疊: >

	zo

你還可以用以下命令再關閉該摺疊: >

	zc

所有的摺疊命令都以 'z' 開頭。展開你的想像力，這個字母看起來就像一張摺疊起來的
紙的側面。而 "z" 後面可用的字母，由於採用了幫助記憶方法選擇，很容易記得住:

	zf	F-old creation (建立摺疊)
	zo	O-pen a fold (開啟摺疊)
	zc	C-lose a fold (關閉摺疊)

摺疊可以巢狀: 一個含有摺疊的文字區可以被再次摺疊。例如，你可以摺疊本節內每一段
落，然後摺疊本章內所有的節。試試看。你將注意到，開啟全章的摺疊，會將節的摺疊還
原得跟以前一樣，有些開啟，而有些關閉。

假定你已經建立了若干摺疊，而現在需要閱覽全部文字。你可以移到每個摺疊處，並鍵入
"zo"。若要做得更快，可以用這個命令: >

	zr

這將減少 (R-educe) 摺疊。相反的操作是: >

	zm

這將摺疊更多 (M-ore)。你可以重複 "zr" 和 "zm" 來開啟和關閉若干層巢狀的摺疊。

如果你有一個嵌套了好幾層深的摺疊，你可以用這個命令把它們全部開啟: >

	zR

這將減少摺疊直至一個也不剩。而用下面這個命令你可以關閉所有的摺疊: >

	zM

這將增加摺疊，直至所有的摺疊都關閉了。

你可以用 |zn| 命令快速禁止摺疊功能。然後 |zN| 恢復原來的摺疊。|zi| 切換於兩者
之間。以下步驟是一種實用的操作方法:
- 建立摺疊，以獲取你的檔案的概覽
- 移動到你要操作的地方
- 執行 |zi| 以便一邊看著文字，一邊編輯
- 再執行 |zi|  以便移動到另一處

在參考手冊中有更多關於手動摺疊的內容: |fold-manual|

==============================================================================
*28.3*	對摺疊的操作

當一些摺疊關閉時，移動命令，如 "j" 和 "k" 會輕鬆的移過摺疊，就像它是單個空行一
樣。這允許你快速移過摺疊了的文字。

你可以向對待單行一樣複製，刪除和貼上摺疊。當你要改動某個程式裡的函式的先後次序
時，這是很實用的。首先，為 'foldmethod' 選擇一個正確的摺疊方法，以保證每個摺疊
包含了整個函式 (或稍缺一點兒)。然後，用 "dd" 命令刪除該函式，移動游標，並用
"p" 命令貼上。如果函式中某些行在摺疊之上，或之下，你可以利用可視模式下的選擇方
法:
- 把游標置於被移文字的首行
- 擊 "V" 鍵開始可視模式
- 把游標置於被移文字的末行
- 擊 "d" 鍵刪除被選中的行。
- 把游標移到新位置，並擊 "p" 鍵把文字貼上在那兒。

有時候，檢視或記住一個摺疊在哪兒，挺不容易的。更別說用 |zo| 命令來打開了。要查
看那些已定義的摺疊: >

	:set foldcolumn=4

這個命令將在視窗左邊顯示一小欄來標識各個摺疊。一個 "+" 表示某個關閉的摺疊。一
個 "-" 表示每個開啟的摺疊的開頭，而 "|" 則表示該摺疊內其餘的行。

你可以在摺疊欄內用滑鼠點選 "+"，以開啟一個摺疊。點選 "-" ，或在它之下的某個
"|" ，將關閉一個開啟的摺疊。

開啟所有游標行上的摺疊用 |zO|。
關閉所有游標行上的摺疊用 |zC|。
刪除一個游標行上的摺疊用 |zd|。
刪除所有游標行上的摺疊用 |zD|。

當你進入插入模式後，游標行上的摺疊永遠不會關閉。那是要讓你看見你打的什麼字！

當游標前後跳轉至摺疊，或在摺疊上左右移動時，摺疊就會自動開啟。例如，零命令 "0"
開啟游標下的摺疊 (假設 'foldopen' 包含 "hor"，即預設設定)。'foldopen' 選項可以
修改，為指定的某一類命令開啟摺疊。如果你要游標遇到摺疊，摺疊就開啟，那麼可以這
麼做: >

	:set foldopen=all

警告: 你將因此無法移到一個關閉的摺疊上。你也許只想臨時用一用這個命令，然後把它
設回預設值: >

	:set foldopen&

你可以在移開摺疊時自動關閉摺疊: >

	:set foldclose=all

這個命令將重新把摺疊級別 'foldlevel' 作用到所有的不含游標的摺疊。你必須自己試
試看你會不會喜歡這個設定。用 |zm| 增加摺疊級別，並用 |zr| 減少摺疊級別 (減少折
疊的層次)。

摺疊是限於本地視窗的。這允許你為同一緩衝區開啟兩個視窗，一個帶摺疊，而另一個不
帶摺疊。或者，一個讓所有的摺疊關閉，而另一個則讓所有的摺疊開啟。

==============================================================================
*28.4*	儲存和恢復摺疊

當你放棄一個檔案時 (開始編輯另一個)，其摺疊狀態就丟失了。如果你稍後再回來編輯
同一檔案，那麼，所有手動開啟和關閉的摺疊，全都恢復到它們的預設狀態了。如果摺疊
是用手動方式建立的，則所有的摺疊都消失了！為了保存摺疊，可以用 |:mkview| 命
令: >

	:mkview

這將儲存那些影響檔案檢視的設定及其它內容。你可以利用 'viewoptions' 選項修改儲
存的範圍。當你稍後回到同一檔案時，你可以重新載入這個檢視: >

	:loadview

你可以為一個檔案儲存多至十個檢視。例如，把當前設定儲存為第三個檢視，並載入第
二個檢視: >

	:mkview 3
	:loadview 2
<
注意 當你插入或刪除一些文字行時，檢視可能變得無效。還得檢查 'viewdir' 選項，它
指定檢視檔案儲存在哪兒。你可能時不時需要刪除舊的檢視檔案。

==============================================================================
*28.5*	依縮排摺疊

使用 |zf| 來定義一個摺疊很費事。如果你的文字依循一種結構，以較多的縮排表示較低
的層次，那麼，你可以採用縮排摺疊的方法。這將為每一系列有相同縮排的行建立一個折
疊。縮排較多的行將成為巢狀的摺疊。縮排摺疊適用於許多程式語言。

我們來試試這個方法。先設定 'foldmethod' 選項: >

	:set foldmethod=indent

然後你可以用 |zm| 和 |zr| 命令增加和減少摺疊。在下面這個例文上很容易看明白:

本行沒有縮排
	本行被縮排一次
		本行被縮排兩次
		本行被縮排兩次
	本行被縮排一次
本行沒有縮排
	本行被縮排一次
	本行被縮排一次

注意 縮排多少和摺疊深度之間的關係倚賴於 'shiftwidth' 選項。每個 'shiftwidth'
選項規定的縮排寬度，在摺疊深度上加一。這被稱為一個摺疊級別。

當你使用 |zr| 和 |zm| 命令時，你實際上是在增加或減少 'foldlevel' 選項。你也可
以直接設定它: >

	:set foldlevel=3

這意味著，所有縮排等於或大於 'shiftwidth' 三倍的摺疊將被關閉。摺疊級別設定得越
低，越多的摺疊將被關閉。當 'foldlevel' 為零時，所有的摺疊都將被關閉。|zM| 把
'foldlevel' 設為零。相反的命令 |zR| 把 'foldlevel' 設為檔案中最深的摺疊級別。

因此，有兩種方法開啟和關閉摺疊:
(A) 設定摺疊級別。
    這提供了一種極快的 "縮小" 方法來檢視文字結構，移動游標，以及重新 "放大" 到
    具體的文字。

(B) 利用 |zo| 和 |zc| 命令開啟和關閉指定的摺疊。
    這個方法允許你僅僅開啟那些你要開啟的摺疊，而不影響其它的摺疊。

這兩種方法可以結合起來用: 你可以先用幾次 |zm| 以關閉大多數摺疊，然後用 |zo|
開啟一個指定的摺疊。或者，用 |zR| 開啟所有的摺疊，然後用 |zc| 關閉指定的摺疊。

但是，當摺疊方法 'foldmethod' 的值為 "indent" 時，你不能手動定義摺疊。因為那樣
會引起縮排寬度和摺疊級別之間的衝突。

在參考手冊中有更多關於縮排摺疊的內容: |fold-indent|

==============================================================================
*28.6*	依標誌摺疊

文字中的標誌用於指定一個摺疊區的起點和終點。標誌摺疊可以精確地控制一個摺疊究竟
包含哪些行文字。缺點是文字需要改動。

試試這個: >

	:set foldmethod=marker

以下列 C 程式片段為例:

	/* foobar () {{{ */
	int foobar()
	{
		/* return a value {{{ */
		return 42;
		/* }}} */
	}
	/* }}} */

請注意，摺疊行將顯示位於標誌之前的文字。這正好用來說明該摺疊包含了什麼。

令人十分困擾的是，當某些文字行移動後，標誌不再正確地配對。這種局面可以利用編號
標誌來避免。例如:

	/* global variables {{{1 */
	int varA，varB;

	/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}

	/* funcB() {{{2 */
	void funcB() {}
	/* }}}1 */

每一個編號標誌表示一個編號指定級別的摺疊的開始。這將使任何較高層次的摺疊在此結
束。你可以只用編號標誌的開始符定義所有的摺疊。只有當你要明確地在另一個開始前結
束一個摺疊時，你才需要加一個標誌停止符。

在參考手冊中有更多關於標誌摺疊的內容: |fold-marker|

==============================================================================
*28.7*	依語法摺疊

Vim 為每一種不同的語言使用一個不同的語法檔案。語法檔案為檔案中各種不同語法項定
義顏色。如果你正用 Vim 在一個支援色彩的終端上閱讀本文，你所看見的色彩就是由語
法檔案 "help" 定製的。
   在語法檔案中，你可以加入一些帶有 "fold" 引數的語法項。這些語法項將定義摺疊
區。這要求寫一個語法檔案，把這些專案加入其中。編寫這樣一個檔案是不容易的。但是
一旦寫成，所有摺疊的建立就變成自動的了。
   在此，我們將假定你正使用一個已經寫好的語法檔案。這樣的話，就沒更多解釋的必
要了。你可以像以上解釋過的那樣開啟和關閉摺疊。編輯檔案時摺疊會自動建立和刪除。

在參考手冊中有更多關於語法摺疊的內容: |fold-syntax|

==============================================================================
*28.8*	依表示式摺疊

表示式摺疊類似於縮排摺疊，但並非利用文字行的縮排，而是呼叫一個函式來計算一行的
摺疊級別。當文字的一部分表明那些行屬於同一組時，你可以使用這個方法。一個例子是
電子郵件，其中引述的文字由行首的 ">" 來表示。要摺疊這些引文，可以用以下命令: >

	:set foldmethod=expr
	:set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^>].*','',''))

你可以在這段文字上試式看:

> quoted text he wrote
> quoted text he wrote
> > double quoted text I wrote
> > double quoted text I wrote

以下是上例中 'foldexpr' 的解釋 (自裡至外):
   getline(v:lnum)			讀取當前行
   substitute(...,'\\s','','g')		從當前行刪除所有空白字元
   substitute(...,'[^>].*','','')	刪除行首那些 '>' 之後的任何字元
   strlen(...)				計算字串的長度，即 '>' 的個數

注意 在 ":set" 命令中，每一個空格，雙引號和反斜線符之前，必須插入一個反斜槓。
如果這會把你搞糊塗，那麼就執行  >

	:set foldexpr

來檢查所產生的實際值。為了修正一個複雜的表示式，請使用命令列補全: >

	:set foldexpr=<Tab>

其中 <Tab> 是一個真實的 Tab 鍵。Vim 將填入以前的值，然後你可以編輯它。

當該表示式變得相對複雜時，你應當將其放入一個函式。然後設定 'foldexpr' 來呼叫該
函式。

在參考手冊中有更多關於表示式摺疊的內容: |fold-expr|

==============================================================================
*28.9*	摺疊未被改動的行

當你在同一視窗也設定 'diff' 選項時，這種摺疊方法就很有用。|vimdiff| 命令為你設
定好了使用未改行摺疊。例如: >

	:setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1

在顯示同一檔案的不同版本的每個視窗內執行這個命令。你將清楚地看到不同檔案間的區
別，因為那些沒改動的文字都被摺疊起來了。

更多細節參見 |fold-diff|。

==============================================================================
*28.10* 使用哪種摺疊辦法呢？

所有這些可能性讓你感到納悶，你究竟應該選擇哪種方法。不幸的是，沒有放之四海皆準
的法則。這裡只給出一些提示。

如果存在一個語法檔案，其中定義的摺疊符合你正在使用的程式語言，那麼，語法摺疊應
該是最好的選擇。否則，你也許得試著寫一個。這要求你相當的瞭解關於查詢模式知識。
這並非易事。但一旦寫成，你將不必以手動的方式定義摺疊了。

鍵入命令，手動摺疊一個個文字區的方法可用於無結構特點的文字。然後用 |:mkview|
命令來儲存和還原摺疊狀態。

標誌摺疊法要求你修改檔案。如果你與它人共享這個檔案，或不得不遵守公司規定的標
準，那麼你也許得不到許可給檔案加標誌。
   標誌摺疊的主要優點是，你可以精確的把標誌放在你要的位置。那樣就避免了那種在
你剪下和貼上摺疊時漏了幾行文字的情況。並且，你還可以加個註釋，說明該摺疊包含些
什麼。

縮排摺疊法是那種在許多檔案裡都用的著。但並不是每次都能成功的方法。當你無法採用
其它方法時，就用這種。然而，縮排摺疊在做提綱時特別有用。你必須為每一層巢狀摺疊
特意的使用同一縮排寬度 'shiftwidth'。

表示式摺疊法能夠在幾乎任何有結構特定的文字中建立摺疊。這種方法相當簡單，尤其當
摺疊的開始和結束處能容易地被識別的時候。
   如果你用 "expr" 方法來定義摺疊而無法得到完全滿意的結果。那麼你可以切換到手
動方法 "manual"。這麼做不會刪除那些已經定義好了的摺疊。之後你便可以手動刪除或
增加摺疊了。

==============================================================================

下一章: |usr_29.txt|  在程式碼間移動

版權: 參見 |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
