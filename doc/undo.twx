*undo.txt*      For Vim version 8.0.  最近更新: 2017年8月


		  VIM 參考手冊    by Bram Moolenaar
			譯者: jwdu, tocer http://vimcdoc.sf.net

撤銷和重做							*undo-redo*

在使用者手冊的 |02.5| 節對它們的基本操作有解釋。

1. 撤銷和重做操作的命令		|undo-commands|
2. 撤銷操作的兩種方法		|undo-two-ways|
3. 撤銷塊			|undo-blocks|
4. 撤銷分支			|undo-branches|
5. 撤銷的永續性 		|undo-persistence|
6. 撤銷操作的解釋		|undo-remarks|

==============================================================================
1. 撤銷和重做命令					*undo-commands*

<Undo>		或					*undo* *<Undo>* *u*
u			撤銷 [count] 次更改。 		{Vi: 僅有一級}

							*:u* *:un* *:undo*
:u[ndo]			撤銷一次更改。  		{Vi: 僅有一級}

								*E830*
:u[ndo] {N}		轉到改變號 {N} 之後。{N} 的含義參見 |undo-branches|。
			{Vi 無此功能}

							*CTRL-R*
CTRL-R			重做 [count] 次被撤銷的更改。	{Vi: 重新整理螢幕}

							*:red* *:redo* *redo*
:red[o]			重做一個被撤銷的更改。		{Vi: 沒有 redo}

							*U*
U			撤銷最近對特定行所作的一系列更改，也就是最近作改變的
			那行。|U| 自己也算一次改變，因此 |U| 會撤銷之前的
			|U|。
			{Vi: 僅當這些修改不超出最近作改變那行的範圍}

由於最近所作的更改是被記住的，因此，你可以應用上面的撤銷和重做命令把檔案倒轉到
你所作每次更改以前的狀態。當然，你也可以重新應用這些修改，把檔案重做到執行撤銷
操作以前的狀態。

對於撤銷/重做 (undo/redo) 來說，"U" 命令和其他命令是同等對待的。所以 "u" 可以
撤銷一個 "U" 命令、'CTRL-R' 也可以重做對 "U" 命令的撤銷。當 "U"、"u" 和
'CTRL-R' 三個命令混合使用時，你將注意到 "U" 命令決意將被該行還原到前一個 "U"
命令之前的狀態。這或許會令你困惑。多試試，你會習慣的。
"U" 命令總是把緩衝區標記為已改變。即使它把修改過的緩衝區重做到未改變的狀態也是
如此。為此，只有使用 "u" 命令，才能令緩衝區正確地回覆到未改變的標記。

==============================================================================
2. 撤銷操作的兩種方法					*undo-two-ways*

撤銷和重做的工作模式依賴於 'cpoptions' 中 'u' 標誌位。這裡有兩種模式，Vim 模式
(不包含 'u') 和 Vi-相容模式 (包含 'u')。在 Vim 模式下，"uu" 命令撤銷兩次改變，
在 Vi-相容模式下，"uu" 命令什麼也不做 (撤銷第一次撤銷)。

不包含 'u' 的 Vim 模式:
及時的撤銷命令可以回到先前的狀態。你也可以使用重做命令再次前進。不過，如果在撤
銷命令後你做了一個新的改變，重做上次的撤銷便不再可能。

包含 'u' 的 Vi-相容模式:
撤銷命令撤銷包含以前的撤銷命令在內的任何更改。重做命令重複前一個撤銷命令。但它
_不_用來重複改變命令。為此請用 "." 命令。

舉例		Vim 模式		Vi-相容模式	~
"uu"		兩次撤銷		空操作
"u CTRL-R"	空操作			兩次撤銷

原理:	Nvi 使用 "." 命令而不是 CTRL-R。不幸的是，這不是 Vi 相容的。例如
	"dwdwu." 命令，在 Vi 中刪除兩個詞，但在 Nvi 中，它什麼也不做。

==============================================================================
3. 撤銷塊						*undo-blocks*

單個 undo 命令通常撤掉一個輸入的命令，不論這個命令造成多少改變。這個可以撤銷的
改變序列構成了一個撤銷塊。所以如果鍵入的命令呼叫一個函式，那麼在這個函式中的所
有命令全部被撤銷。

如果你想編寫一個函式或指令碼，它不包含新的可撤銷之改變，而合併到之前的改變中，用
以下命令:

						*:undoj* *:undojoin* *E790*
:undoj[oin]		把其後的改變和以前的撤銷塊進行合併。
			警告: 小心使用。它會阻止使用者合理地撤銷改變。不要在撤銷
			或重做後使用。
			{Vi 無此功能}

這最適用於在改變的過程中需要提示使用者的場合。例如呼叫 |getchar()| 的函式。確保
在這之前有一個相關的必須與之合併的改變。

這條命令不能單獨工作，因為下一個鍵擊會再次造成新改變。但你可以這麼做: >

	:undojoin | delete

在此之後，"u" 命令會同時撤銷 delete 命令和前一次改變。

要反過來，把一個改動分成兩個撤銷塊，在插入模式下用 CTRL-G u。可用於使某個插入
命令部分可撤銷。譬如可分拆到每個句子。|i_CTRL-G_u|
設定 'undolevels' 的值也會破壞撤銷。即使新值和舊值相同。

==============================================================================
4. 撤銷分支					*undo-branches* *undo-tree*

上面我們只討論了單線的撤銷/重做。但你也可以進行分支。考慮你先撤銷了若干改變，
然後又進行了一些其它的改變。此時，被撤銷的改變就成為一個分支。下面的命令使你能
夠到達那個分支。

這在使用者手冊中有解釋: |usr_32.txt|。

							*:undol* *:undolist*
:undol[ist]		列出改變樹的所有葉結點。例如:
			   number changes  when               saved ~
			       88      88  2010/01/04 14:25:53
			      108     107  08/07 12:47:51
			      136      46  13:33:01             7
			      166     164  3 seconds ago

			"number" 列是改變號。這個編號持續增加，用於標識特定可
			撤銷的改變，參見 |:undo|。
			"changes" 列是樹的根結點到此葉結點所需的改變數目。
			"when" 列是此改變發生的日期時間。四種可能的格式是:
			    N seconds ago
			    HH:MM:SS             時分秒
			    MM/DD HH:MM:SS       同上，還有月日
			    YYYY/MM/DD HH:MM:SS  同上，還有年
			"save" 列給出此改變是否已寫入硬碟和第幾次寫入檔案。可
			用於 |:later| 和 |:earlier| 命令。
			要更詳細的資訊可用 |undotree()| 函式。

							*g-*
g-			轉到較早的文字狀態。如果帶計數，重複那麼多次。
			{Vi 無此功能}
							*:ea* *:earlier*
:earlier {count}	轉到 {count} 次較早的文字狀態。
:earlier {N}s		轉到大約 {N} 秒鐘之前的較早的文字狀態。
:earlier {N}m		轉到大約 {N} 分鐘之前的較早的文字狀態。
:earlier {N}h		轉到大約 {N} 小時之前的較早的文字狀態。
:earlier {N}d		轉到大約 {N} 天之前的較早的文字狀態。

:earlier {N}f		轉到 {N} 次檔案寫入之前的較早的文字狀態。
			如果上次寫入之後有改動，":earlier 1f" 會恢復文字到上次
			寫入時的狀態。否則會轉到再上一次寫入時的狀態。
			如果在第一次檔案寫入的狀態，甚至於從未寫入過檔案，
			":earlier 1f" 會轉到首次改變之前的狀態。

							*g+*
g+			轉到較新的文字狀態。如果帶計數，重複那麼多次。
			{Vi 無此功能}
							*:lat* *:later*
:later {count}	轉到 {count} 次較新的文字狀態。
:later {N}s		轉到大約 {N} 秒鐘之後的較新的文字狀態。
:later {N}m		轉到大約 {N} 分鐘之後的較新的文字狀態。
:later {N}h		轉到大約 {N} 小時之後的較新的文字狀態。
:later {N}d		轉到大約 {N} 天之後的較新的文字狀態。

:later {N}f		轉到 {N} 次檔案寫入之後較新的文字狀態。
			若在在最後一次檔案寫入的狀態，":later 1f" 會轉到最新的
			文字狀態。

注意 如果由於 'undolevels' 選項，撤銷資訊被清空，那麼文字狀態將無法訪問。

在不同時間點上移動的時候，不要奇怪一個時間點會同時發生多個改變。通過撤銷樹跳轉
然後又做了新的改變後就會發生這種情況。

示 例

從這一行開始:
	one two three ~

按三次 "x" 刪除第一個單詞:
	ne two three ~
	e two three ~
	 two three ~

現在按 "u" 三次撤銷:
	e two three ~
	ne two three ~
	one two three ~

按三次 "x" 刪除第二個單詞:
	one wo three ~
	one o three ~
	one  three ~

現在按 "g-" 三次撤銷:
	one o three ~
	one wo three ~
	 two three ~

現在，回到第一個撤銷分支，也就是在刪除 "one" 之後。重複 "g-" 會回到原始文字:
	e two three ~
	ne two three ~
	one two three ~

使用 ":later 1h" 跳到最後一次改變:
	one  three ~

使用 ":earlier 1h" 再次回到開始:
	one two three ~


注意 使用 "u" 和 CTRL-R 無法得到全部可能的文字狀態，但是重複 "g-" 和 "g+" 卻可
以。

==============================================================================
5. 撤銷的永續性			*undo-persistence* *persistent-undo*

解除安裝緩衝區時，Vim 通常會刪除該緩衝區建立的撤銷樹。通過設定 'undofile' 選項，
Vim 會在寫入檔案時自動儲存撤銷歷史，而重新編輯檔案時，恢復撤銷歷史。

'undofile' 選項在寫入檔案之後檢查，而發生在 BufWritePost 自動命令之前。要控制
哪些檔案需要儲存撤銷資訊，可以使用 BufWritePre 自動命令: >
	au BufWritePre /tmp/* setlocal noundofile

Vim 把撤銷樹儲存在一個獨立的撤銷檔案裡，每個編輯的檔案對應一個，使用一個簡單的
方案來對應檔案系統的路徑到撤銷檔名。Vim 會檢測是否某個撤銷檔案不再和寫它時的
那個檔案同步 (使用檔案內容的雜湊值)，如果檔案內容在撤銷檔案寫入後有改動，忽略
撤銷檔案，以防止檔案遭破壞。如果撤銷檔案的擁有者和正在編輯檔案的不同，也忽略
之，除非撤銷檔案的擁有者是當前使用者。設定 'verbose' 可獲取關於開啟檔案的訊息。

撤銷檔案通常儲存在檔案本身相同的目錄裡。這可以用 'undodir' 選項改變。

如果檔案被加密，撤銷檔案的檔案也會加密。使用相同的金鑰和方法。|encryption|

你也可以用 ":wundo" 和 ":rundo" 來相應地儲存和恢復撤銷歷史:
							*:wundo* *:rundo*
:wundo[!] {file}
		把撤銷歷史寫入 {file}。
		如果 {file} 已存在而看起來不像撤銷檔案 (檔案頭部的魔術數字不
		符)，此命令失敗。除非加上 !。
		如果檔案存在且看起來像撤銷檔案，覆蓋之。如果沒有撤銷歷史，不
		寫入任何東西。
		實現細節: 覆蓋操作如此執行，先刪除已有的檔案，然後建立同名的
		檔案。所以，不能在防寫目錄裡覆蓋已有的撤銷檔案。
		{Vi 無此功能}

:rundo {file}	從 {file} 讀出撤銷歷史。
		{Vi 無此功能}

你可以在自動命令中用這些命令來顯式指定歷史檔名。例如: >

	au BufReadPost * call ReadUndo()
	au BufWritePost * call WriteUndo()
	func ReadUndo()
	  if filereadable(expand('%:h'). '/UNDO/' . expand('%:t'))
	    rundo %:h/UNDO/%:t
	  endif
	endfunc
	func WriteUndo()
	  let dirname = expand('%:h') . '/UNDO'
	  if !isdirectory(dirname)
	    call mkdir(dirname)
	  endif
	  wundo %:h/UNDO/%:t
	endfunc

此時，應該關閉 'undofile'，否則每次寫入檔案時會有兩個撤銷檔案。

可以用 |undofile()| 函式來確定 Vim 會使用的檔名。

注意: 讀寫檔案時，如果設定了 'undofile'，大部分的錯誤資訊會被遮蔽，除非設定了
'verbose'。而 :wundo 和 :rundo 會得到更到的錯誤資訊，如檔案不能讀或寫等。

注意: Vim 從不刪除撤銷檔案。你需要自己進行清除。

讀出已經存在的撤銷檔案可能會有以下的失敗原因:
*E822*	不能開啟，檔案許可許可權不許可。
*E823*	檔案頭的魔術數字不符。通常這意味著這不是一個撤銷檔案。
*E824*	撤銷檔案的版本號說明它是由更新的 Vim 版本寫入的。需要更新的版本來讀。
	如果你想保留該檔案中的撤銷資訊，不要寫入緩衝區。
"File contents changed, cannot use undo info"
	檔案文字和撤銷檔案寫入時的不同。這意味著不再能使用該撤銷檔案，否則會破
	壞文字。這也可能是因為 'encoding' 和撤銷檔案寫入時的不同。
*E825*	撤銷檔案沒有合法的內容，不能使用。
*E826*	撤銷檔案經過加密而解密失敗。
*E827*	撤銷檔案經過加密而此版本的 Vim 不支援加密。用別的 Vim 開啟該檔案。
*E832*	撤銷檔案經過加密而 'key' 沒有設定，文字檔案本身沒有加密。這可能是因為
	文字檔案本來是由 Vim 用加密方式寫入的，後來又用非加密方式進行了覆蓋。
	最好刪除該撤銷檔案。
"Not reading undo file, owner differs"
	撤銷檔案的擁有者和文字檔案的擁有者不同。因為安全原因，不使用該撤銷文
	件。

寫入撤銷檔案可能會有以下的失敗原因:
*E828*	待寫入的檔案不能建立。可能你沒有該目錄的寫入許可權。
"Cannot write undo file in any directory in 'undodir'"
	'undodir' 裡沒有一個可用的目錄。
"Will not overwrite with undo file, cannot read"
	待寫入的撤銷檔案已經存在，但不能讀回。你需要先刪除或改名。
"Will not overwrite, this is not an undo file"
	待寫入的撤銷檔案已經存在，但開頭沒有正確的魔術數字。你需要先刪除或改
	名。
"Skipping undo file write, nothing to undo"
	沒有可寫的撤銷資訊，沒有任何改變，或者 'undolevels' 為負。
*E829*	寫入撤銷檔案時有錯。可以多試幾次。

==============================================================================
6. 撤銷操作的解釋					*undo-remarks*

能記憶的最大改變次數由 'undolevels' 選項決定。如果它的值是零，我們總是執行在
Vi-相容模式。如果它的值是負的，任何撤銷都是不可能的。這隻有在記憶體緊張的時候適
用。

							*clear-undo*
如果設定 'undolevels' 為 -1，撤銷資訊不會立即清除。當有新改變時才會。要強迫清
除撤銷資訊，可以用: >
	:let old_undolevels = &undolevels
	:set undolevels=-1
	:exe "normal a \<BS>\<Esc>"
	:let &undolevels = old_undolevels
	:unlet old_undolevels

當前緩衝區的位置標記 ('a 至 'z) 隨文字一起被儲存和復原。{Vi 的做法稍有不同}

當所有的改變都被撤銷時，緩衝區被標記為未改變。這時可以使用 ":q" 而不一定是
":q!" 退出 Vim 。{Vi 並非如此} 注意未改變是相對檔案的最後寫入而言的。在寫入
":w" 後緊跟的撤銷 "u"，實際上改變了被寫入以後緩衝區的狀態。因此，此時緩衝區應
被視為已改變。

當使用手動 |folding| 時，摺疊不會被儲存和復原。只有完全發生摺疊內部的改變才不
會影響該摺疊，因為它開頭和最後一行沒有改變。

數字編號的暫存器也可以被用作撤銷刪除操作。你每一次刪除文字，該文字被放在 "1 寄
存器中。同樣的，"1 暫存器的內容被移到 "2 暫存器，依次類推。"9 暫存器的內容則會
丟失。現在，你可以通過命令 '"1P' 得到最近刪除的文字。(如果被刪除的內容來自最近
的刪除或複製操作，'P' 或 'p' 同樣也可得到你要的結果，因為他們會複製未命名寄存
器的內容)。使用 '"3P' 可以得到三個刪除操作之前的文字。

							*redo-register*
如果你想得到多於一處被刪除文字的內容，你可以使用重複命令 "." 一個特殊的特性:
它會遞增所使用暫存器內的序號。所以，你如果先使用 ""1P" ，那麼接下來的 "." 就意
味著 '"2P 。重複這樣的操作，所有編號的暫存器都會被插入。

例如: 如果你用 'dd....' 刪除了內容 (五行文字)，那麼用 '"1P....' 可以恢復之。

如果你不知道被刪除的內容在哪一個暫存器，你可以用 |:display| 命令。還有一個方法
就是先試第一個暫存器 '"1P' ，如果不對，用 'u.' 命令。這將會移走第一次放進的內
容，然後在第二個暫存器上重複 put 命令。重複使用 'u.' 直到你得到想要的內容為
止。

 vim:tw=78:ts=8:ft=help:norl:
