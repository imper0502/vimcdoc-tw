*usr_30.txt*	For Vim version 8.0.  最近更新: 2017年8月

		     VIM 使用者手冊 - by Bram Moolenaar
		     譯者: wandys  http://vimcdoc.sf.net

			      編輯程式


Vim 有很多幫助編寫程式程式碼的命令。例如: 直接在 Vim 內編譯程式並跳轉到出錯位
置；根據語言種類自動設定縮排，還有對註釋進行排版。


|30.1|	編譯
|30.2|	C 檔案縮排
|30.3|	自動縮排
|30.4|	其它縮排
|30.5|	製表符和空格
|30.6|	排版註釋格式

     下一章: |usr_31.txt|  使用 GUI
     前一章: |usr_29.txt|  在程式碼間移動
       目錄: |usr_toc.txt|

==============================================================================
*30.1*	編譯

Vim 有個 "quickfix" 命令集。通過這些命令，你可在 Vim 內編譯程式並能直接跳轉到
出錯位置進行修正。你可以接著重新編譯並做修正，直到不再出錯為止。

下面的命令執行 "make" (包括你所給出的引數) 程式並捕捉其執行結果: >

	:make {arguments}

如果有錯誤產生那麼它們將被捕獲到。而且游標會停留在出現第一個錯誤的地方。
   讓我們看一個 "make" 的例子。當輸入 ":make" 後，螢幕出現如下的結果:

	:!make | &tee /tmp/vim215953.err ~
	gcc -g -Wall -o prog main.c sub.c ~
	main.c: In function 'main': ~
	main.c:6: too many arguments to function 'do_sub' ~
	main.c: At top level: ~
	main.c:10: parse error before '}' ~
	make: *** [prog] Error 1 ~

	2 returned ~
	"main.c" 11L, 111C ~
	(3 of 6): too many arguments to function 'do_sub' ~
	Press ENTER or type command to continue ~

你會看到編譯 "main.c" 檔案 (見下) 出現的錯誤。按一下 <Enter>，Vim 會顯示檔案
"main.c" 並將游標移到第一個出現錯誤行。你無需指定檔名或具體的行號，Vim 會根
據出錯資訊定位相關位置。


		+---------------------------------------------------+
		|int main()					    |
		|{						    |
		|	int i=3;				    |
        游標 -> |	do_sub("foo");				    |
		|	++i;					    |
		|	return (0);				    |
		|}						    |
		|}						    |
		| ~						    |
		|(3 of 12): too many arguments to function 'do_sub' |
		+---------------------------------------------------+

這個命令將游標移到下一個錯誤所在的行: >

	:cnext

游標跳轉到檔案的最後一行 (第十行)，那裡有一個多餘的 '}'。
  有時由於空間不夠，Vim 會縮短出錯資訊。如果你想檢視詳細資訊，可執行: >

	:cc

你可以通過 ":clist" 命令得到一個有關所有出錯資訊的概覽。輸出的內容如下所示: >

	:clist
<	3 main.c: 6:too many arguments to function 'do_sub' ~
	5 main.c: 10:parse error before '}' ~

只有那些含有檔名或行數的錯誤資訊會被顯示。Vim 假定你對其它的資訊不敢興趣。有
時你也許需要檢視那些並不含檔名或行數的資訊 (比如聯結器輸出的有關未定義函式的
錯誤資訊)。要檢視所有資訊，在命令後加上 "!" 就可以:
>
	:clist!
<	1 gcc -g -Wall -o prog main.c sub.c ~
	2 main.c: In function 'main': ~
	3 main.c:6: too many arguments to function 'do_sub' ~
	4 main.c: At top level: ~
	5 main.c:10: parse error before '}' ~
	6 make: *** [prog] Error 1 ~

Vim 會高亮顯示當前錯誤。如果你想回到上一個錯誤，執行:
>
	:cprevious

以下是一些其它的跳轉命令:

	:cfirst		到第一處錯誤
	:clast		到最後一處錯誤
	:cc 3		到第三處錯誤


指 定 編 譯 器

通過 'makeprg' 選項可以指定 ":make" 命令啟動的程式名。通常它被設定為 "make"。
但 Visual C++ 的使用者需要將它設定為 "nmake":
>
	:set makeprg=nmake

你可以對這個選項指定引數。如有特殊字元，請用 '\' 來轉義。比如:
>
	:set makeprg=nmake\ -f\ project.mak

你還可以使用特殊的 Vim 內部關鍵字。比如用 '%' 來代替當前檔名: >
	:set makeprg=make\ %:S

這樣，當你編輯檔案 "main.c" 時，執行 ":make" 命令會執行下面的程式:
>
	make main.c

這不太有用，所以你需要用 :r (root) 修飾符來稍稍修改一下:
>
	:set makeprg=make\ %:r:S.o

現在執行的程式就成了:
>
	make main.o

有關修飾符的更多資訊，請檢視這裡: |filename-modifiers|。


舊 的 出 錯 信 息 列 表

假設你用 ":make" 編譯了一個程式。其中的一個檔案裡有個警告 (warning) 資訊而另一
個檔案中有一個出錯 (error) 資訊。你修改了這個錯誤，並再次執行 ":make" 以參看它
是否已被糾正。現在你想檢視剛才的那個警告資訊。但由於含有警告的那個檔案並沒有被
重新編譯，你無法在當前出錯資訊列表中看到原來的警告資訊。在這種情況下，你可以用
下面的命令來檢視上一個出錯資訊列表:
>
	:colder

然後你可以通過 ":clist" 和 ":cc {nr}" 命令來跳轉到出現警告的地方。
   要檢視下一個出錯列表:
>
	:cnewer

Vim 可以記住十個出錯資訊列表。


更 換 編 譯 器

要做到這一點，你需要告訴 Vim 所使用編譯器產生的錯誤資訊格式。這可以通過
'errorformat' 來設定。這個選項幾乎可以配合任意一個編譯器的使用，但它的具體配置
卻很複雜。請在這裡檢視詳細解釋: |errorformat|。

你可能會用到多種不同的編譯器。每次都設定 'makeprg' 選項，尤其是 'errorformat'
選項是很繁雜的。為此，Vim 提供一個簡便的方法。比如: 要使用微軟的 Visual C++ 編
譯器:
>
	:compiler msvc

這個命令會找到適合 "msvc" 編譯器的 Vim 指令碼檔案並設定相關選項。
   你可以為編譯器編寫自己的指令碼檔案。請參考 |write-compiler-plugin|。


輸 出 重 定 向

"make" 命令會將執行結果重定向到一個錯誤檔案中。具體的工作方式取決於很多方面，
比如 'shell' 選項。如果你的 ":make" 命令不能捕獲輸出，請檢查 'makeef' 和
'shellpipe' 選項。選項 'shellquote' 和 'shellxquote' 可能也會起作用。

如果你無法利用 ":make" 命令重定向輸出，一種變通的方法是在另一個視窗編譯程式並
將輸出重定向到一個檔案中。然後你可在 Vim 中檢視此檔案:
>
	:cfile {filename}

這樣，你就可以像執行 ":make" 命令那樣跳轉到出錯的地方。

==============================================================================
*30.2*	C 風格檔案縮排

合理的縮排會使程式更容易理解。Vim 提供了多種方法來簡化這項工作。要對 C 或 C 風
格如 Java 或 C++ 的程式縮排，請設定 'cindent' 選項。Vim 相當地瞭解 C 程式，它
會盡可能地為你自動縮排。通過 'shiftwidth' 選項，你可以指定下一級的縮排空格數。
4 個空格的效果很好。用一個 ":set" 命令就可做到:
>
	:set cindent shiftwidth=4

設定了這一選項之後，當你輸入了一個語句，比如 "if (x)" 後，下一行會自動向下一級
縮排。

				    if (flag)
	自動縮排           --->		do_the_work();
	自動取消縮排       <--	    if (other_flag) {
	自動縮排           --->		do_file();
	保持縮排			do_some_more();
	自動取消縮排       <--	    }

當你在大括號 ({}) 內輸入時，語句會在開始處縮排，而在結束處取消縮排。每次輸入
'}' 後都會取消縮排，因為 Vim 不知道你下一步將要輸入什麼。

自動縮排還能幫助你提前發現程式碼中的錯誤。比如當你輸入了一個 '}' 後，如果發現比
預想中的縮排多，那可能缺少了一個 '}'。請用 "%" 命令查詢與你輸入的 '}' 相匹配的
'{'。
   缺少 ')' 和 ';' 同樣會引起額外的縮排。當你發現比預料中多空白時，最好檢查一
下之前的程式碼。

當你的程式碼沒有被正確地排版，或者你插入或刪除了某些行時，你需要重新進行程式碼縮
進。操作符 "=" 能完成這項功能，最簡單的格式是:
>
	==

這會縮排當前行。像其它的操作符一樣，有三種方式使用它。可視模式下，"=" 縮排選中
的行。一個有用的文字物件是 "a{"。它會選中當前 {} 區。這樣，要重新縮排游標所在
程式碼塊:
>
	=a{

你還可以重新縮排整個檔案:
>
	gg=G

但是，不要對已經手工縮排的檔案使用此命令。自動縮排的確做得很好，但在某些情況下
你也許確實需要手工縮排。


設 定 縮 進 風 格

不同的人有不同的縮排風格。在預設情況下，Vim 採用了 90% 的程式設計師都使用的一種方
式並能很好地完成工作。但是，如果你想使用其它的風格，你可以通過 'cinoptions' 選
項來設定。
   'cinoptions' 預設為空，Vim 會使用預設風格。你可以在你希望改變的地方新增相應
的專案。例如，要使大括號的縮排如下所示:

	if (flag) ~
	  { ~
	    i = 8; ~
	    j = 0; ~
	  } ~

請使用這個命令:
>
	:set cinoptions+={2

還有很多其它的專案可供使用。請參考 |cinoptions-values|。

==============================================================================
*30.3*	自動縮排

你無需每次編輯 C 檔案時都手工設定 'cindent' 選項。通過下面的命令你可以使它自動
化:
>
	:filetype indent on

實際上，它不僅為 C 檔案打開了 'cindent' 選項。首先，它會使 Vim 自動檢查檔案類
型。語法高亮同樣需要此功能。
   一旦檔案型別被識別，Vim 會為此型別的檔案查詢相關的縮排檔案。(Vim 的發行中包
含了適合多種不同程式語言的縮排檔案。) 該縮排檔案將會被用來縮排當前檔案。

如果你不喜歡這項功能，可以將它關閉:
>
	:filetype indent off

如果你不想為某種特定型別的檔案進行縮排，你可以這樣做:
首先建一個只包括下行的檔案:
>
	:let b:did_indent = 1

然後將其重新命名為:

	{directory}/indent/{filetype}.vim

{filetype} 是檔案型別的名字，比如 "cpp" 或 "java"。你可以用下面的命令來得到
Vim 識別到的檔案型別名:
>
	:set filetype

對本檔案，輸出會是:

	filetype=help ~

這樣你就可以用 "help" 來表示 {filetype}。
   對 {directory} 部分，你需要根據你的執行時目錄來設定。請檢視下面命令的輸
出:
>
	set runtimepath

請使用第一項 (也就是第一個逗號前的名字)。如果上面命令的輸出是:

	runtimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after ~

你需要使用 "~/.vim" 來表示 {directory}。這樣最後的檔名就是:

	~/.vim/indent/help.vim ~

除了關閉縮排選項，你還可以編寫自己的縮排檔案。請參考 |indent-expression|。

==============================================================================
*30.4*	其它縮排

最簡單的自動縮排通過 'autoindent' 選項來完成，它會延續上一行的縮排。稍微聰明點
的是 'smartindent'，這個選項對那些沒有縮排檔案可用的程式語言很有用。
'smartindent' 選項沒有 'cindent' 選項聰明，但要比 'autoindent' 聰明些。
   如果 'smartindent' 被設定，會在每個 '{' 處新增一級縮排，並在每個 '}' 處消
減。另外，對於 'cinwords' 選項所設定的所有單詞也會新增新一級的縮排。所有以 '#'
開始的行都會被特殊處理: 所有縮排都被清除。這樣做是為了保持所有的預處理命令都在
第一列開始。縮排會在下一行中恢復。


修 正 縮 進

當你利用 'autoindent' 和 'smartindent' 選項延續上一行的縮排時，有很多時候你都
需要新增或刪除一個 'shiftwidth' 寬度的縮排。一個快速的方法是在插入模式下利用
CTRL-D 和 CTRL-T 命令。
   比如，當你需要輸入以下的 shell 指令碼時:

	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	fi ~

設定了這樣的選項:
>
	:set autoindent shiftwidth=3

你先輸入了第一行，按下回車後又輸入了第二行的開頭:

	if test -n a; then ~
	echo ~

這時你會發現你需要一個額外的縮排。輸入 CTRL-T，結果變為:

	if test -n a; then ~
	   echo ~

在插入模式下，CTRL-T 命令會加入一個 'shiftwidth' 寬度的縮排，無論游標在當前行
的什麼位置。
   你繼續輸入第二行，按下回車後又輸入了第三行。現在的縮排一切正常。然後你按下
回車輸入最後一行，現在的情況如下所示:

	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	   fi ~

要刪除這個多餘的縮排，可以在最後一行輸入 CTRL-D。這會刪除一個 'shiftwidth' 寬
度的縮排，無論游標在行中的什麼位置。
   在普通模式下，你可以用 ">>" 和 "<<" 命令來完成縮排的修正。'>' 和 '<' 是操作
符，因此你可以使用通常的那三種方式來指定你要縮排的行。一個有用的組合是:
>
	>i{

這個命令會縮排當前 {} 區內的行，'{' 和 '}' 本身並不被縮排。">a{" 會包括它們。
在下面的例子中，游標停留在 "printf" 上:

	原文			">i{" 之後		">a{" 之後

	if (flag)		if (flag)		if (flag) ~
	{			{			    { ~
	printf("yes");		    printf("yes");	    printf("yes"); ~
	flag = 0;		    flag = 0;		    flag = 0;  ~
	}			}			    } ~

==============================================================================
*30.5*	製表符和空格

'tabstop' 在預設狀態下被設定為 8。儘管你可以改變它，但很快你就會遇到麻煩。其它
的程式不知道你用的製表符間隔值是多少，你的檔案看起來會一下子改變許多。另外，很
多印表機都將製表符間隔值固定為 8。所以最好還是保留 'tabstop' 值不變。(如果你編
輯使用其它製表符間隔值的檔案，請參考 |25.3| 來修正。)
   如果使用 8 個空格來縮排程式，你很快就會走到視窗的最右端；而用 1 個空格又看
不出足夠的差別。因此很多人喜歡用 4 個空格。這的確是個很好的折衷。
   由於一個製表符 (<Tab>) 是 8 個空格，而你又想使用 4 個空格來縮排，這樣你就無
法使用製表符來完成縮排。這裡有兩種解決辦法:

1. 混合使用製表符和空格。由於一個製表符佔用 8 個空格的位置，你的檔案會含有更少
的位元組數。插入或刪除一個製表符也要比 8 個空格快很多。

2. 只用空格。這就避免了那些使用不同製表符間隔值的檔案所帶來的麻煩。

幸運的是，Vim 能夠同時很好地支援這兩種方式。


混 合 使 用 空 格 和 制 表 符

如果你使用製表符和空格的組合，你直接按正常情況編輯就行。Vim 預設狀態下，能夠很
好地處理這些情況。
   通過設定 'softtabstop' 可以使工作變得更簡便。這個選項能使 <Tab> 看起來像是
被設定為 'softtabstop' 所指定的值，但實際上使用的確是製表符和空格的組合。
   當你執行下面的命令後，你每次按下 <Tab> 鍵，游標都會移動到下一個 "4 列" 邊
界:
>
	:set softtabstop=4
<
當你在第一列按下 <Tab> 鍵後，4 個空格會插入到文字中；再次按下 <Tab> 鍵，Vim 會
先刪除那 4 個空格，然後再插入一個製表符。Vim 會盡可能地使用製表符，並輔以空格
填補。
   刪除會以相反的方式進行。<BS> 鍵總是刪除 'softtabstop' 指定的數量。Vim 儘可
能地使用製表符，而用空格來填補空隙。
   下面的例子顯示了多次輸入製表符然後使用 <BS> 的情況。"." 代表一個空格而
"------->" 代表製表符。

	輸入			  結果 ~
	<Tab>			  ....
	<Tab><Tab>		  ------->
	<Tab><Tab><Tab>		  ------->....
	<Tab><Tab><Tab><BS>	  ------->
	<Tab><Tab><Tab><BS><BS>   ....

另一種方法是使用 'smarttab' 選項。當它被設定，Vim 對每個在縮排行中的製表符使用
'shiftwidth'，而對在第一個非空字元後輸入的 <Tab> 使用真的製表符。但 <BS> 鍵不
會像在 'softtabstop' 選項下那樣工作。


只 用 空 格

如果你不想在檔案中出現製表符，可以設定 'expandtab' 選項:
>
	:set expandtab
<
當這個選項被設定，<Tab>鍵會插入一系列的空格。這樣你可以獲得如同插入一個製表符
一樣數量的空格。但你的檔案中並不包含真正的製表符。
  退格鍵 (<BS>) 每次只能刪除一個空格。這樣如果你鍵入了一個 <Tab>，你需要鍵入
8 次 <BS> 才能恢復。如果你在調整縮排中，輸入 CTRL-D 會更快些。


制 表 符 與 空 格 的 相 互 轉 換

設定 'expandtab' 選項並不會影響已有的製表符。如果你想將製表符轉換為空格，可以
用 ":retab" 命令。使用下面的命令:
>
	:set expandtab
	:%retab

Vim 會在所有縮排中使用空格而非製表符。但是，所有非空字元後的製表符不會受到影
響。如果你想要轉化這些製表符，需要在命令中加入 !:
>
	:%retab!

這不大安全。因為它也許會修改字串內的製表符。要檢查這種情況是否存在，可以執
行:
>
	/"[^"\t]*\t[^"]*"

這裡建議你不要在字串中直接使用製表符。請用 "\t" 來替代，麻煩會少些。

將空格轉化為製表符的命令則恰好相反:
>
	:set noexpandtab
	:%retab!

==============================================================================
*30.6*	排版註釋格式

Vim 最了不起的地方之一就是它理解註釋。你可以要求 Vim 排版一段註釋。它會做得很
出色。
   比如，你有下面的一段註釋:

	/* ~
	 * This is a test ~
	 * of the text formatting. ~
	 */ ~

你可以要求 Vim 排版這段註釋。將游標定位到註釋開頭，然後輸入:
>
	gq]/

"gq" 是用來排版文字的操作符。"]/" 是移動到註釋尾的動作。命令的結果是:

	/* ~
	 * This is a test of the text formatting. ~
	 */ ~

注意 Vim 可以正確處理每行的開頭。
  另外一種方法是在可視模式下用 "gq" 排版選中的文字。

要在註釋中加入新的一行，先將游標移到中間一行，然後按 "o"。結果會如下所示:

	/* ~
	 * This is a test of the text formatting. ~
	 * ~
	 */ ~

Vim 會為你自動新增一個星號和空格，現在你可以輸入新的註釋。如果一行註釋長於
'textwidth'，Vim 會將其自動分開。同樣，星號和空格會被自動新增進來:

	/* ~
	 * This is a test of the text formatting. ~
	 * Typing a lot of text here will make Vim ~
	 * break ~
	 */ ~

要使用這些功能，你必須在 'formatoptions' 選項中指定一些標誌位:

	r	在插入模式下，輸入回車時插入星號。
	o	在普通模式下，使用 "o" 或 "O" 時插入星號。
	c	根據 'textwidth' 將註釋分行。

更多標誌位請參考 |fo-table|。


定 義 注 釋

'comments' 選項可以定義註釋的樣式。Vim 可以分辨單行註釋和那些包含開頭，中間，
結尾三部分的註釋。
   很多單行註釋都是以一個特殊的字元開頭。在 C++ 中是 //，在 Makefile 中是 #，
在 Vim 指令碼中是 "。比如，要使 Vim 理解 C++ 註釋:
>
	:set comments=://
<
冒號將條目的標誌位和用來識別註釋的字元分開。'comments' 的一般格式是:

	{flags}:{text}

{flags} 部分可以為空 (就像本例)。
   不同的條目可以連線在一起，用逗號隔開。這樣可以在同時識別多種不同的註釋。比
如，讓我們編輯一個 email 資訊。當回覆時，別人寫的內容會以 ">" 和 "!" 字元開
頭:
>
	:set comments=n:>,n:!

這裡有兩個條目。一個識別以 ">" 開頭的註釋，一個識別以 "!" 開頭的註釋。兩個都設
定了 "n" 標誌位，這意味著註釋可以巢狀。也就是說，一個以 ">" 開始的行可以在 ">"
之後包括其它的註釋符號。這樣就可以用來排版下面的文字了:

        > ! Did you see that site? ~
	> ! It looks really great. ~
	> I don't like it.  The ~
	> colors are terrible. ~
	What is the URL of that ~
	site? ~

試著將 'textwidth' 設定為其它的值，例如 80。在可視模式下選中註釋，然後輸入
"gq"。結果為:

	> ! Did you see that site? It looks really great. ~
	> I don't like it.  The colors are terrible. ~
	What is the URL of that site? ~

你會注意到 Vim 並沒有將文字從一種註釋移動到另一種註釋。因為第一行以 ">!" 開
頭，而第二行以 ">" 開頭，Vim 知道它們是不同的註釋，所以第二行的 "I" 並沒有移到
上一行。


包 括 三 部 分 的 注 釋

C 語言註釋的樣式是: 以 "/*" 開頭，中間含有 "*"，以 "*/" 結尾。我們可以通過
'comments' 選項來這樣進行設定:
>
	:set comments=s1:/*,mb:*,ex:*/

開始部分用 "s1:/*" 定義。"s" 表示三部分註釋的開始。冒號將標誌位與代表註釋的特
殊字元 "/*" 分開。這裡有一個標誌位 "1"。它指明註釋的中間部分有一個空格位置的偏
移。
   "mb:*" 的 "m" 表示這是註釋的中間部分。"b" 標誌位表示星號後要有空格。否則
Vim 會將形如 "*pointer" 的語句視為某個註釋的中間部分。
   "ex:*/" 中的 "e" 表示註釋的結尾。"x" 標誌位表示在 Vim 自動插入星號後，輸入
"/" 會刪除多餘的空格。

要了解更多細節，請參考 |format-comments|。

==============================================================================

下一章:  |usr_31.txt|  使用 GUI

版權:  參見 |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
